<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随手记</title>
  
  <subtitle>不积跬步无以至千里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-29T03:12:26.453Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>马建</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Native 自签名Https处理</title>
    <link href="http://yoursite.com/2018/03/28/react-native-https/"/>
    <id>http://yoursite.com/2018/03/28/react-native-https/</id>
    <published>2018-03-28T07:43:22.000Z</published>
    <updated>2018-03-29T03:12:26.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>现在绝大多数网站已转为https方式浏览，但很多情况下https的证书并不是CA颁发的合法证书，而是通过公司或个人自签名产生的证书。当我们在开发移动应用时，对于这种自签名证书，通常是需要额外的通过证书来校验访问的合法性。<br>当我们再开发React Native应用时，由于框架封装了网络请求库，造成我们无法自定义相关逻辑。本文的主要目的就是记录一下再开发过程中遇到此类问题是怎么解决的。</p><h2 id="IOS处理"><a href="#IOS处理" class="headerlink" title="IOS处理"></a>IOS处理</h2><ol><li>使用Xcode打开ios代码</li><li>在<code>Libraries</code>下展开 <code>RCTNetwork.xcodeproj</code> 找到 <code>RCTHTTPRequestHandler.m</code> 文件<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/03/28/react-native-https/26fa978f-a83b-4e49-b6b3-dab541da890c.png" alt="logo" title="">                </div>                <div class="image-caption">logo</div>            </figure></li><li><p>在文件中找到下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSURLSession delegate</span></span><br></pre></td></tr></table></figure></li><li><p>在此代码下方添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(<span class="keyword">void</span> (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">  completionHandler(NSURLSessionAuthChallengeUseCredential, [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编辑info.plist文件，修改如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/03/28/react-native-https/794c1115-612a-4e30-ac96-f1c2c8e8648f.png" alt="info.plist" title="">                </div>                <div class="image-caption">info.plist</div>            </figure><ol start="6"><li>完成配置，重新打包即可<h2 id="Android处理"><a href="#Android处理" class="headerlink" title="Android处理"></a>Android处理</h2>Android下React Native使用OKHTTP作为网络请求库，由于npm在安装react-native时已经编译过相关第三方依赖库，所以要改动依赖库中的代码，我们需要下载ReactAndroid的源代码，修改OKHTTP源码后重新编译。所以过程相对IOS会复杂很多，下面我们开始一步步来完成相关工作。</li><li>下载NDK，解压<br> NDK官方<a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip" target="_blank" rel="noopener">下载地址</a></li><li>local.properties 中设置ndk.dir.</li><li><p>修改<code>settings.gradle</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">':ReactAndroid'</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">':ReactAndroid'</span>).projectDir = <span class="keyword">new</span> <span class="keyword">File</span>(rootProject.projectDir, <span class="string">'../node_modules/react-native/ReactAndroid'</span>)</span><br></pre></td></tr></table></figure></li><li><p>修改<code>app/build.gradle</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compile "com.facebook.react:react-native:+"  // From node_modules</span></span><br><span class="line"><span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':ReactAndroid'</span>)</span><br><span class="line"><span class="comment">//可能在需要添加一下代码</span></span><br><span class="line"><span class="keyword">configurations</span>.all &#123;</span><br><span class="line"> <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.facebook.react'</span>, module: <span class="string">'react-native'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改ReactAndroid中OKHTTP相关源代码，打开<code>node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/network/OkHttpClientProvider.java</code>文件，修改文件内容为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClientProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Centralized OkHttpClient for all networking requests.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> OkHttpClient sClient;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient <span class="title">getOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">  sClient = createClient();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// okhttp3 OkHttpClient is immutable</span></span><br><span class="line">  <span class="comment">// This allows app to init an OkHttpClient with custom settings.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replaceOkHttpClient</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">  sClient = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient <span class="title">createClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// No timeouts by default</span></span><br><span class="line">  OkHttpClient.Builder client = getUnsafeOkHttpClient()</span><br><span class="line">  .connectTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">  .readTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">  .writeTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">  .cookieJar(<span class="keyword">new</span> ReactCookieJarContainer());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> enableTls12OnPreLollipop(client).build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  On Android 4.1-4.4 (API level 16 to 19) TLS 1.1 and 1.2 are</span></span><br><span class="line"><span class="comment">  available but not enabled by default. The following method</span></span><br><span class="line"><span class="comment">  enables it.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient.<span class="function">Builder <span class="title">enableTls12OnPreLollipop</span><span class="params">(OkHttpClient.Builder client)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN &amp;&amp; Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  client.sslSocketFactory(<span class="keyword">new</span> TLSSocketFactory());</span><br><span class="line"></span><br><span class="line">  ConnectionSpec cs = <span class="keyword">new</span> ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)</span><br><span class="line">  .tlsVersions(TlsVersion.TLS_1_2)</span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line">  List&lt;ConnectionSpec&gt; specs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  specs.add(cs);</span><br><span class="line">  specs.add(ConnectionSpec.COMPATIBLE_TLS);</span><br><span class="line">  specs.add(ConnectionSpec.CLEARTEXT);</span><br><span class="line"></span><br><span class="line">  client.connectionSpecs(specs);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception exc) &#123;</span><br><span class="line">  FLog.e(<span class="string">"OkHttpClientProvider"</span>, <span class="string">"Error while enabling TLS 1.2"</span>, exc);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient.<span class="function">Builder <span class="title">getUnsafeOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// Create a trust manager that does not validate certificate chains</span></span><br><span class="line">  <span class="keyword">final</span> TrustManager[] trustAllCerts = <span class="keyword">new</span> TrustManager[]&#123;</span><br><span class="line">  <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> java.security.cert.X509Certificate[]&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install the all-trusting trust manager</span></span><br><span class="line">  <span class="keyword">final</span> SSLContext sslContext = SSLContext.getInstance(<span class="string">"SSL"</span>);</span><br><span class="line">  sslContext.init(<span class="keyword">null</span>, trustAllCerts, <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line">  <span class="comment">// Create an ssl socket factory with our all-trusting manager</span></span><br><span class="line">  <span class="keyword">final</span> SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();</span><br><span class="line"></span><br><span class="line">  OkHttpClient.Builder builder = <span class="keyword">new</span> OkHttpClient.Builder();</span><br><span class="line">  builder.sslSocketFactory(sslSocketFactory);</span><br><span class="line">  builder.hostnameVerifier(<span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> builder;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行<code>react-native run-android</code>开始编译，过程中可能会报错，Google解决一下即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;现在绝大多数网站已转为https方式浏览，但很多情况下https的证书并不是CA颁发的合法证书，而是通过公司或个人自签名产生
      
    
    </summary>
    
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件(六)-保存状态</title>
    <link href="http://yoursite.com/2017/09/28/architecture-saving-states/"/>
    <id>http://yoursite.com/2017/09/28/architecture-saving-states/</id>
    <published>2017-09-28T11:33:31.000Z</published>
    <updated>2018-04-13T08:17:53.797Z</updated>
    
    <content type="html"><![CDATA[<p>保持UI状态是用户体验的关键部分。无论用户是旋转设备，或者用户重新启动应用程序，还是系统关闭应用程序，重要的是你的activity保持用户期望的状态。</p><p>如果要保存的UI数据是简单和轻量级的，那么您可以使用<code>onSaveInstanceState()</code>来保存您的状态数据。在需要保存复杂数据的情况下，可以组合地使用<code>ViewModel</code>对象、<code>onSaveInstanceState()</code>方法以及持久本地存储（database）。</p><p>本文将会讨论着两种方式。</p><h1 id="简单案例的处理：onSaveInstanceState"><a href="#简单案例的处理：onSaveInstanceState" class="headerlink" title="简单案例的处理：onSaveInstanceState()"></a>简单案例的处理：onSaveInstanceState()</h1><hr><p><code>onSaveInstanceState()</code>回调方法被设计用于存储相对少量的数据，以便轻松地重新加载UI控制器的状态，例如activity或fragment，如果系统停止，稍后重新创建控制器。这个回调方法是用来处理下面的两种情况:</p><ul><li>由于内存限制，当应用程序在后台时，系统会杀死应用程序的进程。</li><li>配置发生了改变，比如屏幕旋转，或者输入语言发生改变。</li></ul><p>正如这两种情况所示，<code>onSaveInstanceState()</code>在activity处于stop状态(但是没有被finished掉)的情况下被调用。例如,如果用户离开应用程序几个小时,系统就会回收相关过程的内存,这时系统就会调用<code>onSaveInstanceState()</code>来保存每个UI控制器的状态（UI控制器带有一个ID）。之后,当用户返回到应用程序时,系统使用保存状态来恢复activity。</p><blockquote><p><strong>注意：</strong>当用户显示地关闭activity或者其他情况下finish()被调用了，onSaveInstanceState() 是不会被调用。</p></blockquote><p>系统自动为您保存和恢复大量的UI相关的数据:<code>onSaveInstanceState()</code>的默认实现保存有关activity的视图层次结构的状态信息，比如<code>EditText</code>的文本或<code>ListView</code>的滚动位置。您还可以通过重写<code>onSaveInstanceState()</code>回调来将自定义数据保存到bundle中。如果您重写此方法以保存每一个实体未捕获的额外信息，那么您应该调用默认的实现，除非您已经准备好保存每个实体的状态（这个太难了，没必要）。</p><p><code>onSaveInstanceState()</code>不是设计用于存储大量数据，例如位图或复杂的数据结构，这些数据结构需要进行冗长的序列化或反序列化。如果序列化的对象是复杂的，序列号会消耗大量内存。在配置更改期间这个操作是发生在主线程上，如果时间过长，序列化会导致掉帧和虚拟机卡顿。因此，不要使用<code>onSaveInstanceState()</code>来处理复杂的数据结构，确保在本地持久化存储中存储这些结构;在创建数据的同时，最好存储数据，以减少丢失数据的机会。然后，使用<code>onSaveInstanceState()</code>存储每个对象的惟一id（数据库中一般一条数据都有对应的id）。</p><p>本文档的下一部分提供了关于保存更复杂数据更多的细节。</p><h1 id="处理更负责的状态：分而治之"><a href="#处理更负责的状态：分而治之" class="headerlink" title="处理更负责的状态：分而治之"></a>处理更负责的状态：分而治之</h1><hr><p>当您需要在activity结束时保留更复杂的数据结构时，您可以通过将操作划分为几种不同的存储机制，从而有效地保存和恢复UI状态。<br>一般来说离开一个activity有两种方式，每种方式都会导致不同的结果:</p><ul><li>用户完全关闭该activity。如果用户从屏幕上把activity滑出去，从当前activity跳转到另一个activity，或者退出该activity–比如按下返回键，则可以完全关闭activity。在这些情况下的假设是，用户已经永久地离开了activity，如果他们重新打开该activity，他们将期望从一个全新的状态开始。</li><li>用户旋转手机，或者把activity放在后台，然后再回来。例如，用户执行搜索，然后按home键或接听电话。当他们返回到搜索activity时，他们期望前面输入搜索关键字和搜索结果仍然在那里，和以前一样。</li></ul><p>为了在两种情况下实现复杂数据结构的行为，您可以使用本地持久性（database，sp）、<code>ViewModel</code>类和<code>onSaveInstanceState()</code>方法。每一种方法都存储在activity中使用的不同类型数据。</p><ul><li><strong>本地持久化:</strong>存储所有您不想丢失的数据，如果您打开并关闭该activity。<ul><li>示例:一组歌曲对象，可以包括音频文件和元数据。</li></ul></li><li><strong>ViewModel:</strong>存储在内存中的所有用来显示UI控制器相关的数据。<ul><li>示例:最近搜索的歌曲对象和最近的搜索查询。</li></ul></li><li><strong>onSaveInstanceState():</strong>如果系统停止，然后重新创建UI控制器的情况下，存储少量数据，用来轻松地重新加载activity状态。与其在这里存储复杂对象，还不如在本地存储中保存复杂对象，并在<code>onSaveInstanceState()</code>中存储这些对象的惟一ID。<ul><li>示例:存储最近的搜索查询。</li></ul></li></ul><p>作为一个例子，考虑一个允许你搜索你的歌曲库的activity。下面列举了如何处理不同的事件:<br>当用户添加歌曲（就是向数据库–Room插入该歌曲）时，<code>ViewModel</code>代表数据库中歌曲的列表（指的是<code>LiveData</code>对象）。如果新添加的歌曲应该显示在UI中，您还应该更新<code>ViewModel</code>对象中的数据（<code>LiveData</code>对象）以反映歌曲的添加。记住不要在主线程上执行数据库插入操作。<br>当用户搜索歌曲时，您从数据库中查询到的歌曲数据（用来显示在UI上面的歌曲列表数据）应该立即存储在<code>ViewModel</code>对象中（设置到LiveData对象）。您还应该将搜索查询本身保存在<code>ViewModel</code>对象中。<br>当活动进入后台时，系统调用<code>onSaveInstanceState()</code>。您应该在<code>onSaveInstanceState()</code>包中保存搜索查询。这少量的数据很容易保存。它还保存了将activity恢复到当前状态所需的所有信息。</p><h1 id="恢复复杂的状态：重新组装"><a href="#恢复复杂的状态：重新组装" class="headerlink" title="恢复复杂的状态：重新组装"></a>恢复复杂的状态：重新组装</h1><hr><p>当用户返回到activity，重新创建activity时，可能会有如下两种情况:</p><ul><li>activity在系统被停止后重新创建后。该activit将保存在<code>onSaveInstanceState()</code>的bundle中的查询关键字传递给<code>ViewModel</code>。<code>ViewModel</code>看到它没有该关键字的搜索结果缓存后就会使用给定的搜索关键字来加载数据库中的搜索结果。<strong><em>ViewModel被销毁了。</em></strong></li><li>该activity是在配置更改后重新创建的。activity将保存在onSaveInstanceState()的bundle对象中的搜索关键字传递给ViewModel，ViewMo发现已经缓存了搜索结果，所以决定不需要重新查询数据库。<strong><em>ViewModel在配置改变期间是不会被销毁的。</em></strong><blockquote><p><strong>注意：</strong>当一个activity最初创建时，onSaveInstanceState()的bundle是不包含数据，而ViewModel对象是空的。当您创建ViewModel对象时，传递一个空的搜索关键字，相当于告诉ViewModel对象不需要进行搜索结果数据加载。因此，activity从一个空状态开始。</p></blockquote></li></ul><p>根据您的activity实现，您可能根本不需要使用<code>onSaveInstanceState()</code>。例如，浏览器可能会把用户带回到他们在离开浏览器之前看到的网页。如果您的activ的行为是这样的，您可以放弃使用<code>onSaveInstanceState()</code>，并且将所有的内容持久化到本地。在歌曲-搜索示例中，这可能意味着在Shared Preferences中保存最近的查询。</p><p>此外，当您从一个intent打开的activity，当配置发生更改时或者系统恢复activity，bundle里面的数据都能被交付给activity。如果搜索查询作为intent的附加数据传入，您可以使用bundle来获取附加数据而不是使用<code>onSaveInstanceState()</code>bundle。</p><p>在这两种情况下，您仍然可以使用<code>ViewModel</code>来避免在配置发生更改时从数据库中重新加载数据的时间消耗。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;保持UI状态是用户体验的关键部分。无论用户是旋转设备，或者用户重新启动应用程序，还是系统关闭应用程序，重要的是你的activity保持用户期望的状态。&lt;/p&gt;
&lt;p&gt;如果要保存的UI数据是简单和轻量级的，那么您可以使用&lt;code&gt;onSaveInstanceState()&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Architecture Components" scheme="http://yoursite.com/tags/Architecture-Components/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件(五)-ViewModel</title>
    <link href="http://yoursite.com/2017/09/25/architecture-viewmodel/"/>
    <id>http://yoursite.com/2017/09/25/architecture-viewmodel/</id>
    <published>2017-09-25T12:22:31.000Z</published>
    <updated>2018-04-12T09:25:08.379Z</updated>
    
    <content type="html"><![CDATA[<p><code>ViewModel</code>类被设计用来以 lifecycle 的方式存储和管理与ui相关的数据，<code>ViewModel</code>类允许数据在诸如屏幕旋转之类的配置更改中存活。</p><p>Android 框架管理 UI 控制器的生命周期，比如 activities 和 fragments。该框架可能会决定销毁或重新创建UI控制器，以响应完全超出您控制的某些用户操作或设备事件。</p><p>如果系统销毁或重新创建一个UI控制器，那么存储在其中的任何与UI相关的数据都将丢失。例如，你的应用可能会在其中一个activity中包含一个用户列表。当因为配置更改重新创建activity时，新activity必须重新获取用户列表。对于简单的数据，该活动可以使用 <code>onSaveInstanceState()</code>方法，并从<code>onCreate()</code> 中的 bundle 中恢复其数据，但是这种方法只适用于少量的可以序列化以及反序列化数据，而不是像用户列表或位图那样的潜在的大量数据。</p><p>另一个问题是 UI 控制器经常需要进行异步调用，这可能需要一些时间才能返回。<br>UI 控制器需要管理这些调用，并确保系统在被销毁后清除它们，以避免潜在的内存泄漏。这种管理需要大量的维护，并且在由于配置更改而重新创建对象的情况下，如果重新发出已经发过的调用(比如网络请求)，那么就会造成资源的浪费。</p><p>诸如 activities 和 fragments 之类的 UI 控制器主要是用来显示 UI 数据、对用户操作作出反应，或者处理操作系统通信（比如权限请求）。若要求 UI 控制器同时负责从数据库或网络加载数据，这会使类变得膨胀。给UI控制器分配过多的责任会导致一个单独的类，它试图独自处理应用程序的所有工作，而不是将工作委托给其他类。以这种方式为 UI 控制器分配过多的责任也会使测试变得更加困难。</p><p>将视图数据从 UI 控制器分离出来会使程序变得更容易维护、以及更高效。</p><h1 id="实现ViewModel"><a href="#实现ViewModel" class="headerlink" title="实现ViewModel"></a>实现ViewModel</h1><hr><p>架构组件为 UI 控制器提供 <code>ViewModel</code> 帮助类，它可以负责为 UI 准备数据。在配置更改期间，<code>ViewModel</code> 对象将自动保留，以便它们保存的数据在下一个 activity 或 fragment 实例创建时能够立即被使用。例如，如果您需要在应用程序中显示一个用户列表，请确保将责任分配给一个 <code>ViewModel</code>，而不是给一个 activity 或 fragment，如下面的示例代码所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData&lt;List&lt;User&gt;&gt; users;</span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;List&lt;User&gt;&gt; getUsers() &#123;</span><br><span class="line">        <span class="keyword">if</span> (users == <span class="keyword">null</span>) &#123;</span><br><span class="line">            users = <span class="keyword">new</span> MutableLiveData&lt;List&lt;Users&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do an asynchronous operation to fetch users.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以使用下面这种方式在activity中获取列表：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class="line">        <span class="comment">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class="line"></span><br><span class="line">        MyViewModel model = ViewModelProviders.of(<span class="keyword">this</span>).get(MyViewModel.class);</span><br><span class="line">        model.getUsers().observe(<span class="keyword">this</span>, users -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果该 activity 被重新创建，它将收到第一个 activity 创建的 MyViewModel 实例。当拥有 MyViewModel 对象的 activity 被 <code>finish()</code> 后，框架调用 <code>ViewModel</code> 对象的 <code>onCleared()</code> 方法，以便它可以清理资源。</p><blockquote><p><strong>注意</strong>:ViewModel永远不能引用view，Lifecycle或任何可能引用activity context的类。</p></blockquote><p><code>ViewModel</code> 对象的设计是为了能够比特定的视图（activity/fragment）或者 <code>LifecycleOwners</code> 实例存活得更久。因为它不知道视图和生命周期对象，所以您可以更容易地编写测试来覆盖 <code>ViewModel</code>。<code>ViewModel</code> 对象可以包含 <code>LifecycleObservers</code> ，例如 <code>LiveData</code> 对象。然而，<code>ViewModel</code> 对象永远不能观察 lifecycle-aware 可观察对象的变化，例如 LiveData 对象。如果 <code>ViewModel</code> 需要应用程序上下文，例如找到一个系统服务，它可以扩展 <code>AndroidViewModel</code> 类，并使用一个在接收 <code>Application</code> 参数的构造函数，因为 <code>Application</code> 类扩展了上下文。</p><h1 id="ViewModel的生命周期"><a href="#ViewModel的生命周期" class="headerlink" title="ViewModel的生命周期"></a>ViewModel的生命周期</h1><hr><p><code>ViewModel</code> 对象的作用范围是由在获得 <code>ViewModel</code> 时传递给 <code>ViewModelProvider</code> 的 Lifecycle 所决定的。ViewModel 会一直存在于内存中，直到限定它作用范围的 Lifecycle 彻底地消失: 如果 Lifecycle 是一个 activity 的情况下，当它 finish 时，如果是一个 fragment，那么是在被 detached 时。<br>图1演示了一个activity的各个生命周期状态，当它进行旋转的时候，然后结束。插图还显示了与相关活动生命周期相邻的 ViewModel 的生命周期。这个特殊的图说明了activity的状态。同样的基本状态也适用于fragment的生命周期。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/09/25/architecture-viewmodel/viewmodel-lifecycle.png" alt="t1" title="">                </div>                <div class="image-caption">t1</div>            </figure></p><p>通常在系统调用 activity 对象的 onCreate() 方法里面 new 一个 ViewModel。系统可以在 activity 的整个生命周期中多次调用 onCreate()，例如在设备屏幕被旋转时。您第一次创建 ViewModel 将会一直存在，直到 activity 完成并销毁。</p><h1 id="在fragments间共享数据"><a href="#在fragments间共享数据" class="headerlink" title="在fragments间共享数据"></a>在fragments间共享数据</h1><hr><p>在一个 activity 中，两个或多个 fragment 通常都需要相互通信。设想一个主-细节 fragments 常见的场景（比如系统设置界面），其中有一个 fragment，用户从一个列表中选择一个项目，另一个 fragment 显示选项的详细内容。这个案例其实并不容易，因为两个 fragment 都需要定义一些接口描述，而两个 fragment 的拥有者 activity 必须将两者结合在一起。此外，两个 fragment 必须处理其中某一个 fragment 尚未创建或不可见的情况。<br>这个常见的痛点可以通过使用 <code>ViewModel</code> 对象来解决。这些 fragments 可以使用 activity scope（因为是同一个 activity，所以有同样的作用范围或者生命周期）来共享一个<code>ViewModel</code>，以处理这种通信，如下面的示例代码所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="keyword">new</span> MutableLiveData&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;Item&gt; <span class="title">getSelected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SharedViewModel model;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        SharedViewModel model = ViewModelProviders.of(getActivity()).get(SharedViewModel.class);</span><br><span class="line">        model.getSelected().observe(<span class="keyword">this</span>, &#123; item -&gt;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请注意，在获取 <code>ViewModelProvider</code> 时，两个 fragment 都使用<code>getActivity()</code>。因此，这两个片段都接收相同的 SharedViewModel 实例，该实例的作用域是 activity。<br>这种方式有一下好处：</p><ul><li>activity 不需要做任何事情，也不需要知道任何关于通信的信息。</li><li>除了 SharedViewModel 之外，fragment 不需要相互了解。如果其中一个 fragment 消失了，另一个则继续正常工作。</li><li>每个 fragment 都有自己的生命周期，并且不受另一个生命周期的影响。<br>如果一个详情 fragment 替换另一个详情 fragment ，UI 将继续工作，没有任何问题。</li></ul><h1 id="用ViewModel取代Loaders"><a href="#用ViewModel取代Loaders" class="headerlink" title="用ViewModel取代Loaders"></a>用ViewModel取代Loaders</h1><hr><p>像 <code>CursorLoader</code> 这样的 Loader 类经常用于保持应用程序的 UI 中显示的数据以及数据库同步。您可以使用 <code>ViewModel</code>，以及其他一些类来替换加载器。使用 ViewModel 将 UI 控制器与数据加载操作分离，这意味着可以减少类之间的强引用。<br>在使用加载器的一种常见方法中，应用程序可能使用一个 <code>CursorLoader</code> 来观察数据库的内容。<br>当数据库中的值发生变化时，加载器会自动触发数据的重新加载，并更新 UI:<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/09/25/architecture-viewmodel/viewmodel-loader.png" alt="t2" title="">                </div>                <div class="image-caption">t2</div>            </figure></p><p><font style="font-size: 14px">图2. 使用Loader加载数据</font><br><code>ViewModel</code> 使用 <code>Room</code> 和 <code>LiveData</code> 来替换加载器。<code>ViewModel</code> 确保数据在设备配置更改中得以保存。当数据库发生变化时，<code>Room</code> 会通知您的 <code>LiveData</code>，而 <code>LiveData</code> 则会用修改后的数据更新您的 UI 。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/09/25/architecture-viewmodel/viewmodel-replace-loader.png" alt="t3" title="">                </div>                <div class="image-caption">t3</div>            </figure></p><p><font style="font-size: 14px">图3. 使用ViewModel加载数据</font><br>这篇博客文章描述了如何使用一个带有 <code>LiveData</code> 的 <code>ViewModel</code> 来替换一个 <code>AsyncTaskLoader</code>。随着您的数据变得越来越复杂，您可能会选择一个单独的类来加载数据。<code>ViewModel</code> 的目的是封装 UI 控制器的数据，使数据能够在配置更改中存活。有关如何在配置更改中加载、持久化和管理数据的信息，请参见保存 UI 状态。Android 应用程序架构的指南建议构建一个 repository 类来处理这些函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;ViewModel&lt;/code&gt;类被设计用来以 lifecycle 的方式存储和管理与ui相关的数据，&lt;code&gt;ViewModel&lt;/code&gt;类允许数据在诸如屏幕旋转之类的配置更改中存活。&lt;/p&gt;
&lt;p&gt;Android 框架管理 UI 控制器的生命周期，比如
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Architecture Components" scheme="http://yoursite.com/tags/Architecture-Components/"/>
    
      <category term="ViewModel" scheme="http://yoursite.com/tags/ViewModel/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件(四)-LiveData</title>
    <link href="http://yoursite.com/2017/09/21/architecture-livedata/"/>
    <id>http://yoursite.com/2017/09/21/architecture-livedata/</id>
    <published>2017-09-21T11:44:55.000Z</published>
    <updated>2018-04-11T08:50:36.064Z</updated>
    
    <content type="html"><![CDATA[<p><code>LiveData</code>是一个可被观察的数据持有类。不同于常规的observable，LiveData是生命周期敏感的，也就意味着它尊重其他组件的生命周期，比如activities, fragments，或者services。这种特性确保了LiveData只会在一个激活的生命周期状态下更新应用组件下的observers。</p><p>如果观察者的生命周期处于<code>STARTED</code>或<code>RESUMED</code>状态，则<code>LiveData</code>会将<code>Observer</code>类表示的观察者视为活动状态。<code>LiveData</code>只会通知那些处于活动状态的observers去更新。那些注册了观察<code>LiveData</code>但是处于非活动状态的observers不会收到改变的通知。</p><p>您可以注册与实现<code>LifecycleOwner</code>接口的对象配对的观察者。此关系允许在相应生命周期对象的状态更改为<code>DESTROYED</code>时删除观察者。这对于activities和fragments特别有用，因为它们可以安全地观察LiveData对象，而不必担心泄漏 - 在其生命周期被破坏时，activities和fragments会立即取消订阅。</p><h1 id="LiveData的优点"><a href="#LiveData的优点" class="headerlink" title="LiveData的优点"></a>LiveData的优点</h1><hr><p>使用LiveData能够带来如下优点：</p><ul><li><strong>确保你的UI和数据状态匹配</strong><br>LiveData遵循观察者模式。当生命周期状态发生变化时，LiveData会通知观察者对象。您可以整合更新UI的代码到这些观察者对象中。在每次应用程序数据改变时，你的观察者可以更新UI，而不是每次更新的时候更新UI。</li><li><strong>避免内存溢出</strong><br>观察者被绑定到Lifecycle对象，当他们的相关生命周期处于destroyed时，他们会自我清理。</li><li><strong>避免activities停止带来的崩溃问题</strong><br>如果观察者的生命周期是不活动的，比如在后台堆栈中的活动，那么它就不会接收到任何LiveData事件。</li><li><strong>避免过多的生命周期手动处理</strong><br>UI组件只观察相关数据而不会去停止或恢复观察。LiveData自动管理所有这些，因为它在observing期间能够意识到相关生命周期状态的变化。</li><li><strong>始终保持最新的数据</strong><br>如果生命周期变得不活跃，当再次激活的时候它会接收到最新数据。例如，后台的活动在返回到前台后接收最新的数据。</li><li><strong>正确的配置更改</strong><br>如果一个Activity或者Fragment由于类似设备旋转等配置更改造成重新创建，它会立马接收到最新的可用数据。</li><li><strong>共享资源</strong><br>您可以使用单例模式扩展LiveData对象，以封装系统服务，以便在应用程序中共享它们。LiveData对象连接到系统服务一次，然后任何需要该资源的观察者只需观察LiveData对象。</li></ul><h1 id="使用LiveData对象"><a href="#使用LiveData对象" class="headerlink" title="使用LiveData对象"></a>使用LiveData对象</h1><hr><p>通过以下步骤学习使用<code>LiveData</code>对象：</p><ol><li>创建一个LiveData实例来保存某种类型的数据。这通常在您的<code>ViewModel</code>类中完成。</li><li>创建一个Observer对象，该对象定义<code>onChanged()</code>方法，该方法控制在<code>LiveData</code>对象的数据更改时需要进行的操作。您通常在UI控制器中创建一个观察者对象，例如一个activity或者fragment。</li><li>使用<code>observe()</code>方法将<code>Observer</code>对象连接到LiveData对象。<code>observe()</code>方法使用一个<code>LifecycleOwner</code>对象。它将Observer对象订阅到LiveData对象，以便通知更改。您通常将Observer对象附加在UI控制器中，例如activity或fragment。<blockquote><p><strong>注意：</strong>您可以使用<code>observeForever(Observer)</code>方法在没有关联的<code>LifecycleOwner</code>对象的情况下注册一个观察者。在这种情况下，观察者被认为总是处于活动状态，因此总是被告知修改。您可以删除调用<code>removeObserver(Observer)</code>方法的这些observers。</p></blockquote></li></ol><p>当您更新LiveData对象中存储的值时，只要附加的LifecycleOwner对象处于活动状态，它就会触发所有已注册的observers。<br>LiveData允许UI控制器里面的observers订阅更新。当LiveData对象所持有的数据发生变化时，UI会自动响应更新。</p><h2 id="创建LiveData对象"><a href="#创建LiveData对象" class="headerlink" title="创建LiveData对象"></a>创建LiveData对象</h2><p>LiveData是一个可以用于任何数据的包装器，包括实现<code>Collections</code>的对象，如<code>List</code>。<code>LiveData</code>对象通常存储在<code>ViewModel</code>对象中，并通过getter方法进行访问，如所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a LiveData with a String</span></span><br><span class="line"><span class="keyword">private</span> MutableLiveData&lt;String&gt; mCurrentName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;String&gt; <span class="title">getCurrentName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurrentName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCurrentName = <span class="keyword">new</span> MutableLiveData&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mCurrentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rest of the ViewModel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>开始，LiveData对象中的数据没有设置。</p><blockquote><p><strong>注意：</strong>确保是在ViewModel对象中存储更新UI的LiveData对象，而不是activity或fragment，原因如下:</p><ul><li>避免膨胀的activities和fragments。现在，这些UI控制器负责显示数据，而不是保存数据状态。 </li><li>将LiveData实例与特定activity或fragment实例分离，可以确保LiveData对象在配置更改中（比如旋转屏幕）存活。</li></ul></blockquote><h2 id="观察LiveData对象"><a href="#观察LiveData对象" class="headerlink" title="观察LiveData对象"></a>观察LiveData对象</h2><p>在大多数情况下，应用程序组件的<code>onCreate()</code>方法是开始观察LiveData对象的正确位置，原因如下:</p><ul><li>为了确保系统不会从一个activity或者fragment的onResume()方法中发出冗余的调用。</li><li>为了确保activity或者fragment拥有数据，它可以在活动开始时显示。一旦应用程序组件处于活动状态，它就会从它所观察到的LiveData对象中接收到最新的值。只有在已被observed的LiveData对象被设置时才会出现这种情况</li></ul><p>一般来说，LiveData只在数据发生变化时才提供更新，而且只对活动的observers进行更新。这种行为的一个例外是，当观察者从一个非活动状态转变为一个活动状态时，也会收到一个更新。此外，如果观察者第二次从非活动状态变为活动状态，如果该值在上一次激活时发生了变化，它也只会收到一个更新。</p><p>以下示例代码说明了如何开始观察一个<code>LiveData</code>对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NameViewModel mModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Other code to setup the activity...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the ViewModel.</span></span><br><span class="line">        mModel = ViewModelProviders.of(<span class="keyword">this</span>).get(NameViewModel.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the observer which updates the UI.</span></span><br><span class="line">        <span class="keyword">final</span> Observer&lt;String&gt; nameObserver = <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(@Nullable <span class="keyword">final</span> String newName)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Update the UI, in this case, a TextView.</span></span><br><span class="line">                mNameTextView.setText(newName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.</span></span><br><span class="line">        mModel.getCurrentName().observe(<span class="keyword">this</span>, nameObserver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用nameObserver作为参数传递了<code>observe()</code>方法后，<code>onChanged()</code>方法将会被立即调用，以提供当前在mCurrentName中存储的最新值。<br>如果LiveData对象没有给mCurrentName设置值，则不会调用<code>onChanged()</code>。</p><h2 id="更新LiveData对象"><a href="#更新LiveData对象" class="headerlink" title="更新LiveData对象"></a>更新LiveData对象</h2><p><code>LiveData</code>没有公开可用的方法来更新存储的数据。<code>MutableLiveData</code>类公开了<code>setValue(T)</code>和<code>postValue(T)</code>方法，如果需要编辑存储在<code>LiveData</code>对象中的值，则必须使用这些方法。通常在<code>ViewModel</code>中使用<code>MutableLiveData</code>，然后<code>ViewModel</code>只向observers公开不可变的LiveData对象。<br>在设置了observer关系之后，您可以更新<code>LiveData</code>对象的值，如下面的例子所示，当用户点击一个按钮时，它会触发所有观察者。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String anotherName = <span class="string">"John Doe"</span>;</span><br><span class="line">        mModel.getCurrentName().setValue(anotherName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在示例中调用<code>setValue(T)</code>结果是<code>observers</code>调用了<code>onChanged()</code>方法，并且<code>onChanged()</code>方法参数的值为John Doe。这个示例显示了一个按钮按下，但是<code>setValue()</code>或<code>postValue()</code>可以被调用以各种原因更新mName，包括响应网络请求或数据库加载完成;<br>在所有情况下，对<code>setValue()</code>或<code>postValue()</code>的调用会触发观察者并更新UI。</p><blockquote><p><strong>注意：</strong>调用setValue(T)方法更新LiveData对象只能在主线程中。如果代码是在一个工作线程中执行的，那么您可以使用postValue(T)方法来更新LiveData对象。</p></blockquote><h2 id="结合Room使用LiveData"><a href="#结合Room使用LiveData" class="headerlink" title="结合Room使用LiveData"></a>结合Room使用LiveData</h2><p><code>Room</code>持久化库支持observable的查询，这些查询返回了LiveData对象。observable的查询是作为数据库访问对象(DAO)的一部分编写的。</p><p>当数据库被更新时，Room会生成所有必要的代码来更新LiveData对象。当需要时，生成的代码在后台线程上异步地运行查询。此模式有助于将数据显示在UI中，与存储在数据库中的数据保持同步。您可以在Room的持久化库指南中了解更多关于Room和dao的内容。</p><h1 id="扩展LiveData"><a href="#扩展LiveData" class="headerlink" title="扩展LiveData"></a>扩展LiveData</h1><hr><p>LiveData认为如果observer的生命周期处于STARTED或RESUMED状态，那么observer处于活动状态，以下示例代码说明了如何扩展LiveData类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StockManager mStockManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimplePriceListener mListener = <span class="keyword">new</span> SimplePriceListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPriceChanged</span><span class="params">(BigDecimal price)</span> </span>&#123;</span><br><span class="line">            setValue(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockLiveData</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        mStockManager = <span class="keyword">new</span> StockManager(symbol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.requestPriceUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.removeUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>本示例中的价格监听器的实现包括以下重要方法:</p><ul><li>当<code>LiveData</code>对象有一个活动的观察者时，就会调用<code>onActive()</code>方法。这意味着您需要从这个方法开始观察股票价格的更新。</li><li>当<code>LiveData</code>对象没有任何活动的观察者时，就会调用<code>onInactive()</code>方法。由于没有observers在监听，因此没有理由与StockManager服务保持联系。</li><li><code>setValue(T)</code>方法更新<code>LiveData</code>实例的值，并通知任何活动的观察者关于这个变化。<br>你可以像下面代码这样使用<code>StockLiveData</code>类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        LiveData&lt;BigDecimal&gt; myPriceListener = ...;</span><br><span class="line">        myPriceListener.observe(<span class="keyword">this</span>, price -&gt; &#123;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>把fragment作为<code>observe()</code>方法的第一个参数，该fragment是<code>LifecycleOwner</code>的一个实例。这样做意味着这个观察者被绑定到fragment相关的Lifecycle对象，这意味着:</p><ul><li>如果Lifecycle对象不是处于活动状态，那么即使值发生变化，也不会调用观察者。</li><li>在Lifecycle对象被销毁后，observer也会被自动移除。<br>实际上LiveData对象是生命周期敏感的，这意味着您可以在多个activities、fragments和services之间共享它们。为了保持这个示例的简单性，您可以将LiveData类作为一个单例对象来实现:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StockLiveData sInstance;</span><br><span class="line">    <span class="keyword">private</span> StockManager mStockManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimplePriceListener mListener = <span class="keyword">new</span> SimplePriceListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPriceChanged</span><span class="params">(BigDecimal price)</span> </span>&#123;</span><br><span class="line">            setValue(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StockLiveData <span class="title">get</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> StockLiveData(symbol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StockLiveData</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        mStockManager = <span class="keyword">new</span> StockManager(symbol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.requestPriceUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.removeUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>然后你可以再fragment中这样使用它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        StockLiveData.get(getActivity()).observe(<span class="keyword">this</span>, price -&gt; &#123;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多个fragments和activities可以观察到MyPriceListener实例。LiveData只有在其中一个或多个具有可见性和活动性时才连接到系统服务。</p><h1 id="转换LiveData"><a href="#转换LiveData" class="headerlink" title="转换LiveData"></a>转换LiveData</h1><hr><p>您可能想要对LiveData对象中存储的值进行更改，然后将其发送给observers，或者您可能需要根据另一个对象的值返回一个不同的LiveData实例。Lifecycle package提供了<code>Transformations</code>，其中包括支持这些场景的帮助方法。<br><strong>Transformations.map()</strong><br>对存储在<code>LiveData</code>对象中的值应用一个函数，并将结果传播到下游。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LiveData&lt;User&gt; userLiveData = ...;</span><br><span class="line">LiveData&lt;String&gt; userName = Transformations.map(userLiveData, user -&gt; &#123;</span><br><span class="line">    user.name + <span class="string">" "</span> + user.lastName</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>Transformations.switchMap()</strong><br>与<code>map()</code>类似，将一个函数应用到<code>LiveData</code>对象中存储的值，并将结果发送到下游。传递给<code>switchMap()</code>方法的函数(匿名内部类)必须返回一个<code>LiveData</code>对象，如下面的例子所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">  ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveData&lt;String&gt; userId = ...;</span><br><span class="line">LiveData&lt;User&gt; user = Transformations.switchMap(userId, id -&gt; getUser(id) );</span><br></pre></td></tr></table></figure></p><p>如果您认为在<code>ViewModel</code>对象中需要一个Lifecycle对象，那么<code>transformation</code>可能是更好的解决方案。例如，假设您有一个UI组件，该组件接受一个地址，并返回该地址的邮政编码。您可以为该组件实现简单的<code>ViewModel</code>，如下示例代码所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PostalCodeRepository repository;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewModel</span><span class="params">(PostalCodeRepository repository)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> LiveData&lt;String&gt; <span class="title">getPostalCode</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// DON'T DO THIS</span></span><br><span class="line">       <span class="keyword">return</span> repository.getPostCode(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后，UI组件需要从先前的<code>LiveData</code>对象中取消注册，并在每次调用<code>getPostalCode()</code>时注册到新实例。此外，如果UI组件被重新创建，它将触发另一个<code>repository.getpostcode()</code>方法的调用，而不是使用以前的调用的结果。</p><p>相反的，您可以实现邮政编码查找作为地址输入的transformation，如下面的示例所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PostalCodeRepository repository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;String&gt; addressInput = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> LiveData&lt;String&gt; postalCode =</span><br><span class="line">            Transformations.switchMap(addressInput, (address) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> repository.getPostCode(address);</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyViewModel</span><span class="params">(PostalCodeRepository repository)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.repository = repository</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setInput</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">      addressInput.setValue(address);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在本例中，postalCode字段是public的和final的，因为字段永远不会更改。postalCode字段被定义为addressInput的转换，这意味着在addressInput发生变化时调用了<code>repository.getPostCode()</code>方法。上述的情况在有一个活动的观observer情况下是正确的，而如果<code>repository.getPostCode()</code>被调用时没有一个活动状态的observer，那么是不会发生计算，直到添加一个观察。<br>该机制允许应用程序的较低级别创建基于需求的延迟计算的LiveData对象。ViewModel对象可以很容易地获得对LiveData对象的引用，然后在它们上面定义transformation规则。</p><h2 id="创建新的转换"><a href="#创建新的转换" class="headerlink" title="创建新的转换"></a>创建新的转换</h2><p>在你的应用中有十几个不同的具体的transformation，但它们不是默认提供的。为了实现您自己的转换，您可以使用MediatorLiveData类，它listens其他的LiveData对象，并处理它们发出的事件。MediatorLiveData正确地将其状态传播到源LiveData对象。</p><h1 id="合并多个LiveData源"><a href="#合并多个LiveData源" class="headerlink" title="合并多个LiveData源"></a>合并多个LiveData源</h1><hr><p><code>MediatorLiveData</code>是<code>LiveData</code>的一个子类，它允许您合并多个LiveData数据源。当任何原始的LiveData数据源对象发生变化时，MediatorLiveData对象的观察者就会被触发。<br>例如，如果您的UI中有一个LiveData对象，可以从本地数据库或网络更新，那么您可以将以下源添加到MediatorLiveData对象:</p><ul><li>一个<code>LiveData</code>对象与数据库相关联。</li><li>一个<code>LiveData</code>对象与网络访问相关联。<br>您的activity只需要观察<code>MediatorLiveData</code>对象来接收来自两个源的更新。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;LiveData&lt;/code&gt;是一个可被观察的数据持有类。不同于常规的observable，LiveData是生命周期敏感的，也就意味着它尊重其他组件的生命周期，比如activities, fragments，或者services。这种特性确保了LiveData
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Architecture Components" scheme="http://yoursite.com/tags/Architecture-Components/"/>
    
      <category term="LiveData" scheme="http://yoursite.com/tags/LiveData/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件(三)-生命周期</title>
    <link href="http://yoursite.com/2017/09/15/architecture-lifecycle/"/>
    <id>http://yoursite.com/2017/09/15/architecture-lifecycle/</id>
    <published>2017-09-15T07:14:25.000Z</published>
    <updated>2018-04-11T08:50:23.718Z</updated>
    
    <content type="html"><![CDATA[<p><code>android.arch.lifecycle</code>包提供了类和接口，使得你可以构建“生命周期敏感的组件”——自动适应当前<code>Fragment</code>或者<code>Activity</code>的组件。</p><blockquote><p><strong>注意：</strong>如何引入android.arch.lifecycle到你的安卓项目中，详见<a href="https://developer.android.com/topic/libraries/architecture/adding-components.html" target="_blank" rel="noopener">adding components to your project</a></p></blockquote><p>安卓框架所定义的大多数组件都有相关的生命周期。生命周期被操作系统或运行在你程序中的框架代码所管理。它们是安卓运行的核心，你的应用必须遵守它们，不要做触发内存泄漏或应用崩溃的事情。</p><p>想象一下我们有一个在屏幕上显示位置的Activity，一个常见的实现大概像这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//连接至系统位置服务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从系统位置服务断开</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, (location) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 更新UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        myLocationListener.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使这个样例代码看起来还不错，但是在实际的app中，由于拥有过多的<code>start()</code>和<code>stop</code>而导致<code>onStart()</code>和<code>onStop()</code>非常巨大。</p><p>此外，一些组件不能只在<code>onStart()</code>中开始。如果我们需要在开始位置观察前检查一些配置怎么办？某种情况下很可能检查会在Activity停止后结束，这意味着<code>myLocationListener.start()</code>会在<code>myLocationListener.stop()</code>之后调用，基本上会一直保持连接。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, location -&gt; &#123;</span><br><span class="line">            <span class="comment">// 更新UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="comment">//如果回调在activity停止后调用呢？</span></span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>android.arch.lifecycle</code>包提供了类和接口，帮助你解决这个问题。</p><h1 id="Lifecycle类"><a href="#Lifecycle类" class="headerlink" title="Lifecycle类"></a>Lifecycle类</h1><hr><p><code>Lifecycle</code>是一个持有某组件生命周期状态的类，并允许其他对象观察这一状态。</p><p><code>Lifecycle</code>使用两个枚举类型来跟踪相关联组件的生命周期状态。</p><ul><li><strong>Event（事件）:</strong><br>生命周期事件由框架和Lifecycle类分发。这些事件映射到Activity和Fragment的回调。</li><li><strong>State（状态）：</strong><br>由Lifecycle对象所跟踪组件的当前状态。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/09/15/architecture-lifecycle/lifecycle-states.png" alt="t1" title="">                </div>                <div class="image-caption">t1</div>            </figure></li></ul><p>请将状态想成图的节点，将事件想成两个节点的边。 一个可以显示组件生命周期状态的类通过添加注解到其方法中来实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">disconnectListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myLifecycleOwner.getLifecycle().addObserver(<span class="keyword">new</span> MyObserver());</span><br></pre></td></tr></table></figure></p><h1 id="LifecycleOwner类"><a href="#LifecycleOwner类" class="headerlink" title="LifecycleOwner类"></a>LifecycleOwner类</h1><hr><p><code>LifecycleOwner</code>是一个单一方法的接口，表示该类拥有一个<code>Lifecycle</code>。它只有一个方法且必须实现：<code>getLifecycle()</code>。</p><p>这个接口从单独的类中抽象出生命周期的所有权，如<code>Fragment</code> 和<code>AppCompatActivity</code>，并且允许编写可与两者兼容的组件。任何自定义应用程序类可以实现<code>lifecycleowner</code>接口。</p><p>实现<code>lifecycleobserver</code>接口的组件可以很好与实现<code>LifecycleOwner</code>接口的对象工作，因为一个可以用来提供生命周期，而一个observer 可以监听它。</p><p>对于位置跟踪的例子，我们让<code>MyLocationListener</code> 类实现<code>LifecycleObserver</code> ， 然后把在<code>onCreate()</code>方法中把它和<code>Activity</code>的生命周期联系起来。这让<code>MyLocationListener</code> 类能自给自足，这意味着可以在<code>MyLocationListener</code> 类中来做对生命周期的响应逻辑而不是在<code>Activity</code>中来处理。让各个组件存储自己的逻辑使activities 和fragments 的逻辑更容易管理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, getLifecycle(), location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.enable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个常见的用例是，如果<code>Lifecycle</code>并不处在良好的状态，则立刻避免调用具体的回调。</p><p>为了使这变的简单，<code>Lifecycle</code> 类允许其他对象查询当前的状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Lifecycle lifecycle, Callback callback)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_START)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">           <span class="comment">// connect</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        enabled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(STARTED)) &#123;</span><br><span class="line">            <span class="comment">// connect if not connected</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_STOP)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disconnect if connected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这种实现下，我们的LocationListener类是完全生命周期敏感的，它可以做自己的初始化以及清除工作，而不需要被Activity管理。如果我们需要从另一个Activity或者Fragment使用自己的LocationListener，我们只需要初始化它就可以了。所有的搭建和拆除操作都由该类自己管理。</p><p>可以和Lifecycle一同工作的类被叫做生命周期敏感的组件。需要和Android生命周期共同工作的类是值得提倡变成生命周期敏感组件的。因此它们的客户端可以轻易地整合这些类，而不需要手动管理客户端的生命周期。</p><h2 id="实现自定义LifecycleOwner"><a href="#实现自定义LifecycleOwner" class="headerlink" title="实现自定义LifecycleOwner"></a>实现自定义LifecycleOwner</h2><p>Fragments 和 Activities在Support Library 26.1.0及以后的版本中实现了LifecycleOwner接口。<br>如果你有一个自定义的类，你想做一个LifecycleOwner，你可以用lifecycleregistry类，但你需要将事件转发到该自定义的类，如下面的代码示例所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>LiveData是一个生命周期敏感组件的样例。将LiveData和ViewModel一起使用可以更轻易地构建遵循Android生命周期的app。</p><h1 id="Lifecycles的最佳实践"><a href="#Lifecycles的最佳实践" class="headerlink" title="Lifecycles的最佳实践"></a>Lifecycles的最佳实践</h1><hr><ul><li>保持你的UI控制器（activities， fragments）体积尽可能地瘦小。它们不应该尝试获得自己的数据，使用ViewModel去做这件事，然后观察LiveData以响应数据的变化至UI。</li><li>尝试编写数据驱动的UI，你的UI控制器仅仅负责当数据变化时更新UI，或通知至ViewModel。</li><li>将你的数据逻辑放到你的ViewModel类中，ViewModel应该作为你的UI控制器和app剩余部分的连接器。然而请小心，ViewModel的职责并不在于获取数据（例如从网路中获取数据）。相反ViewModel应当调用正确的组件去做这件工作，之后给UI控制器提供结果。</li><li>使用数据绑定在你的视图和UI控制器之间维护一个清晰的接口。这允许你在activities/fragments更新最少的代码。如果你想在Java这样做，使用[Butter Knife]这样的类库来避免模板代码，以及拥有更好的抽象。</li><li>如果你的UI很复杂，考虑创建一个Presenter类来处理UI的修改。</li><li>永远不要在你的ViewModel中引用View或者Activity的Context。如果ViewModel在Activity之外存活，你的Activity将会被泄漏并且不能正确地被回收。</li></ul><h2 id="生命周期感知组件的使用示例"><a href="#生命周期感知组件的使用示例" class="headerlink" title="生命周期感知组件的使用示例"></a>生命周期感知组件的使用示例</h2><p>生命周期感知组件可以使你在各种情况下更容易管理的生命周期。举几个例子：</p><ul><li>在非精确和精确位置更新之间切换。使用生命周期感知组件，在应用程序是可见时使用精确的定位，当应用程序是切换到后台时切换到非精确定位模式。LiveData，生命周期感知组件，可以让你实现在位置发生变化时自动更新UI。</li><li>停止和启动视频缓冲。使用生命周期感知组件尽可能快地启动视频缓冲，一旦应用程序完全启动就可以播放了。您还可以使用生命周期感知组件在应用程序被销毁时终止缓冲。</li><li>启动和停止网络连接。使用生命周期感知组件，当应用程序位于前台启用网络数据的实时更新（流），也可以在应用程序进入后台时自动暂停。</li><li>暂停和恢复的动画图片。使用生命周期感知组件， 应用程序在后台时暂停动画，当切换到前台时又恢复。</li></ul><h2 id="处理停止事件"><a href="#处理停止事件" class="headerlink" title="处理停止事件"></a>处理停止事件</h2><p>当一个<code>Lifecycle</code>属于一个<code>AppCompatActivity</code>或者<code>Fragment</code>时，那么当 <code>AppCompatActivity</code>或者Fragment’s <code>onSaveInstanceState()</code>被调用的时候<code>Lifecycle</code>会切换到<code>CREATED</code>状态同时发送一个<code>ON_STOP</code>事件。</p><p>当一个<code>Fragment</code>或者<code>AppCompatActivity</code>调用<code>onSaveInstanceState()</code>保存状态，它假设UI是不会发生改变，直到<code>ON_START</code>被调用。也就是说在保存状态后尝试修改UI可能会导致应用程序的导航状态不一致。这也就是为什么如果APP在状态保存后运行一个<code>FragmentTransaction</code>，<code>FragmentManager</code>就会抛出一个异常。</p><p><code>LiveData</code>可以很方便的通过 observer’s相关联的Lifecycle是否处于STARTED状态来决定是否调用该observer的方式来避免上述情况。在幕后，是LiveData调用了它的isAtLeast()。</p><p>不幸的是，在<code>onSaveInstanceState()</code>之后调用AppCompatActivity的<code>onStop()</code>，这会产生一个空白时间段。在该空白时间段内UI是不允许改变的，但是Lifecycle还没有进入到CREATED的状态</p><p>为了防止这个问题，Lifecycle类在版本beta2中，在不发送事件的情况下标记状态为CREATED，这样任何检查当前状态的代码都会得到真正的值，直到系统调用<code>onStop()</code>后才开始发送事件。</p><p>不幸的是，上面这种解决办法有两个问题：</p><ul><li>在API级别23和更低的情况下，Android系统实际上保存了一个Activity的状态，即使它被另一个Activity覆盖了部分。换句话说，Android系统调用onsaveinstancestate()但不一定需要调用onstop()。这将创建一个潜在的长间隔，在这种情况下，观察者仍然认为lifecycle是活动的，即使它的UI处于不能修改状态。</li><li>任何类，想要暴露类似于livedata类的行为，必须实现beta2或者更低版本Lifecycle提供的解决方法。<blockquote><p><strong>注意：</strong>为了使流程更简单和提供与旧版本的兼容性，从版本1.0.0-rc1，当onsaveinstancestate()被调用时，Lifecycle对象标记为CREATED并且发送ON_STOP事件，无需等待onstop()方法的调用。这不太可能影响您的代码，但这是您需要注意的，因为它与API级别26或者更低的Activity类中的调用顺序不匹配。</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;android.arch.lifecycle&lt;/code&gt;包提供了类和接口，使得你可以构建“生命周期敏感的组件”——自动适应当前&lt;code&gt;Fragment&lt;/code&gt;或者&lt;code&gt;Activity&lt;/code&gt;的组件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Architecture Components" scheme="http://yoursite.com/tags/Architecture-Components/"/>
    
      <category term="Lifecycle" scheme="http://yoursite.com/tags/Lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Android 8.0 行为变更</title>
    <link href="http://yoursite.com/2017/09/15/android-8-0-changes/"/>
    <id>http://yoursite.com/2017/09/15/android-8-0-changes/</id>
    <published>2017-09-15T03:02:23.000Z</published>
    <updated>2018-04-10T01:33:13.438Z</updated>
    
    <content type="html"><![CDATA[<p>Android 8.0 除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。</p><p>其中大部分变更会影响所有应用，而不论应用针对的是何种版本的 Android。不过，有几项变更仅影响针对 Android 8.0 的应用。为清楚起见，本页面分为两个部分：<strong>针对所有 API 级别的应用</strong>和<strong>针对 Android 8.0 的应用</strong>。</p><h1 id="针对所有-API-级别的应用"><a href="#针对所有-API-级别的应用" class="headerlink" title="针对所有 API 级别的应用"></a>针对所有 API 级别的应用</h1><hr><p>这些行为变更适用于 在 Android 8.0 平台上运行的 所有应用，无论这些应用是针对哪个 API 级别构建。所有开发者都应查看这些变更，并修改其应用以正确支持这些变更（如果适用）。</p><h2 id="后台执行限制"><a href="#后台执行限制" class="headerlink" title="后台执行限制"></a>后台执行限制</h2><p>Android 8.0 为提高电池续航时间而引入的变更之一是，当您的应用进入<strong>已缓存</strong>状态时，如果没有活动的<strong>组件</strong>，系统将解除应用具有的所有唤醒锁。</p><p>此外，为提高设备性能，系统会限制未在前台运行的应用的某些行为。具体而言：</p><ul><li>现在，在后台运行的应用对后台服务的访问受到限制。</li><li>应用无法使用其清单注册大部分隐式广播（即，并非专门针对此应用的广播）。</li></ul><p>默认情况下，这些限制仅适用于针对 O 的应用。不过，用户可以从 Settings 屏幕为任意应用启用这些限制，即使应用并不是以 O 为目标平台。<br>Android 8.0 还对特定函数做出了以下变更：</p><ul><li>如果针对 Android 8.0 的应用尝试在不允许其创建后台服务的情况下使用 <code>startService()</code> 函数，则该函数将引发一个 <code>IllegalStateException</code>。</li><li>新的 <code>Context.startForegroundService()</code> 函数将启动一个前台服务。现在，即使应用在后台运行，系统也允许其调用 <code>Context.startForegroundService()</code>。不过，应用必须在创建服务后的五秒内调用该服务的 <code>startForeground()</code> 函数。<br>如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/background.html" target="_blank" rel="noopener">后台执行限制</a>。</li></ul><h2 id="Android-后台位置限制"><a href="#Android-后台位置限制" class="headerlink" title="Android 后台位置限制"></a>Android 后台位置限制</h2><p>为节约电池电量、保持良好的用户体验和确保系统健康运行，在运行 Android 8.0 的设备上使用后台应用时，降低了后台应用接收位置更新的频率。此行为变更会影响包括 Google Play 服务在内的所有接收位置更新的应用。</p><p>此类变更会影响以下 API：</p><ul><li>Fused Location Provider (FLP)</li><li>Geofencing</li><li>GNSS Measurements</li><li>Location Manager</li><li>Wi-Fi Manager</li></ul><p>为确保您的应用按预期方式运行，请完成以下步骤：</p><ul><li>查看您的应用的逻辑，并确保您使用的是最新的位置 API。</li><li>测试您的应用是否在每个用例中都表现出预期行为。</li><li>考虑使用 Fused Location Provider (FLP) 或地理围栏来处理依赖于用户当前位置的用例。</li></ul><p>如需了解此类变更的详细信息，请参阅后台位置限制。</p><h2 id="应用快捷键"><a href="#应用快捷键" class="headerlink" title="应用快捷键"></a>应用快捷键</h2><p>Android 8.0 对应用快捷方式做出了以下变更：</p><ul><li><code>com.android.launcher.action.INSTALL_SHORTCUT</code> 广播不再会对您的应用有任何影响，因为它现在是私有的隐式广播。相反，您应使用 <code>ShortcutManager</code> 类中的 <code>requestPinShortcut()</code> 函数创建应用快捷方式。</li><li>现在，<code>ACTION_CREATE_SHORTCUT</code> Intent 可以创建可使用 <code>ShortcutManager</code> 类进行管理的应用快捷方式。此 Intent 还可以创建不与 <code>ShortcutManager</code> 交互的旧版启动器快捷方式。在以前，此 Intent 只能创建旧版启动器快捷方式。</li><li>现在，使用 <code>requestPinShortcut()</code> 创建的快捷方式和在处理 <code>ACTION_CREATE_SHORTCUT Intent</code> 的操作组件中创建的快捷方式均已转换为功能齐全的应用快捷方式。因此，应用现在可以使用 ShortcutManager 中的函数来更新这些快捷方式。</li><li>旧版快捷方式仍然保留了它们在旧版 Android 中的功能，但您必须在应用中手动将它们转换成应用快捷方式。</li></ul><p>如需了解有关应用快捷方式变更的更多信息，请参阅<a href="https://developer.android.com/preview/features/pinning-shortcuts-widgets.html" target="_blank" rel="noopener">固定快捷方式和微件预览功能指南</a>。</p><h2 id="语言区域和国际化"><a href="#语言区域和国际化" class="headerlink" title="语言区域和国际化"></a>语言区域和国际化</h2><p>Android 7.0（API 级别 24）引入能指定默认类别语言区域的概念，但是某些 API 在本应使用默认 <code>DISPLAY</code> 类别语言区域时，仍然使用不带参数的通用 <code>Locale.getDefault()</code> 函数。现在，在 Android 8.0 中，以下函数使用 <code>Locale.getDefault(Category.DISPLAY)</code> 来代替 <code>Locale.getDefault()</code>：</p><ul><li><code>Currency.getDisplayName()</code></li><li><code>Currency.getSymbol()</code></li><li><code>Locale.getDisplayScript()</code></li></ul><p>当为 <code>Locale</code> 参数指定的 <code>displayScript</code> 值不可用时，<code>Locale.getDisplayScript(Locale)</code> 同样回退到 <code>Locale.getDefault()</code>。</p><p>与语言区域和国际化有关的其他变更如下：</p><ul><li>调用 <code>Currency.getDisplayName(null)</code> 会引发 <code>NullPointerException</code>，以与文档规定的行为保持一致。</li><li><p>时区名称的分析方法发生变化。之前，Android 设备使用在启动时取样的系统时钟值，缓存用于分析日期时间的时区名称。因此，如果在启动时或其他较为罕见的情况下系统时钟出错，可能对分析产生负面影响。<br>现在，一般情况下，在分析时区名称时分析逻辑将使用 ICU 和当前系统时钟值。此项变更可提供更加准确的结果，如果您的应用使用 <code>SimpleDateFormat</code> 等类，此结果可能与之前的 Android 版本不同。</p></li><li><p>Android 8.0 将 ICU 的版本更新至版本 58。</p></li></ul><h2 id="提醒窗口"><a href="#提醒窗口" class="headerlink" title="提醒窗口"></a>提醒窗口</h2><p>如果应用使用 <code>SYSTEM_ALERT_WINDOW</code> 权限并且尝试使用以下窗口类型之一来在其他应用和系统窗口上方显示提醒窗口：</p><ul><li><code>TYPE_PHONE</code></li><li><code>TYPE_PRIORITY_PHONE</code></li><li><code>TYPE_SYSTEM_ALERT</code></li><li><code>TYPE_SYSTEM_OVERLAY</code></li><li><code>TYPE_SYSTEM_ERROR</code></li></ul><p>…那么，这些窗口将始终显示在使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型的窗口下方。如果应用针对的是 Android 8.0，则应用会使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型来显示提醒窗口。</p><p>如需了解详细信息，请参阅针对 Android 8.0 的应用的行为变更内的<a href="https://developer.android.com/about/versions/oreo/android-8.0-changes.html#cwt" target="_blank" rel="noopener">提醒窗口的常用窗口类型</a>部分。</p><h2 id="输入和导航"><a href="#输入和导航" class="headerlink" title="输入和导航"></a>输入和导航</h2><p>随着 Android 应用出现在 Chrome 操作系统和平板电脑等其他大尺寸设备上，我们看到，用户在 Android 应用中又重新开始使用键盘导航。在 Android 8.0 中，我们又再次使用键盘作为导航输入设备，从而为基于箭头键和 Tab 键的导航构建了一种更可靠并且可预测的模型。</p><p>尤其要指出的是，我们对元素焦点行为做出以下变更：</p><ul><li><p>现在，如果您没有为 View 对象（前景或背景图片）定义任何焦点状态颜色，框架会为 View 设置默认的焦点突出显示颜色。此焦点突出显示标志是基于操作组件主题背景的涟漪图片。<br>如果您不希望 View 对象在接收焦点时使用此默认突出显示标志，请在包含 View 的布局 XML 文件中将 android:defaultFocusHighlightEnabled 属性设置为 false，或者将 false 传递至应用界面逻辑中的 setDefaultFocusHighlightEnabled()。</p></li><li><p>要测试键盘输入对界面元素焦点有何影响，您可以启用 <strong>Drawing &gt; Show layout bounds</strong> 开发者选项。在 Android 8.0 中，此选项在当前具有焦点的元素上显示一个“X”图标。</p></li></ul><p>另外，Android 8.0 中的所有工具栏元素自动组成<a href="https://developer.android.com/preview/api-overview.html#kbnc" target="_blank" rel="noopener">键盘导航键区</a>用户可以更加轻松地导航进入和离开每个作为一个整体的工具栏。</p><p>如需详细了解如何在您的应用中改善对键盘导航的支持，请阅读<a href="https://developer.android.com/training/keyboard-input/navigation.html" target="_blank" rel="noopener">支持键盘导航</a>南。</p><h2 id="网页表单自动填充"><a href="#网页表单自动填充" class="headerlink" title="网页表单自动填充"></a>网页表单自动填充</h2><p>现在，Android 自动填充框架提供对自动填充功能的内置支持，对于安装到运行 Android 8.0 的设备上的应用，与 WebView 对象相关的下列函数已经发生变化：</p><p><strong>WebSettings</strong></p><ul><li><code>getSaveFormData()</code> 函数现在返回 false。之前，此函数返回 true。</li><li>调用 <code>setSaveFormData()</code> 不再有任何效果。<br><strong>WebViewDatabase</strong></li><li>调用 <code>clearFormData()</code> 不再有任何效果。</li><li><code>hasFormData()</code> 函数现在返回 false。之前，当表单包含数据时，此函数返回 true。</li></ul><h2 id="无障碍功能"><a href="#无障碍功能" class="headerlink" title="无障碍功能"></a>无障碍功能</h2><p>现在，无障碍服务可识别应用的 <code>TextView</code> 对象内部的所有 <code>ClickableSpan</code> 实例。</p><p>如需了解有关如何让您的应用更便于访问的更多信息，请参阅<a href="https://developer.android.com/guide/topics/ui/accessibility/index.html" target="_blank" rel="noopener">无障碍功能</a>。</p><h2 id="网络连接和-HTTP-S-连接"><a href="#网络连接和-HTTP-S-连接" class="headerlink" title="网络连接和 HTTP(S) 连接"></a>网络连接和 HTTP(S) 连接</h2><p>Android 8.0 对网络连接和 HTTP(S) 连接行为做出了以下变更：</p><ul><li>无正文的 OPTIONS 请求具有 Content-Length: 0 标头。之前，这些请求没有 Content-Length 标头。</li><li>HttpURLConnection 在包含斜线的主机或颁发机构名称后面附加一条斜线，使包含空路径的网址规范化。例如，它将 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 转化为 <a href="http://example.com/。" target="_blank" rel="noopener">http://example.com/。</a></li><li>通过 ProxySelector.setDefault() 设置的自定义代理选择器仅针对所请求的网址（架构、主机和端口）。因此，仅可根据这些值选择代理。传递至自定义代理选择器的网址不包含所请求的网址的路径、查询参数或片段。</li><li><p>URI 不能包含空白标签。<br>之前，平台支持一种权宜方法，即允许主机名称中包含空白标签，但这是对 URI 的非法使用。此权宜方法只是为了确保与旧版 libcore 兼容。开发者如果对 API 使用不当，将会看到一条 ADB 消息：“URI example..com 的主机名包含空白标签。此格式不正确，将不被未来的 Android 版本所接受。”Android 8.0 废除了此权宜方法；系统对格式错误的 URI 会返回 null。</p></li><li><p>Android 8.0 在实现 HttpsURLConnection 时不会执行不安全的 TLS/SSL 协议版本回退。</p></li><li><p>对隧道 HTTP(S) 连接处理进行了如下变更：</p><ul><li>在通过连接建立隧道 HTTP(S) 连接时，系统会在 Host 行中正确放置端口号 (:443) 并将此信息发送至中间服务器。之前，端口号仅出现在 CONNECT 行中。</li><li>系统不再将隧道连接请求中的 user-agent 和 proxy-authorization 标头发送至代理服务器。<br>在建立隧道时，系统不再将隧道 Http(s)URLConnection 中的 proxy-authorization 标头发送至代理。相反，由系统生成 proxy-authorization 标头，在代理响应初始请求发送 HTTP 407 后将其发送至此代理。<br>同样地，系统不再将 user-agent 标头由隧道连接请求复制到建立隧道的代理请求。相反，库为此请求生成 user-agent 标头。</li></ul></li><li><p>如果之前执行的 connect() 函数失败，·send(java.net.DatagramPacket)· 函数将会引发 SocketException。</p><ul><li>如果存在内部错误，·DatagramSocket.connect()· 会引发 pendingSocketException。对于 Android 8.0 之前的版本，即使 send() 调用成功，后续的 recv() 调用也会引发 SocketException。为确保一致性，现在这两个调用均会引发 SocketException。</li></ul></li><li>在回退到 TCP Echo 协议之前，InetAddress.isReachable() 会尝试执行 ICMP。<ul><li>对于某些屏蔽端口 7 (TCP Echo) 的主机（例如 google.com），如果它们接受 ICMP Echo 协议，现在也许能够访问它们。</li><li>对于确实无法访问的主机，此项变更意味着调用需要两倍的时间才能返回结果。</li></ul></li></ul><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>Android 8.0 对 <code>ScanRecord.getBytes()</code> 函数检索的数据长度做出以下变更：</p><ul><li><code>getBytes()</code> 函数对于所接收的字节数不作任何假定。因此，应用不应受所返回的任何最小或最大字节数的影响。相反，应用应当计算所返回数组的长度。</li><li>兼容蓝牙 5 的设备返回的数据长度可能会超出之前最大约 60 个字节的限制。</li><li>如果远程设备未提供扫描响应，则也可能返回少于 60 个字节的数据。</li></ul><h2 id="无缝连接"><a href="#无缝连接" class="headerlink" title="无缝连接"></a>无缝连接</h2><p>Android 8.0 对 WLAN 设置进行了多项改进，这样可以更轻松地选择能够提供最佳用户体验的 WLAN 网络。具体变更包括：</p><ul><li>稳定性和可靠性改进。</li><li>更加直观的界面。</li><li>一个合并的 WLAN 首选项菜单。</li><li>当附近存在优质的已保存网络时在兼容设备上自动激活 WLAN。</li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>Android 8.0 包含以下与安全性有关的变更：</p><ul><li>此平台不再支持 SSLv3。</li><li>在与未正确实现 TLS 协议版本协商的服务器建立 HTTPS 连接时，<code>HttpsURLConnection</code> 不再尝试回退到之前的 TLS 协议版本并重试的权宜方法。</li><li>Android 8.0 将使用安全计算 (SECCOMP) 过滤器来过滤所有应用。允许的系统调用列表仅限于通过 bionic 公开的系统调用。此外，还提供了其他几个后向兼容的系统调用，但我们不建议使用这些系统调用。</li><li>现在，您的应用的 <code>WebView</code> 对象将在多进程模式下运行。网页内容在独立的进程中处理，此进程与包含应用的进程相隔离，以提高安全性。</li><li>您无法再假定 APK 驻留在名称以 -1 或 -2 结尾的目录中。应用应使用 <code>sourceDir</code> 获取此目录，而不能直接使用目录格式。</li><li>如需了解与使用原生库有关的安全性增强的信息，请参阅<a href="https://developer.android.com/about/versions/oreo/android-8.0-changes.html#nl" target="_blank" rel="noopener">原生库</a>。</li></ul><p>有关提升应用安全性的其他准则，请参阅<a href="https://developer.android.com/topic/security/index.html" target="_blank" rel="noopener">面向 Android 开发者的安全性</a>。</p><h2 id="隐私性"><a href="#隐私性" class="headerlink" title="隐私性"></a>隐私性</h2><p>Android 8.0 对平台做出了以下与隐私性有关的变更。</p><ul><li><p>现在，平台改变了标识符的处理方式。</p><ul><li>对于在 OTA 之前安装到某个版本 Android 8.0（API 级别 26）的应用，除非在 OTA 后卸载并重新安装，否则 <code>ANDROID_ID</code> 的值将保持不变。要在 OTA 后在卸载期间保留值，开发者可以使用<code>密钥/值备份</code>关联旧值和新值。</li><li>对于安装在运行 Android 8.0 的设备上的应用，<code>ANDROID_ID</code> 的值现在将根据应用签署密钥和用户确定作用域。应用签署密钥、用户和设备的每个组合都具有唯一的 <code>ANDROID_ID</code> 值。因此，在相同设备上运行但具有不同签署密钥的应用将不会再看到相同的 Android ID（即使对于同一用户来说，也是如此）。</li><li>只要签署密钥相同（并且应用未在 OTA 之前安装到某个版本的 O），<code>ANDROID_ID</code> 的值在软件包卸载或重新安装时就不会发生变化。</li><li>即使系统更新导致软件包签署密钥发生变化，<code>ANDROID_ID</code> 的值也不会变化。<br>要借助一个简单的标准系统实现应用获利，请使用广告 ID。广告 ID 是 Google Play 服务针对广告服务提供的唯一 ID，此 ID 可由用户重置。</li></ul></li><li><p>查询 net.hostname 系统属性返回的结果为空。</p></li></ul><h2 id="记录未捕获的异常"><a href="#记录未捕获的异常" class="headerlink" title="记录未捕获的异常"></a>记录未捕获的异常</h2><p>如果某个应用安装的 <code>Thread.UncaughtExceptionHandler</code> 未移交给默认的 <code>Thread.UncaughtExceptionHandler</code>，则当出现未捕获的异常时，系统不会终止应用。从 Android 8.0 开始，在此情况下系统将记录异常堆栈跟踪情况；在之前的平台版本中，系统不会记录异常堆栈跟踪情况。</p><p>我们建议，自定义 <code>Thread.UncaughtExceptionHandler</code> 实现始终移交给默认处理程序处理；遵循此建议的应用不受 Android 8.0 此项变更的影响。</p><h2 id="联系人提供程序使用情况统计方法的变更"><a href="#联系人提供程序使用情况统计方法的变更" class="headerlink" title="联系人提供程序使用情况统计方法的变更"></a>联系人提供程序使用情况统计方法的变更</h2><p>在之前版本的 Android 中，联系人提供程序组件允许开发者获取每个联系人的使用情况数据。此使用情况数据揭示了与某个联系人相关联的每个电子邮件地址和每个电话号码的信息，包括与该联系人联系的次数以及上次联系该联系人的时间。请求 <code>READ_CONTACTS</code> 权限的应用可以读取此数据。</p><p>如果应用请求 <code>READ_CONTACTS</code> 权限，它们仍可以读取此数据。从 Android 8.0 开始，使用情况数据查询会返回近似值，而不是精确值。不过，Android 系统内部仍然会保留精确值，因此，此变更不会影响 auto-complete API。</p><p>此行为变更会影响以下查询参数：</p><ul><li><code>TIMES_CONTACTED</code></li><li><code>TIMES_USED</code></li><li><code>LAST_TIME_CONTACTED</code></li><li><code>LAST_TIME_USED</code></li></ul><h2 id="集合的处理"><a href="#集合的处理" class="headerlink" title="集合的处理"></a>集合的处理</h2><p>现在，<code>AbstractCollection.removeAll()</code> 和 <code>AbstractCollection.retainAll()</code> 始终引发 <code>NullPointerException</code>；之前，当集合为空时不会引发 <code>NullPointerException</code>。此项变更使行为符合文档要求。</p><h2 id="Android-企业版"><a href="#Android-企业版" class="headerlink" title="Android 企业版"></a>Android 企业版</h2><p>Android 8.0 更改了企业应用（包括设备规范控制器 (DPC)）的某些 API 和功能的行为。这些变更包括：</p><ul><li>新增多种行为，帮助应用支持完全托管设备中的工作资料。</li><li>变更系统更新处理、应用验证和身份验证方式，以提高设备和系统的完整性。</li><li>改进用户在配置、通知、“最近使用的应用”屏幕和 Always on VPN 方面的体验。</li></ul><p>如需查看 Android 8.0 中的所有企业版变更和了解它们可能给您的应用带来的影响，请阅读企业中的 Android。</p><h1 id="针对-Android-8-0-的应用"><a href="#针对-Android-8-0-的应用" class="headerlink" title="针对 Android 8.0 的应用"></a>针对 Android 8.0 的应用</h1><hr><p>这些行为变更专门应用于针对 O 平台或更高平台版本的应用。针对 Android 8.0 或更高平台版本进行编译，或将 targetSdkVersion 设为 Android 8.0 或更高版本的应用开发者必须修改其应用以正确支持这些行为（如果适用）。</p><h2 id="提醒窗口-1"><a href="#提醒窗口-1" class="headerlink" title="提醒窗口"></a>提醒窗口</h2><p>使用 <code>SYSTEM_ALERT_WINDOW</code> 权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口：</p><ul><li><code>TYPE_PHONE</code></li><li><code>TYPE_PRIORITY_PHONE</code></li><li><code>TYPE_SYSTEM_ALERT</code></li><li><code>TYPE_SYSTEM_OVERLAY</code></li><li><code>TYPE_SYSTEM_ERROR</code></li></ul><p>相反，应用必须使用名为 <code>TYPE_APPLICATION_OVERLAY</code> 的新窗口类型。</p><p>使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型显示应用的提醒窗口时，请记住新窗口类型的以下特性：</p><ul><li>应用的提醒窗口始终显示在状态栏和输入法等关键系统窗口的下面。</li><li>系统可以移动使用 TYPE_APPLICATION_OVERLAY 窗口类型的窗口或调整其大小，以改善屏幕显示效果。</li><li>通过打开通知栏，用户可以访问设置来阻止应用显示使用 TYPE_APPLICATION_OVERLAY 窗口类型显示的提醒窗口。</li></ul><h2 id="内容变更通知"><a href="#内容变更通知" class="headerlink" title="内容变更通知"></a>内容变更通知</h2><p>Android 8.0 更改了 <code>ContentResolver.notifyChange()</code> 和 <code>registerContentObserver(Uri, boolean, ContentObserver)</code> 在针对 Android 8.0 的应用中的行为方式。</p><p>现在，这些 API 需要在所有 URI 中为颁发机构定义一个有效的 <code>ContentProvider</code>。使用相关权限定义一个有效的 <code>ContentProvider</code> 可帮助您的应用防范来自恶意应用的内容变更，并防止将可能的私密数据泄露给恶意应用。</p><h2 id="视图焦点"><a href="#视图焦点" class="headerlink" title="视图焦点"></a>视图焦点</h2><p>可点击的 View 对象现在默认也可以成为焦点。如果您希望 View 对象可点击但不可成为焦点，请在包含 View 的布局 XML 文件中将 <code>android:focusable</code> 属性设置为 false，或者将 false 传递至应用界面逻辑中的 <code>setFocusable()</code>。</p><h2 id="安全性-1"><a href="#安全性-1" class="headerlink" title="安全性"></a>安全性</h2><p>如果您的应用的网络安全性配置选择退出对明文流量的支持，那么您的应用的 <code>WebView</code> 对象无法通过 HTTP 访问网站。每个 <code>WebView</code> 对象必须转而使用 HTTPS。</p><p>有关提升应用安全性的其他准则，请参阅<a href="https://developer.android.com/topic/security/index.html" target="_blank" rel="noopener">面向 Android 开发者的安全性</a>。</p><h2 id="帐号访问和可检测性"><a href="#帐号访问和可检测性" class="headerlink" title="帐号访问和可检测性"></a>帐号访问和可检测性</h2><p>除非身份验证器拥有用户帐号或用户授予访问权限，否则，应用将无法再访问用户帐号。仅拥有 <code>GET_ACCOUNTS</code> 权限尚不足以访问用户帐号。要获得帐号访问权限，应用应使用 <code>AccountManager.newChooseAccountIntent()</code> 或特定于身份验证器的函数。获得帐号访问权限后，应用可以调用 <code>AccountManager.getAccounts()</code> 来访问帐号。</p><p>Android 8.0 已弃用 <code>LOGIN_ACCOUNTS_CHANGED_ACTION</code>。相反，应用在运行时应使用 <code>addOnAccountsUpdatedListener()</code> 获取帐号更新信息。</p><p>有关新增 API 和增加的帐号访问和可检测性函数的信息，请参阅此文档的“新增 API”部分中的帐号访问和可检测性。</p><h2 id="隐私性-1"><a href="#隐私性-1" class="headerlink" title="隐私性"></a>隐私性</h2><p>以下变更影响 Android 8.0 的隐私性。</p><ul><li>系统属性 net.dns1、net.dns2、net.dns3 和 net.dns4 不再可用，此项变更可加强平台的隐私性。</li><li>要获取 DNS 服务器之类的网络连接信息，具有 <code>ACCESS_NETWORK_STATE</code> 权限的应用可以注册 <code>NetworkRequest</code> 或 <code>NetworkCallback</code> 对象。这些类在 Android 5.0（API 级别 21）及更高版本中提供。</li><li>Build.SERIAL 已弃用。需要知道硬件序列号的应用应改为使用新的 <code>Build.getSerial()</code> 函数，该函数要求具有 <code>READ_PHONE_STATE</code> 权限。</li><li><code>LauncherApps</code> API 不再允许工作资料应用获取有关主个人资料的信息。当某个用户在托管配置文件中时，<code>LauncherApps</code> API 的行为就像同一配置文件组的其他配置文件中未安装任何应用一样。和之前一样，尝试访问无关联的个人资料会引发 SecurityExceptions。</li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。</p><p>对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p><p>例如，假设某个应用在其清单中列出 <code>READ_EXTERNAL_STORAGE</code> 和 <code>WRITE_EXTERNAL_STORAGE</code>。应用请求 <code>READ_EXTERNAL_STORAGE</code>，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予 <code>WRITE_EXTERNAL_STORAGE</code>，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 <code>READ_EXTERNAL_STORAGE</code>；不过，如果该应用后来又请求 <code>WRITE_EXTERNAL_STORAGE</code>，则系统会立即授予该权限，而不会提示用户。</p><h2 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h2><ul><li>框架会执行音频闪避。进行 <code>AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</code> 时，应用不会失去焦点。新的 API 适用于需要暂停而不是闪避的应用。请注意，此行为无法在 Android 8.0 1 版本中实现。</li><li>当用户打电话时，活动的媒体流将在通话期间静音。</li><li>所有与音频相关的 API 都应使用 <code>AudioAttributes</code> 而不是音频流类型来说明音频播放用例。仅为音量控制继续使用音频流类型。流类型（例如，已弃用的 <code>AudioTrack constructor</code>）的其他用途仍然有效，但是系统会将其记录为错误。</li><li>使用 <code>AudioTrack</code> 时，如果应用请求了足够大的音频缓冲区，则框架将尝试使用深度缓冲区输出（如果可用）。</li><li>在 Android 8.0 中，媒体按钮事件的处理有所不同：<ol><li>在界面操作组件中处理媒体按钮未发生变化：前台操作组件在处理媒体按钮时仍然优先。</li><li>如果前台操作组件不处理媒体按钮，系统会将媒体按钮路由到最近在本地播放音频的应用。在确定哪些应用接收媒体按钮事件时，不再考虑活动状态、标志和媒体会话的播放状态。即使在应用调用 <code>setActive(false)</code> 后，媒体会话仍然可以接收媒体按钮事件。</li><li>如果应用的媒体会话已经释放，系统会将媒体按钮事件发送到应用的 <code>MediaButtonReceiver</code>（如果有）。</li><li>对于任何其他情况，系统都会舍弃媒体按钮事件。与其开始播放错误的应用，不如不播放任何东西。</li></ol></li></ul><h2 id="原生库"><a href="#原生库" class="headerlink" title="原生库"></a>原生库</h2><p>在针对 Android 8.0 的应用中，如果原生库包含任何可写且可执行的加载代码段，则不会再加载原生库。倘若某些应用的原生库包含不正确的加载代码段，则此变更可能会导致这些应用停止工作。这是一种安全加强措施。</p><p>如需了解详细信息，请参阅<a href="https://android.googlesource.com/platform/bionic/+/master/android-changes-for-ndk-developers.md#Writable-and-Executable-Segments-Enforced-for-API-level-26" target="_blank" rel="noopener">可写且可执行的代码段</a>。</p><p>与早期的开发者预览版相同，Android 8.0 还有助于更轻松地发现所有与链接器有关的问题。链接器的变更绑定到应用的目标 API 级别。如果应用的目标 API 级别发生链接器变更，则该应用无法加载该库。如果您的目标 API 级别低于发生链接器变更的 API 级别，则 logcat 会显示一条警告消息。在预览版期间，与链接器有关的问题不仅会显示在 logcat 中，也会以 toast 的形式显示。对于特定的 API 级别，警告可能会变成错误，此变更有助于提前发现此类问题。</p><h2 id="集合的处理-1"><a href="#集合的处理-1" class="headerlink" title="集合的处理"></a>集合的处理</h2><p>在 Android 8.0 中，<code>Collections.sort()</code> 是在 <code>List.sort()</code> 的基础上实现的。在 Android 7.x（API 级别 24 和 25）中，则恰恰相反。在过去，<code>List.sort()</code> 的默认实现会调用 <code>Collections.sort()</code>。</p><p>此项变更使 <code>Collections.sort()</code> 可以利用优化的 <code>List.sort()</code> 实现，但具有以下限制：</p><ul><li><code>List.sort()</code> 的实现不能调用 <code>Collections.sort()</code>，因为这会导致堆栈因无限递归而溢出。相反，如果您需要 List 实现的默认行为，应避免重写 sort()。<br>如果父类以不适当的方法实现 sort() ，通常最好使用在 <code>List.toArray()</code>、<code>Arrays.sort()</code> 和 <code>ListIterator.set()</code> 的基础上构建的实现重写 <code>List.sort()</code>。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">  Object[] elements = toArray();</span><br><span class="line">  Arrays.sort(elements, c);</span><br><span class="line">  ListIterator&lt;E&gt; iterator = (ListIterator&lt;Object&gt;) listIterator();</span><br><span class="line">  <span class="keyword">for</span> (Object element : elements) &#123;</span><br><span class="line">    iterator.next();</span><br><span class="line">    iterator.set((E) element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在大多数情况下，您也可以使用根据 API 级别委托给其他默认实现的实现重写 <code>List.sort()</code>。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">    Collections.sort(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.sort(comparator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果您选择后者只是因为您希望开发一种适用于所有 API 级别的 sort() 函数，可以考虑赋予其一个唯一的名称，例如 sortCompat()，而不是重写 sort()。</p><ul><li><code>现在，Collections.sort()</code> 只是对调用 sort() 的 List 实现进行的一项结构性修改。例如，在 Android 8.0 之前的平台版本中，如果通过调用 <code>List.sort()</code> 进行排序，则当迭代处理 ArrayList 以及在迭代过程中调用 <code>sort()</code> 时，会引发 <code>ConcurrentModificationException</code>。而 <code>Collections.sort()</code> 则不会引发异常。</li></ul><p>此项变更使平台行为更加一致：现在，两种方法都会引发 <code>ConcurrentModificationException</code>。</p><h2 id="类加载行为"><a href="#类加载行为" class="headerlink" title="类加载行为"></a>类加载行为</h2><p>Android 8.0 检查确保类加载器在加载新类时不会违反运行时假设条件。不论类引用自 Java（来自 <code>forName()</code>）、Dalvik 字节码还是 JNI，都会执行这些检查。平台不会拦截 Java 对 <code>loadClass()</code> 函数的直接调用，也不会检查此类调用的结果。此行为不应影响运行良好的类加载器的正常运行。</p><p>平台将检查类加载器返回的类描述符是否与预期的描述符一致。如果返回的描述符与预期不符，平台会引发 <code>NoClassDefFoundError</code> 错误，并在异常日志中存储一条注明不一致之处的详细错误消息。</p><p>平台还检查请求的类描述符是否有效。此检查捕获间接加载诸如 <code>GetFieldID()</code> 等类的 JNI 调用，向这些类传递无效的描述符。例如，找不到包含 java/lang/String 签名的字段，是因为此签名无效；它应为 Ljava/lang/String;。</p><p>这与 JNI 对 <code>FindClass()</code> 的调用不同，其中 java/lang/String 是一个有效的完全限定名称。</p><p>Android 8.0 不支持多个类加载器同时尝试使用相同的 DexFile 对象来定义类。尝试进行此操作，会导致 Android 运行时引发 InternalError 错误，同时显示消息“Attempt to register dex file <filename> with multiple class loaders”。</filename></p><p>DexFile API 现已弃用，强烈建议您改为使用此平台的类加载器之一，包括 PathClassLoader 或 BaseDexClassLoader。</p><blockquote><p><strong>注：</strong> 您可以创建多个引用文件系统中同一个 APK 或 JAR 文件容器的类加载器。这样做通常不会占用大量内存：如果存储而不压缩容器中的 DEX 文件，平台可以对此类文件执行 mmap 操作，而不直接提取它们。但是，如果平台必须从容器中提取 DEX 文件，以这种方式引用 DEX 文件可能占用大量内存。</p></blockquote><p>在 Android 中，所有类加载器都被视为支持并行运行。当多个线程争用同一个类加载器加载相同的类时，第一个完成此操作的线程胜出，而操作结果将用于其他线程。无论类加载器是返回同一个类、返回不同的类还是引发异常，都将发生此行为。该平台静默忽略此类异常。</p><blockquote><p><strong>注意：</strong> 在低于 Android 8.0 的平台版本中，违反这些假设条件可能导致多次定义同一个类、由于类混淆造成堆损坏和其他不良影响。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 8.0 除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。&lt;/p&gt;
&lt;p&gt;其中大部分变更会影响所有应用，而不论应用针对的是何种版本的 Android。不过，有几项变更仅影响针对 A
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
      <category term="Oreo" scheme="http://yoursite.com/tags/Oreo/"/>
    
      <category term="Android 8.0" scheme="http://yoursite.com/tags/Android-8-0/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件(二)-添加组件</title>
    <link href="http://yoursite.com/2017/09/10/architecture-adding-components/"/>
    <id>http://yoursite.com/2017/09/10/architecture-adding-components/</id>
    <published>2017-09-10T11:24:13.000Z</published>
    <updated>2018-04-11T08:50:04.981Z</updated>
    
    <content type="html"><![CDATA[<p>架构组件发布在谷歌的Maven仓库，可以通过遵循以下步骤使用它们：</p><h2 id="添加谷歌Maven仓库"><a href="#添加谷歌Maven仓库" class="headerlink" title="添加谷歌Maven仓库"></a>添加谷歌Maven仓库</h2><p>Android Studio项目默认没有配置对此仓库的访问。</p><p>为了添加其到你的项目中，打开项目根下的build.gradle文件(不是app或module目录下的)然后修改以下内容：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        google()<span class="comment">//添加谷歌仓库</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="添加架构组件"><a href="#添加架构组件" class="headerlink" title="添加架构组件"></a>添加架构组件</h2><p>打开app或module目录下的build.gradle文件，添加你需要的依赖，你可以添加所有或者根据需要添加部分。</p><blockquote><p><strong>注意：</strong>对于基于Kotlin的应用，应该确保你使用kapt而不是annotationProcessor。而且你应该添加kotlin-kapt插件。</p></blockquote><h2 id="主要依赖"><a href="#主要依赖" class="headerlink" title="主要依赖"></a>主要依赖</h2><p>包括<code>Lifecycles</code>,<code>LiveData</code>,<code>ViewModel</code>,<code>Room</code>和<code>Paging</code>.</p><p>同时也包括了测试的工具用来测试LiveData和Room的迁移。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// ViewModel and LiveData</span></span><br><span class="line">    implementation <span class="string">"android.arch.lifecycle:extensions:1.1.1"</span></span><br><span class="line">    <span class="comment">// alternatively, just ViewModel</span></span><br><span class="line">    implementation <span class="string">"android.arch.lifecycle:viewmodel:1.1.1"</span></span><br><span class="line">    <span class="comment">// alternatively, just LiveData</span></span><br><span class="line">    implementation <span class="string">"android.arch.lifecycle:livedata:1.1.1"</span></span><br><span class="line"></span><br><span class="line">    annotationProcessor <span class="string">"android.arch.lifecycle:compiler:1.1.1"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Room (use 1.1.0-beta2 for latest beta)</span></span><br><span class="line">    implementation <span class="string">"android.arch.persistence.room:runtime:1.0.0"</span></span><br><span class="line">    annotationProcessor <span class="string">"android.arch.persistence.room:compiler:1.0.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Paging</span></span><br><span class="line">    implementation <span class="string">"android.arch.paging:runtime:1.0.0-beta1"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test helpers for LiveData</span></span><br><span class="line">    testImplementation <span class="string">"android.arch.core:core-testing:1.1.1"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test helpers for Room</span></span><br><span class="line">    testImplementation <span class="string">"android.arch.persistence.room:testing:1.0.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="对Lifecycles的Java-8支持"><a href="#对Lifecycles的Java-8支持" class="headerlink" title="对Lifecycles的Java 8支持"></a>对Lifecycles的Java 8支持</h2><p>如果你的应用基于Java 8开发，我们建议使用下面依赖替代<code>android.arch.lifecycle:compiler</code>.<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// Java8 support for Lifecycles</span></span><br><span class="line">    implementation <span class="string">"android.arch.lifecycle:common-java8:1.1.1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="RxJava和ReactiveStreams可选的依赖"><a href="#RxJava和ReactiveStreams可选的依赖" class="headerlink" title="RxJava和ReactiveStreams可选的依赖"></a>RxJava和ReactiveStreams可选的依赖</h2><p>添加可选依赖支持Room RxJava和LiveData ReactiveStreams。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// RxJava support for Room (use 1.1.0-beta2 for latest alpha)</span></span><br><span class="line">    implementation <span class="string">"android.arch.persistence.room:rxjava2:1.0.0"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ReactiveStreams support for LiveData</span></span><br><span class="line">    implementation <span class="string">"android.arch.lifecycle:reactivestreams:1.1.1"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RxJava support for Paging</span></span><br><span class="line">    implementation <span class="string">"android.arch.paging:rxjava2:1.0.0-alpha1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Guava可选的依赖"><a href="#Guava可选的依赖" class="headerlink" title="Guava可选的依赖"></a>Guava可选的依赖</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// Guava support for Room</span></span><br><span class="line">    implementation <span class="string">"android.arch.persistence.room:guava:1.1.0-beta1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="只适用于轻量级Lifecycles的替代引入"><a href="#只适用于轻量级Lifecycles的替代引入" class="headerlink" title="只适用于轻量级Lifecycles的替代引入"></a>只适用于轻量级Lifecycles的替代引入</h2><p>支持库依赖此轻量导入。只提供Lifecycles的支持，不支持LiveData或ViewModel。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// Lifecycles only (no ViewModel or LiveData)</span></span><br><span class="line">    implementation <span class="string">"android.arch.lifecycle:runtime:1.1.1"</span></span><br><span class="line">    annotationProcessor <span class="string">"android.arch.lifecycle:compiler:1.1.1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;架构组件发布在谷歌的Maven仓库，可以通过遵循以下步骤使用它们：&lt;/p&gt;
&lt;h2 id=&quot;添加谷歌Maven仓库&quot;&gt;&lt;a href=&quot;#添加谷歌Maven仓库&quot; class=&quot;headerlink&quot; title=&quot;添加谷歌Maven仓库&quot;&gt;&lt;/a&gt;添加谷歌Maven仓库&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Architecture Components" scheme="http://yoursite.com/tags/Architecture-Components/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件(一)-指导</title>
    <link href="http://yoursite.com/2017/09/10/architecture-guide/"/>
    <id>http://yoursite.com/2017/09/10/architecture-guide/</id>
    <published>2017-09-10T08:24:13.000Z</published>
    <updated>2018-04-11T08:49:40.569Z</updated>
    
    <content type="html"><![CDATA[<p>这份文档用于已经掌握构建Android app基本技能，现在想要了解推荐的架构，想要实践如何构建健壮、生产级别app的开发者。</p><blockquote><p><strong>注意：</strong>本文档假设读者已经熟悉Android框架。如果你刚跟接触Android，请访问[这里]的训练系列，该训练包含了本文档的所有预备知识。</p></blockquote><h1 id="App开发者所面临的常见问题"><a href="#App开发者所面临的常见问题" class="headerlink" title="App开发者所面临的常见问题"></a>App开发者所面临的常见问题</h1><hr><p>与之对应的传统桌面应用在大多数情况下含有一个单一的入口点（快捷图标）并运行作为一个单一的程序，这和Android应用很不同。Android app拥有更复杂的结构。一个典型的Android app往往由多种组件构建而成，包括Activity, Fragment, Service, Content Provider以及Broadcast Receiver。</p><p>这些app组件大部分被声明在app清单文件（AndroidManifest）中，该清单文件被Android系统用于决定如何整合你的app到全局的用户体验中。如上文所说，传统的桌面应用通常作为一个整体运行，而一个编写良好的Android应用需要更加灵活，因为用户常常在不同的app间频繁切换。</p><p>例如，考虑当你想在你最喜欢的社交网络上分享一张照片时会发生什么？app触发一个相机的Intent，Android系统启动了一个相机应用来处理请求。在这个时候，用户离开了该社交网络app，但是在体验上却是无缝衔接的。接着，相机app可能触发其他Intent来开启其他应用，例如启动文件选择器。最终，用户回到了社交网络app并分享了图片。同样地，用户可能在这一处理过程中的任何时刻被电话接听所打断，在接听完成后继续回来分享图片。</p><p>在Android中，这种应用频繁切换的行为很常见，因此你的app必须能够正确处理这些行为。请记住，手机设备是被资源所约束的，因此在任何时候操作系统都有可能为了给新开启的app腾出空间而杀死一些app。</p><p>关于这一切的关键点在于你的app组件可以单独启动并且是无序的，以及该组件可以在任何时候被用户或系统销毁。因为app组件是短暂的，并且它们的生命周期（例如何时创建以及何时销毁）并不受你控制。你不能在你的app组件中存储任何数据或状态，并且你的组件之间不应该互相依赖。</p><h1 id="常见架构原则"><a href="#常见架构原则" class="headerlink" title="常见架构原则"></a>常见架构原则</h1><hr><p>如果你不能使用app组件来存储应用的数据和状态，那么app该如何构建呢？</p><p>你所该关注最重要的事情是在你的app中遵守关注点分离原则。一个常见的错误是把你所有的代码都写在Activity或者Fragment中。任何不操作UI或操作系统交互的代码都不应该放在上述这些类中。请尽量保持这些类的体积瘦小以避免许多生命周期相关的问题。不要忘记你并不拥有这些类，它们只是在你的应用和系统之间交互的粘合剂。安卓系统会在任何时候销毁它们，例如用户的交互行为或者其他因素，如可用内存过低等。为了提供一个可靠的用户体验，最好减少对它们的依赖。</p><p>第二个最重要的原则是你应该用模型驱动界面，最好是持久化模型(Persistent Model)。持久化是一个理想的状态，理由如下：1.如果操作系统销毁了你的应用来释放资源，你的用户不应该因此而丢掉数据。2.甚至当网络堵塞甚至未连接时，你的应用应当继续工作。Model是负责处理应用数据的组件，它们独立于视图(View)以及其他app组件，因此Model和这些生命周期相关的问题也是隔绝的。保持UI代码的简洁以及应用逻辑的自由更易于进行管理。将你的app基于Model类构建将对数据管理有利，并使得它们易于测试。</p><h1 id="推荐app架构"><a href="#推荐app架构" class="headerlink" title="推荐app架构"></a>推荐app架构</h1><hr><p>在这一章节，我们致力于如何使用架构组件(Architecture Components)来构建一个app，我们将通过一个用例进行说明。</p><blockquote><p><strong>注意：</strong>软件工程领域没有银弹。我们不可能找到一种最佳的方法能够一劳永逸地适合所有的场景。但是我们所推荐架构的意义在于对大多数用例来说都是好的。如果你已经有一个比较好的方式来写Android应用，那么你不需要做出改变。</p></blockquote><p>想象一下我们正在构建一个显示用户资料的UI界面。该用户界面将通过REST API从我们的私有后台获取。</p><h2 id="构建用户界面"><a href="#构建用户界面" class="headerlink" title="构建用户界面"></a>构建用户界面</h2><p>UI界面将会由一个叫做<code>UserProfileFragment.java</code>的Fragment和对应的布局文件<code>user_profile_layout.xml</code>组成。</p><p>为了驱动UI界面，我们的数据模型需要持有两个数据元素：</p><ul><li><strong>User ID:</strong>用于区分用户。通过fragment参数将信息传递至Fragment是最佳的方式。如果Android系统销毁了你的进程，这个信息将会被保存，因此当app下次重启时，该id也将是可用的</li><li><strong>User Object:</strong>一个含有用户数据的POJO类</li></ul><p>我们将会创建一个基于<strong>ViewModel</strong>类的<code>UserProfileViewModel</code>来保存信息。</p><p>一个ViewModel提供了指定UI组件的数据，例如一个fragment或activity，并处理数据的交互，例如调用其他组件加载数据或数据的更新修改等。ViewModel并不知道View，也不受配置信息变化的影响，例如由于屏幕旋转造成的Activity重建。</p><p>现在我们拥有以下三个文件：</p><ul><li><strong>user_profile.xml: </strong>定义了屏幕的UI布局</li><li><strong>UserProfileViewModel.java:</strong>准备用于UI的数据类</li><li><strong>UserProfileFragment.java: </strong>UI控制器，在ViewModel中显示数据以及响应用户交互</li></ul><p>下面是我们的初步实现（布局文件比较简单直接省略）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> String userId;</span><br><span class="line">     <span class="keyword">private</span> User user;</span><br><span class="line"> </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.userId = userId;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> user;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileFragment</span> <span class="keyword">extends</span> <span class="title">LifecycleFragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UID_KEY = <span class="string">"uid"</span>;</span><br><span class="line">    <span class="keyword">private</span> UserProfileViewModel viewModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        String userId = getArguments().getString(UID_KEY);</span><br><span class="line">        viewModel = ViewModelProviders.of(<span class="keyword">this</span>).get(UserProfileViewModel.class);</span><br><span class="line">        viewModel.init(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater,</span></span></span><br><span class="line"><span class="function"><span class="params">                @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inflater.inflate(R.layout.user_profile, container, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>如果你已经使用了类似于RxJava或者Agera这样的库，你可以继续使用它们，而不是LiveData。但是如果当你使用它们，请确保正确地处理了生命周期，例如当相关的生命周期拥有者（LifecycleOwner）停止时应当暂停，当生命周期持有者销毁时也应当销毁。你也可以添加android.arch.lifecycle:reactivestreams，使LiveData和其他响应流式库共同使用，例如RxJava。</p></blockquote><p>现在我们将<code>UserProfileViewModel</code>中的User成员变量替换为<code>LiveData&lt;User&gt;</code>，使得当数据更新时，Fragment可以收到通知。关于<code>LiveData</code>一件很棒的事是，它能够对生命周期做出反应，并将在不再需要的时候自动清除引用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">private</span> LiveData&lt;User&gt; user;<span class="comment">//替换行</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> user;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>现在我们修改UserProfileFragment，观察数据变化并更新UI。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">    viewModel.getUser().observe(<span class="keyword">this</span>, user -&gt; &#123;</span><br><span class="line">      <span class="comment">// 此处更新 UI</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每次用户数据被更新时，<code>onChanged</code>回调函数会被调用，UI界面会被更新。</p><p>如果你熟悉其他使用观察回调的类库，你可能会意识到我们并没有复写Fragment的<code>onStop()</code>方法来停止对数据的观察。这在<code>LiveData中</code>是不必要的，因为它对生命周期敏感，这意味着将不会调用回调函数，除非Fragment出在激活状态（接收<code>onStart()</code>但没有接受<code>onStop()</code>）。当Fragment接收<code>onDestroy()</code>方法时，LiveData将会自动清除观察者。</p><p>我们也不会做任何特殊的事情来处理配置的变化（例如旋转屏幕）。当配置发生变化的时候，ViewModel将会自动保存，因此一旦新的Fragment到来时，它将会收到ViewModel的相同实例，带有当前数据的回调函数将会立即被调用。这就是ViewModel不应该直接引用View的原因，ViewModel会在View的生命周期外存活。详见：[ViewModel的生命周期]。</p><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>现在我们将ViewModel和Fragment关联在了一起，但是ViewModel该如何获取数据呢？在本例下，我们假设我们的后台提供了REST API。我们会用<code>Retrofit</code>库来访问我们的后台，当然你可以随意选择其他不同的类库。</p><p>这里就是和我们后台交互的retrofit接口Webservice：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Webservice</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@GET</span> 声明是一个HTTP GET请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Path</span>("user") 标记了userId参数来替换GET请求中的&#123;user&#125;路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"/users/&#123;user&#125;"</span>)</span><br><span class="line">    <span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String userId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于Retrofit的使用请详见官方文档，这里只是简单进行了说明</p><p>ViewModel的原生实现可以直接调用Webservice来获取数据并交给用户对象。即使这样可以生效，你的app将会随着增长而难以维护。相对于我们上文所提到的关注点分离原则，这种方式给予了ViewModel类太多的职责。另外ViewModel的作用于被绑在Activity或Fragment的生命周期上，因此当生命周期结束的时候丢掉这些数据是一种很糟糕的用户体验。作为替代，我们的ViewModel将会把这一工作委派给新的仓库（Repository）模块。</p><p>仓库模块(Repository Module)负责处理数据操作。他们提供了清晰的API，并且知道在哪获取数据以及哪种API的调用会导致数据更新。你可以考虑把它作为多种数据源的中介（持久化模型，网络服务数据，缓存等）。</p><p>下方的<code>UserRepository</code>类将会使用<code>WebService</code>来获取数据项：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Webservice webservice;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这并不是最佳的实现方式，我们将在下文修正它</span></span><br><span class="line">        <span class="keyword">final</span> MutableLiveData&lt;User&gt; data = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">        webservice.getUser(userId).enqueue(<span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 错误情况的处理被省略了</span></span><br><span class="line">                data.setValue(response.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>即使仓库模型看起来并不需要，但是它完成了一个重要的目标：它将app中的数据源抽象了出来。现在我们的ViewModel不知道数据是由Webservice获取而来的，这意味着在需要其他实现的时候我们可以进行替换。</p><h3 id="管理组件间的依赖"><a href="#管理组件间的依赖" class="headerlink" title="管理组件间的依赖"></a>管理组件间的依赖</h3><p>上面的<code>UserRepository</code>类需要<code>WebService</code>接口的一个实例去进行工作。我们当然可以在每个仓库模型类中简单地创建一个，不过需要知道<code>WebService</code>所依赖的具体子类。这将会显著提高代码的复杂性和冗余。另外<code>UserRepository</code> 也可能不是唯一需要<code>WebService</code>的类，如果每个类都创建一个<code>WebService</code>，这将会浪费很多的资源。</p><p>有两种模式可以解决这个问题：</p><ul><li><strong>依赖注入：</strong>依赖注入允许类定义依赖而不用去构造他们。在运行的时候，另一个类负责提供这些依赖关系。我们推荐在安卓中使用谷歌的[Dagger 2]类库进行依赖注入。通过遍历依赖树，Dagger 2 自动构造对象并提供编译时的依赖保障。</li><li><strong>服务定位：</strong>服务定位器提供了注册器，使得类可通过依赖进行构建，而不是需要配置它们。服务定位模式相对依赖注入而言更易于实现，因此如果你并不熟悉依赖注入，可以使用服务定位来代替。</li></ul><h2 id="连接ViewModel和仓库"><a href="#连接ViewModel和仓库" class="headerlink" title="连接ViewModel和仓库"></a>连接ViewModel和仓库</h2><p>现在我们修改我们的UserProfileViewModel以使用仓库：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LiveData&lt;User&gt; user;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span> <span class="comment">// UserRepository 参数由Dagger 2提供</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserProfileViewModel</span><span class="params">(UserRepository userRepo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userRepo = userRepo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// ViewModel 由每个fragment创建，因此我们知道并不会发生改变</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        user = userRepo.getUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h2><p>上述仓库的实现易于抽象了调用网络服务的过程，但是因为它仅仅依赖于一个单一的数据源，因此并不是很实用。</p><p><code>UserRepository</code>实现的问题在于在获取数据以后，并没有在任何地方保存它。如果用户离开了<code>UserProfileFragment</code>并再次回来，app会重新获取数据。这很糟糕，有以下两个原因：1.浪费了宝贵的网络带宽；2.强迫用户等待新的请求完成。为了解决这个问题，我们将在<code>UserRepository</code>添加一个新的数据源在内存中缓存我们的User对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span>  <span class="comment">// 通知 Dagger 该类应该只构建一次</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Webservice webservice;</span><br><span class="line">    <span class="comment">// 简单缓存在内存中，忽略实现细节</span></span><br><span class="line">    <span class="keyword">private</span> UserCache userCache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        LiveData&lt;User&gt; cached = userCache.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cached;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MutableLiveData&lt;User&gt; data = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line">        userCache.put(userId, data);</span><br><span class="line">        <span class="comment">// 这仍然不是最优的代码，但是要比之前的代码好</span></span><br><span class="line">        <span class="comment">// 一个完整的实现必须处理错误情况</span></span><br><span class="line">        webservice.getUser(userId).enqueue(<span class="keyword">new</span> Callback&lt;User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;User&gt; call, Response&lt;User&gt; response)</span> </span>&#123;</span><br><span class="line">                data.setValue(response.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>在我们当前的实现中，如果用户旋转了屏幕或者离开并返回app，当前UI界面将立刻可见，这是因为仓库从内存中获取了数据。但是如果用户离开app很久，在Android系统杀掉进程后再回来呢？</p><p>在当前的实现中，我们需要从网络重新获取数据。这并不仅是一个很糟糕的用户习惯，并且很浪费，因为我们要重新获取相同的数据。你可以仅仅通过缓存网络请求来修复它，但是这也创造了新的问题。如果相同的数据类型在另一个请求中发生（如获取一组好友列表）呢？如果是这样，你的app可能会显示不正确的数据。</p><p>正确解决这个问题的关键在于使用一个持久化模型。这正是<code>Room</code>持久化类库所解决的问题。</p><p><code>Room</code>是一个以最小化模板代码提供本地数据持久化的对象关系映射类库。在编译时间，它会验证每个查询语句，因此错误的SQL会导致编译时报错，而不是在运行时报错。Room抽象了一些原生SQL表和查询的底层实现细节。它也允许观察数据库数据的变化，通过LiveData对象进行展现。此外，它显式地定义线程约束以解决一些常见的问题，如在主线程访问存储。</p><blockquote><p><strong>注意：</strong>如果你对另一些持久化解决方案很熟悉，你并不需要进行替换，除非Room的功能集和你的用例更符合。</p></blockquote><p>为了使用<code>Room</code>，我们需要定义我们的本地表。首先使用<code>@Entity</code>去注解<code>User</code>类，标记该类作为数据库中的表。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="meta">@PrimaryKey</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="comment">// getters/setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后，通过扩展<code>RoomDatabase</code>类创建一个数据库类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;User.class&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，<code>MyDatabase</code>类是抽象的，<code>Room</code>会自动提供实现。详情请参见Room文档。</p><p>现在我们需要一个方式将用户数据插入到数据库中，为此我们需要创建一个数据访问对象(DAO)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Insert</span>(onConflict = REPLACE)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"SELECT * FROM user WHERE id = :userId"</span>)</span><br><span class="line">    <span class="function">LiveData&lt;User&gt; <span class="title">load</span><span class="params">(String userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后，从我们的数据库类中引用DAO：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Database</span>(entities = &#123;User.class&#125;, version = <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabase</span> <span class="keyword">extends</span> <span class="title">RoomDatabase</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请注意<code>load</code>方法返回了一个<code>LiveData&lt;User&gt;</code>。<code>Room</code>知道数据库什么时候被修改并将在数据变化时自动通知所有已激活的观察者。使用了LiveData是很高效的，因为只有在至少含有一个处在激活状态的观察者时才会更新。</p><blockquote><p><strong>注意：</strong>Room会检查基于表修改的错误信息，也就是说会分发假阳性的通知。假阳性是指分发的通知是正确的，但是并非是由数据变化所造成的。</p></blockquote><p>现在我们修改UserRepository类，将Room数据源包含在内。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Webservice webservice;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserRepository</span><span class="params">(Webservice webservice, UserDao userDao, Executor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webservice = webservice;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiveData&lt;User&gt; <span class="title">getUser</span><span class="params">(String userId)</span> </span>&#123;</span><br><span class="line">        refreshUser(userId);</span><br><span class="line">        <span class="comment">//直接从数据库返回数据</span></span><br><span class="line">        <span class="keyword">return</span> userDao.load(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">refreshUser</span><span class="params">(<span class="keyword">final</span> String userId)</span> </span>&#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 运行在后台线程</span></span><br><span class="line">            <span class="comment">// 检查用户最新是否获取更新</span></span><br><span class="line">            <span class="keyword">boolean</span> userExists = userDao.hasUser(FRESH_TIMEOUT);</span><br><span class="line">            <span class="keyword">if</span> (!userExists) &#123;</span><br><span class="line">                <span class="comment">// 刷新数据</span></span><br><span class="line">                Response response = webservice.getUser(userId).execute();</span><br><span class="line">                <span class="comment">// TODO 错误情况监测处理（省略）</span></span><br><span class="line">                <span class="comment">// 更新数据库，LiveData会自动更新，因此只需要更新数据库就可以了</span></span><br><span class="line">                userDao.save(response.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请注意，即使我们在<code>UserRepository</code>中改变了数据源，我们仍然不需要改变<code>UserProfileViewModel</code>或者<code>UserProfileFragment</code>。这种灵活性是由抽象所提供的。这对于测试来说也是很棒的，因为你可以在测试<code>UserProfileViewModel</code>的时候提供一个假的<code>UserRepository</code> 。</p><p>现在我们的代码完成了。如果用户稍后再次回到相同的UI，将会立即看到用户信息，因为我们进行了持久化。同时，如果数据过时了，我们的仓库会在后台更新数据它们。当然这取决于你的具体用例，你可以选择在数据过时的时候不显示它们。</p><p>在一些用例中，例如pull-to-refresh，对于UI来说如果当前在进行网络请求，对用户显示该进度是很重要的。将UI的行为和实际数据分离是一种很好的实践，因为数据可能因为多种原因被更新（例如如果我们拉取一组朋友列表，已存在的数据可能会被再次获取，从而触发了<code>LiveData&lt;User&gt;</code>更新）。从UI的角度来看，事实上是另一个数据端。</p><p>该用例有两个常见的方案：</p><ul><li>修改<code>getUser()</code>方法，返回带有网络操作状态的LiveData，例如下文中的“显示网络状态”章节。</li><li>在仓库类中提供另一个公共方法，返回User类的刷新状态。这种方式更好，如果你想要仅仅在响应显式地用户操作（如pull-to-refresh）时显示网络状态。</li></ul><h4 id="真正单一数据源"><a href="#真正单一数据源" class="headerlink" title="真正单一数据源"></a>真正单一数据源</h4><p>对于不同的REST API返回相同的数据是很常见的，例如，如果我们的后台有另一个接口用于返回朋友列表，相同的User对象会从两个API返回。如果<code>UserRepository</code>也要去返回<code>Webservice</code>请求的结果，我们的UI界面可能会显示不正常数据，因为数据可能会因这两个请求接口而改变。这也就是为什么在<code>UserRepository</code>实现中，网络服务仅仅存储数据到数据库的原因。之后，数据库信息的改变会触发<code>LiveData</code>的更新。</p><p>在这种模型下，数据库作为单一数据源，而app的其他部分通过仓库进行访问。不论你是否使用持久化存储，我们推荐你的仓库指定一个数据源作为app的单一数据源。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>关注点分离原则一个很重要的受益处在于可测试性。让我们看看每个模块代码的测试。</p><ul><li><strong>UI&amp;交互：</strong>这是唯一需要[Android UI Instrumentation test]的时刻。测试UI的最佳方式是创建一个[Espresso]特使。你可以创建Fragment并提供一个虚拟的ViewModel。因为Fragment仅仅和ViewModel对话，模拟ViewModel对于测试来说就已经足够了。</li><li><strong>ViewModel：</strong>ViewModel可以使用[JUnit测试]。你仅仅需要模拟UserRepository。</li><li><strong>UserRepository：</strong>你也可以使用JUnit测试UserRepository 。你需要模拟Webservice和DAO。你可以测试网络请求调用，在数据库中保存结果，以及如果数据被缓存并更新后不需要进行请求。因为Webservice和UserDao都是接口，你可以模拟它们。</li><li><strong>UserDao：</strong>测试DAO类的推荐方法是使用测试工具。因为这些测试工具并不需要任何的UI并运行速度很快。对每个测试来说，你可以创建一个内存数据库来保证测试并不会造成双边效应（如改变磁盘上数据库的已有数据）。</li><li><strong>WebService：</strong>独立于外部世界的测试是很重要的，甚至你的Webservice测试应该避免调用后台的网络服务。有大量的类库可以帮助做到这一点，例如：[MockWebServer]。</li><li><strong>测试构件：</strong>架构组件提供一个Maven构件来控制后台线程。在android.arch.core:core-testing中，有两个JUnit规则：<ul><li>任务立即执行规则：这个规则可用于强制架构组件在调用线程里立即执行任何后台操作</li><li>这个规则可用于工具测试，以等待架构组件的后台操作或者连接至Espresso作为闲置资源。</li></ul></li></ul><h2 id="最终架构"><a href="#最终架构" class="headerlink" title="最终架构"></a>最终架构</h2><p>下图显示了我们所推荐架构的所有模块，以及相互间的交互情况：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/09/10/architecture-guide/final-architecture.png" alt="t1" title="">                </div>                <div class="image-caption">t1</div>            </figure></p><h1 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h1><hr><p>以下的建议并不是强制性的，而是根据我们的经验得知，遵循这些建议会使你的代码更健壮，易于测试和易于维护。</p><ul><li>你在清单文件中所定义的入口点——Activity，Service，Broadcast Receiver等并不应该是数据源。相反，他们应该仅仅是和入库点相关的数据源子集。因为每个app的组件的存活时间都是短暂的、取决于用户的交互行为以及运行时整体上的健康度。</li><li>残忍坚决地创建良好的模块分界。例如，不要将从网络读取数据的代码扩展到多个类/包中。相似地，也不要将不相关职责的代码添加进来，如数据缓存等。（高内聚，低耦合）</li><li>模块间交互暴露的接口应该尽可能的少。不要尝试创建“仅仅用一次”的捷径，导致暴露一个模块的内部实现细节。你可能在短期会获益，但是在代码的演进过程中会耗费数倍的技术负担。</li><li>当你定义了模块间的交互时，考虑每个模块的单独可测试性。例如，有一个定义良好的用于从网络获取数据的API会更易于测试本地数据库持久化的模块。相反，如果你搞乱了两个模块间的逻辑，或将你网络请求的代码铺满了所有的地方，那么这将很难进行测试。</li><li>你app的核心是如何在其他app中变得突出。不要花费时间重复造轮子或一遍一遍地写相同的模板代码。相反，将你的心思花在如何使你的app独一无二，让Android架构组件以及其他推荐类库处理重复的部分。</li><li>持久化尽可能多和尽可能新鲜的数据，这样在离线模式下你的app也是可用的。你可能很享受高速的网络连接，可你的用户并不一定这样认为。</li><li>你的仓库应当指定单一数据源。当你的app需要访问数据时，应该永远来自于这个单一的数据源。</li></ul><h1 id="附加：显示网络状态"><a href="#附加：显示网络状态" class="headerlink" title="附加：显示网络状态"></a>附加：显示网络状态</h1><hr><p>在“推荐app架构”一节中，我们故意忽略了网络错误和加载状态，以使样例代码更简单。在本节中，我们致力于使用Resource类显示网络状态以及数据本身。</p><p>下面是样例的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个描述数据以及其状态的泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span> <span class="keyword">public</span> <span class="keyword">final</span> Status status;</span><br><span class="line">    <span class="meta">@Nullable</span> <span class="keyword">public</span> <span class="keyword">final</span> T data;</span><br><span class="line">    <span class="meta">@Nullable</span> <span class="keyword">public</span> <span class="keyword">final</span> String message;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Resource</span><span class="params">(@NonNull Status status, @Nullable T data, @Nullable String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Resource&lt;T&gt; <span class="title">success</span><span class="params">(@NonNull T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Resource&lt;&gt;(SUCCESS, data, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Resource&lt;T&gt; <span class="title">error</span><span class="params">(String msg, @Nullable T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Resource&lt;&gt;(ERROR, data, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Resource&lt;T&gt; <span class="title">loading</span><span class="params">(@Nullable T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Resource&lt;&gt;(LOADING, data, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为从网络加载数据并进行显示是一个常见的用例，我们创建了一个帮助类<code>NetworkBoundResource</code>可以在多个地方复用。下图是<code>NetworkBoundResource</code>的决策树：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/09/10/architecture-guide/network-bound-resource.png" alt="t2" title="">                </div>                <div class="image-caption">t2</div>            </figure></p><p>起点从观察数据源（数据库）开始。当入口被数据库第一次加载时，NetworkBoundResource检查结果是否足够良好以至于可以分发，并且/或应该从网络进行获取。注意，这二者可以同时发生，因为你可能想要显示缓存，同时从网络更新数据。</p><p>如果网络调用完全成功，保存结果至数据库并重新初始化数据流。如果网络请求失败，我们直接分发一个错误。</p><blockquote><p>将新的数据存储到磁盘以后，我们从数据库重新初始化数据流，但是通常我们并不需要这样做，因为数据库会分发这次变化。另一方面，依赖数据库去分发变化会是一把双刃剑，如果数据并没有变化，我们实际上可以避免这次分发。我们也不分发网络请求得到的数据，因为这违反了单一数据源的原则。</p></blockquote><p>以下是NetworkBoundResource所提供的API：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResultType: 数据源类型</span></span><br><span class="line"><span class="comment">// RequestType: API返回的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkBoundResource</span>&lt;<span class="title">ResultType</span>, <span class="title">RequestType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 被调用保存API返回的结果至数据库</span></span><br><span class="line">    <span class="meta">@WorkerThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">saveCallResult</span><span class="params">(@NonNull RequestType item)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被调用去判断是否应该从网络获取数据</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">shouldFetch</span><span class="params">(@Nullable ResultType data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被调用从数据库获取缓存数据</span></span><br><span class="line">    <span class="meta">@NonNull</span> <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> LiveData&lt;ResultType&gt; <span class="title">loadFromDb</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被调用创建API请求</span></span><br><span class="line">    <span class="meta">@NonNull</span> <span class="meta">@MainThread</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; createCall();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当获取数据失败时候调用</span></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFetchFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回代表数据源的LiveData</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> LiveData&lt;Resource&lt;ResultType&gt;&gt; getAsLiveData() &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，上面的类定义了两种类型的参数（ResultType和RequestType），因为从API返回的数据类型可能和本地的数据类型并不匹配。</p><p>同样也请注意，上面的代码使用了ApiResponse用于网络请求。ApiResponse 是Retrofit2.Call类的简单包装，用于将返回结果转化为LiveData。</p><p>下面的NetworkBoundResource的其余实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkBoundResource</span>&lt;<span class="title">ResultType</span>, <span class="title">RequestType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MediatorLiveData&lt;Resource&lt;ResultType&gt;&gt; result = <span class="keyword">new</span> MediatorLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    NetworkBoundResource() &#123;</span><br><span class="line">        result.setValue(Resource.loading(<span class="keyword">null</span>));</span><br><span class="line">        LiveData&lt;ResultType&gt; dbSource = loadFromDb();</span><br><span class="line">        result.addSource(dbSource, data -&gt; &#123;</span><br><span class="line">            result.removeSource(dbSource);</span><br><span class="line">            <span class="keyword">if</span> (shouldFetch(data)) &#123;</span><br><span class="line">                fetchFromNetwork(dbSource);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.addSource(dbSource,</span><br><span class="line">                        newData -&gt; result.setValue(Resource.success(newData)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fetchFromNetwork</span><span class="params">(<span class="keyword">final</span> LiveData&lt;ResultType&gt; dbSource)</span> </span>&#123;</span><br><span class="line">        LiveData&lt;ApiResponse&lt;RequestType&gt;&gt; apiResponse = createCall();</span><br><span class="line">        <span class="comment">// 重新连接dbSource作为新的源,</span></span><br><span class="line">        <span class="comment">//这样会快速分发最新的数据</span></span><br><span class="line">        result.addSource(dbSource,</span><br><span class="line">                newData -&gt; result.setValue(Resource.loading(newData)));</span><br><span class="line">        result.addSource(apiResponse, response -&gt; &#123;</span><br><span class="line">            result.removeSource(apiResponse);</span><br><span class="line">            result.removeSource(dbSource);</span><br><span class="line">            <span class="keyword">if</span> (response.isSuccessful()) &#123;</span><br><span class="line">                saveResultAndReInit(response);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                onFetchFailed();</span><br><span class="line">                result.addSource(dbSource,</span><br><span class="line">                        newData -&gt; result.setValue(</span><br><span class="line">                                Resource.error(response.errorMessage, newData)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveResultAndReInit</span><span class="params">(ApiResponse&lt;RequestType&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AsyncTask&lt;Void, Void, Void&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... voids)</span> </span>&#123;</span><br><span class="line">                saveCallResult(response.body);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void aVoid)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 我们专门请求一个新的LiveData</span></span><br><span class="line">                <span class="comment">// 另一方面获取最新的缓存数据，可能并不是网络请求得到的最新数据</span></span><br><span class="line">                result.addSource(loadFromDb(),</span><br><span class="line">                        newData -&gt; result.setValue(Resource.success(newData)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们使用NetworkBoundResource来重写UserRepository：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span>&#123;</span><br><span class="line">    Webservice webservice;</span><br><span class="line">    UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;Resource&lt;User&gt;&gt; loadUser(<span class="keyword">final</span> String userId) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NetworkBoundResource&lt;User,User&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">saveCallResult</span><span class="params">(@NonNull User item)</span> </span>&#123;</span><br><span class="line">                userDao.insert(item);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">shouldFetch</span><span class="params">(@Nullable User data)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> rateLimiter.canFetch(userId) &amp;&amp; (data == <span class="keyword">null</span> || !isFresh(data));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@NonNull</span> <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> LiveData&lt;User&gt; <span class="title">loadFromDb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> userDao.load(userId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@NonNull</span> <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> LiveData&lt;ApiResponse&lt;User&gt;&gt; createCall() &#123;</span><br><span class="line">                <span class="keyword">return</span> webservice.getUser(userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.getAsLiveData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这份文档用于已经掌握构建Android app基本技能，现在想要了解推荐的架构，想要实践如何构建健壮、生产级别app的开发者。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;本文档假设读者已经熟悉Android框架。如果你刚跟接触Andro
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Architecture Components" scheme="http://yoursite.com/tags/Architecture-Components/"/>
    
  </entry>
  
  <entry>
    <title>Android 8.0 功能和 API</title>
    <link href="http://yoursite.com/2017/08/29/android-8-0/"/>
    <id>http://yoursite.com/2017/08/29/android-8-0/</id>
    <published>2017-08-29T11:47:18.000Z</published>
    <updated>2018-04-10T01:32:54.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h1><hr><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p><img src="/2017/08/29/android-8-0/notification-long-press.png" alt="Drawing" style="width: 200px;float:right"><br>在 Android 8.0 中，我们已重新设计通知，以便为管理通知行为和设置提供更轻松和更统一的方式。这些变更包括：<br>-<strong>通知渠道</strong>：Android 8.0 引入了通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。用户界面将通知渠道称之为通知类别。要了解如何实现通知渠道的信息，请参阅<a href="https://developer.android.com/preview/features/notification-channels.html" target="_blank" rel="noopener">通知渠道</a>指南。<br>-<strong>通知标志</strong>：Android 8.0 引入了对在应用启动器图标上显示通知标志的支持。通知标志可反映某个应用是否存在与其关联、并且用户尚未予以清除也未对其采取行动的通知。通知标志也称为通知点。要了解如何调整通知标志，请参阅<a href="https://developer.android.com/preview/features/notification-badges.html" target="_blank" rel="noopener">通知标志</a>指南。<br>-<strong>休眠</strong>：用户可以将通知置于休眠状态，以便稍后重新显示它。重新显示时通知的重要程度与首次显示时相同。应用可以移除或更新已休眠的通知，但更新休眠的通知并不会使其重新显示。<br>-<strong>通知超时</strong>：现在，使用 <code>setTimeoutAfter()</code>创建通知时您可以设置超时。您可以使用此函数指定一个持续时间，超过该持续时间后，通知应取消。如果需要，您可以在指定的超时持续时间之前取消通知。<br>-<strong>通知设置</strong>：当您使用 <code>Notification.INTENT_CATEGORY_NOTIFICATION_PREFERENCESIntent</code> 从通知创建指向应用通知设置的链接时，您可以调用 <code>setSettingsText()</code> 来设置要显示的文本。此系统可以提供以下 <code>Extra</code> 数据和 <code>Intent</code>，用于过滤应用必须向用户显示的设置：<code>EXTRA_CHANNEL_ID</code>、<code>NOTIFICATION_TAG 和 NOTIFICATION_ID</code>。<br>-<strong>通知清除</strong>：系统现在可区分通知是由用户清除，还是由应用移除。要查看清除通知的方式，您应实现 <code>NotificationListenerService</code> 类的新 <code>onNotificationRemoved()</code> 函数。<br>-<strong>背景颜色</strong>：您现在可以设置和启用通知的背景颜色。只能在用户必须一眼就能看到的持续任务的通知中使用此功能。例如，您可以为与驾车路线或正在进行的通话有关的通知设置背景颜色。您还可以使用 <code>Notification.Builder.setColor()</code> 设置所需的背景颜色。这样做将允许您使用 <code>Notification.Builder.setColorized()</code> 启用通知的背景颜色设置。<br>-<strong>消息样式</strong>：现在，使用 <code>MessagingStyle</code> 类的通知可在其折叠形式中显示更多内容。对于与消息有关的通知，您应使用 <code>MessagingStyle</code> 类。您还可以使用新的 <code>addHistoricMessage()</code> 函数，通过向与消息相关的通知添加历史消息为会话提供上下文。</p><h2 id="自动填充框架"><a href="#自动填充框架" class="headerlink" title="自动填充框架"></a>自动填充框架</h2><p>帐号创建、登录和信用卡交易需要时间并且容易出错。在使用要求执行此类重复性任务的应用时，用户很容易遭受挫折。<br>Android 8.0 通过引入自动填充框架，简化了登录和信用卡表单之类表单的填写工作。在用户选择接受自动填充之后，新老应用都可使用自动填充框架。<br>您可以采取某些措施，优化您的应用使用此框架的方式。如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/autofill.html" target="_blank" rel="noopener">自动填充框架概览</a>。</p><h2 id="画中画模式"><a href="#画中画模式" class="headerlink" title="画中画模式"></a>画中画模式</h2><p>Android 8.0 允许以画中画 (PIP) 模式启动操作组件。PIP 是一种特殊的多窗口模式，最常用于视频播放。目前，PIP 模式可用于 Android TV，而 Android 8.0 则让该功能可进一步用于其他 Android 设备。<br>当某个 Activity 处于 PIP 模式时，它会处于暂停状态，但仍应继续显示内容。因此，您应确保您的应用在 <code>onPause()</code> 处理程序中进行处理时不会暂停播放。相反，您应在 onStop() 中暂停播放视频，并在 <code>onStart()</code> 中继续播放。如需了解详细信息，请参阅<a href="https://developer.android.com/guide/topics/ui/multi-window.html#lifecycle" target="_blank" rel="noopener">多窗口生命周期</a>。<br>要指定您的 Activity 可以使用 PIP 模式，请在清单中将 android:supportsPictureInPicture 设置为 true。（从 Android 8.0 开始，如果您打算在 Android TV 或其他 Android 设备上支持 PIP 模式，则无需将 android:resizeableActivity 设置为 true；只有在您的 Activity 支持其他多窗口模式时，才需要设置 android:resizeableActivity。）</p><h2 id="API-变更"><a href="#API-变更" class="headerlink" title="API 变更"></a>API 变更</h2><p>Android 8.0 引入一种新的对象 PictureInPictureParams，您可以将该对象传递给 PIP 函数来指定某个 Activity 在其处于 PIP 模式时的行为。此对象还指定了各种属性，例如操作组件的首选纵横比。</p><p>现在，在添加画中画中介绍的现有 PIP 函数可用于所有 Android 设备，而不仅限于 Android TV。此外，Android 8.0 还提供以下函数来支持 PIP 模式：</p><ul><li><p><strong>Activity.enterPictureInPictureMode(PictureInPictureParams args)</strong>：将操作组件置于画中画模式。操作组件的纵横比和其他配置设置均由 <code>args</code> 指定。如果 <code>args</code> 中的任何字段为空，系统将使用您上次调用 <code>Activity.setPictureInPictureParams()</code> 时所设置的值。<br>指定的操作组件被置于屏幕的一角，屏幕剩余部分则被屏幕显示的上一个操作组件填满。进入 PIP 模式的 Activity 将进入暂停状态，但仍保持已启动状态。如果用户点按此 PIP 操作组件，系统将显示一个菜单供用户操作，而在操作组件处于 PIP 状态期间，不会理会任何触摸事件。</p></li><li><p><strong>Activity.setPictureInPictureParams()</strong>：更新操作组件的 PIP 配置设置。如果操作组件目前处于 PIP 模式，则会更新此设置；如果操作组件的纵横比发生变化，这非常有用。如果操作组件不处于 PIP 模式，则会使用这些配置设置，而不会考虑您调用的 <code>enterPictureInPictureMode()</code> 函数。</p></li></ul><h2 id="可下载字体"><a href="#可下载字体" class="headerlink" title="可下载字体"></a>可下载字体</h2><p>Android 8.0 和 Android 支持库 26 允许您从提供程序应用请求字体，而无需将字体绑定到 APK 中或让 APK 下载字体。此功能可减小 APK 大小，提高应用安装成功率，使多个应用可以共享同一种字体。</p><p>如需了解有关下载字体的详细信息，请参阅 <a href="https://developer.android.com/preview/features/downloadable-fonts.html" target="_blank" rel="noopener">可下载字体</a>。</p><h2 id="XML-中的字体"><a href="#XML-中的字体" class="headerlink" title="XML 中的字体"></a>XML 中的字体</h2><p>Android 8.0 推出一项新功能，即 XML 中的字体，允许您使用字体作为资源。这意味着，不再需要以资产的形式捆绑字体。字体在 R 文件中编译，并且作为一种资源，可自动用于系统。然后，您可以利用一种新的资源类型 font 来访问这些字体。</p><p>在运行 API 版本 14 及更高版本的设备中，支持库 26 对此功能提供完全支持。</p><p>如需了解有关以资源形式使用字体以及检索系统字体有关的详细信息，请参阅 <a href="https://developer.android.com/preview/features/fonts-in-xml.html" target="_blank" rel="noopener">XML 中的字体</a>。</p><h2 id="自动调整-TextView-的大小"><a href="#自动调整-TextView-的大小" class="headerlink" title="自动调整 TextView 的大小"></a>自动调整 TextView 的大小</h2><p>Android 8.0 允许您根据 TextView 的大小自动设置文本展开或收缩的大小。这意味着，在不同屏幕上优化文本大小或者优化包含动态内容的文本大小比以往简单多了。如需了解有关如何在 Android 8.0 中自动调整 TextView 的大小的详细信息，请参阅<a href="https://developer.android.com/preview/features/autosizing-textview.html" target="_blank" rel="noopener">自动调整 TextView 的大小</a>。</p><h2 id="自适应图标"><a href="#自适应图标" class="headerlink" title="自适应图标"></a>自适应图标</h2><p>Android 8.0 引入自适应启动器图标。自适应图标支持视觉效果，可在不同设备型号上显示为各种不同的形状。要了解如何创建自适应图标，请参阅<a href="https://developer.android.com/preview/features/adaptive-icons.html" target="_blank" rel="noopener">自适应图标预览功能指南</a>。</p><h2 id="颜色管理"><a href="#颜色管理" class="headerlink" title="颜色管理"></a>颜色管理</h2><p>图像应用的 Android 开发者现在可以利用支持广色域彩色显示的新设备。要显示广色域图像，应用需要在其清单（每个操作组件）中启用一个标志，并加载具有嵌入的广域彩色配置文件（AdobeRGB、Pro Photo RGB、DCI-P3 等）的位图。</p><h2 id="WebView-API"><a href="#WebView-API" class="headerlink" title="WebView API"></a>WebView API</h2><p>Android 8.0 提供多种 API，帮助您管理在应用中显示网页内容的 <code>WebView</code> 对象。这些 API 可增强应用的稳定性和安全性，它们包括：</p><ul><li>Version API</li><li>Google SafeBrowsing API</li><li>Termination Handle API</li><li>Renderer Importance API<br>要详细了解如何这些 API，请参阅<a href="https://developer.android.com/preview/features/managing-webview.html" target="_blank" rel="noopener">管理 WebView</a>。</li></ul><h2 id="固定快捷方式和小部件"><a href="#固定快捷方式和小部件" class="headerlink" title="固定快捷方式和小部件"></a>固定快捷方式和小部件</h2><p>Android 8.0 引入了快捷方式和微件的应用内固定功能。在您的应用中，您可以根据用户权限为支持的启动器创建固定的快捷方式和小部件。</p><p>如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/pinning-shortcuts-widgets.html" target="_blank" rel="noopener">固定快捷方式和微件</a>预览功能指南。</p><p>##最大屏幕纵横比<br>以 Android 7.1（API 级别 25）或更低版本为目标平台的应用默认的最大屏幕纵横比为 1.86。针对 Android 8.0 或更高版本的应用没有默认的最大纵横比。如果您的应用需要设置最大纵横比，请使用定义您的操作组件的清单文件中的 <code>maxAspectRatio</code> 属性。</p><h2 id="多显示器支持"><a href="#多显示器支持" class="headerlink" title="多显示器支持"></a>多显示器支持</h2><p>从 Android 8.0 开始，此平台为多显示器提供增强的支持。如果 Activity 支持多窗口模式，并且在具有多显示器的设备上运行，则用户可以将 Activity 从一个显示器移动到另一个显示器。当应用启动 Activity 时，此应用可指定 Activity 应在哪个显示器上运行。</p><blockquote><p><strong>注</strong>：如果 Activity 支持多窗口模式，则 Android 8.0 将为该 Activity 自动启用多显示器支持。您应测试您的应用，确保它在多显示器环境下可正常运行。<br>每次只有一个 Activity 可以处于继续状态，即使此应用具有多个显示器。具有焦点的 Activity 将处于继续状态，所有其他可见的 Activity 均暂停，但不会停止。如需了解有关当多个 Activity 可见时活动生命周期的详细信息，请参阅<a href="https://developer.android.com/guide/topics/ui/multi-window.html#lifecycle" target="_blank" rel="noopener">多窗口生命周期</a>。</p></blockquote><p>当用户将 Activity 从一个显示器移动到另一个显示器时，系统将调整 Activity 大小，并根据需要发起运行时变更。您的 Activity 可以自行处理配置变更，或允许系统销毁包含该 Activity 的进程，并以新的尺寸重新创建它。如需了解详细信息，请参阅<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理配置变更</a>。<br><strong>setLaunchDisplayId()</strong><br>&emsp;&emsp;指定 Activity 在启动后应显示在哪个显示器上。<br><strong>getLaunchDisplayId()</strong><br>&emsp;&emsp;返回操作组件的当前启动显示器。<br>对 adb shell 进行了扩展，以支持多个显示器。shell start 命令现在可用于启动操作组件，并指定操作组件的目标显示器：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell start &lt;activity_name&gt; --display &lt;display_id&gt;</span><br></pre></td></tr></table></figure></p><h2 id="统一的布局外边距和内边距"><a href="#统一的布局外边距和内边距" class="headerlink" title="统一的布局外边距和内边距"></a>统一的布局外边距和内边距</h2><p>Android 8.0 让您可以更轻松地指定 View 元素的对边使用相同外边距和内边距的情形。具体来说，您现在可以在布局 XML 文件中使用以下属性：<br>-<strong>layout_marginVertical</strong>，同时定义 <code>layout_marginTop</code> 和 <code>layout_marginBottom</code>。<br>-<strong>layout_marginHorizontal</strong>，同时定义 <code>layout_marginLeft</code> 和 <code>layout_marginRight</code>。<br>-<strong>paddingVertical</strong>，同时定义 <code>paddingTop</code> 和 <code>paddingBottom</code>。<br>-<strong>paddingHorizontal</strong>，同时定义 <code>paddingLeft</code> 和 <code>paddingRight</code>。</p><blockquote><p><strong>注</strong>：如果您自定义应用逻辑以支持不同语言和文化（包括文本方向），请记住，这些属性不会影响 <code>layout_marginStart</code>、<code>layout_marginEnd</code>、<code>paddingStart</code> 或 <code>paddingEnd</code> 的值。您可以自行设置这些值和新的垂直与水平布局属性来创建取决于文本方向的布局行为。</p></blockquote><h2 id="指针捕获"><a href="#指针捕获" class="headerlink" title="指针捕获"></a>指针捕获</h2><p>某些应用（例如游戏、远程桌面和虚拟化客户端）将大大受益于鼠标指针控制。指针捕获是 Android 8.0 中的一项新功能，可以通过将所有鼠标事件传递到您的应用中焦点视图的方式提供此类控制。</p><p>从 Android 8.0 开始，您的应用中的 View 可以请求指针捕获并定义一个侦听器来处理捕获的指针事件。鼠标指针在此模式下将隐藏。如果不再需要鼠标信息，该视图可以释放指针捕获。系统也可以在视图丢失焦点时（例如，当用户打开另一个应用时）释放指针捕获。</p><p>如需了解有关如何在您的应用中使用此功能的信息，请参<a href="https://developer.android.com/preview/features/pointer-capture.html" target="_blank" rel="noopener">阅指针捕获</a>。</p><h2 id="应用类别"><a href="#应用类别" class="headerlink" title="应用类别"></a>应用类别</h2><p>在适当的情况下，Android 8.0 允许每个应用声明其所属的类别。这些类别用于将应用呈现给用户的用途或功能类似的应用归类在一起，例如按流量消耗、电池消耗和存储消耗将应用归类。您可以在 <application> 清单标记中设置 android:appCategory 属性，定义应用的类别。</application></p><h2 id="Android-TV-启动器"><a href="#Android-TV-启动器" class="headerlink" title="Android TV 启动器"></a>Android TV 启动器</h2><p>Android 8.0 添加了一种以内容为中心的全新 Android TV 主屏幕体验，支持 Android TV 模拟器和 Nexus Player Android 8.0 设备映像。新的主屏幕在对应于频道的行中组织视频内容，这些频道在系统上通过应用填充各个节目。应用可以发布多个频道，用户可以配置他们希望在主屏幕上看到哪些频道。Android TV 也包含一个 Watch Next 行，此行根据用户的观看习惯从应用填充节目。应用也可以提供视频预览，这些预览会在用户聚焦到节目时自动播放。用于填充频道和节目的 API 属于 TvProvider API，这些 API 以 Android 支持库模块的形式随 Android 8.0 分发。</p><h2 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h2><p>从 Android 8.0 开始，AnimatorSet API 现在支持寻道和倒播功能。寻道功能允许您将动画的位置设置为指定的时间点处。如果您的应用包含可撤消的操作的动画，倒播功能会很有用。现在，您不必定义两组独立的动画，而只需反向播放同一组动画。</p><h2 id="输入和导航"><a href="#输入和导航" class="headerlink" title="输入和导航"></a>输入和导航</h2><h3 id="键盘导航键区"><a href="#键盘导航键区" class="headerlink" title="键盘导航键区"></a>键盘导航键区</h3><p>如果您的应用中，某个操作组件使用一种复杂的视图层次结构，可考虑将多组界面元素组成一个键区，简化键盘导航这些元素的操作。用户可以在 Chromebook 设备上按 Meta+Tab 或 Search+Tab，在不同键区之间导航。键区的一些范例包括：侧面板、导航栏、主内容区域和可能包含多个子元素的元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/08/29/android-8-0/keyboard-navigation-clusters.png" alt="包含 5 个键区的操作组件" title="">                </div>                <div class="image-caption">包含 5 个键区的操作组件</div>            </figure><br>要将一个 <code>View</code> 或 <code>ViewGroup</code> 元素设置为一个键区，请在元素的布局 XML 文件中将 <code>android:keyboardNavigationCluster</code> 属性设置为 true，或者将 true 传递至应用界面逻辑中的 <code>setKeyboardNavigationCluster()</code>。</p><blockquote><p><strong>注</strong>：键区不能嵌套，不过，非嵌套键区可以显示在层次结构的不同层级。如果您尝试嵌套键区，框架仅会将最顶层的 ViewGroup 元素视为键区。</p></blockquote><p>在具有触摸屏的设备中，您可以将某个键区指定的 ViewGroup 对象的 <code>android:touchscreenBlocksFocus</code> 元素设置为 true，仅允许从键区导航进入和离开此键区。如果您将此配置应用于某个键区，用户将无法使用 Tab 键或箭头键导航进入或离开此键区，而是必须按键区导航键盘组合键</p><h3 id="视图默认焦点"><a href="#视图默认焦点" class="headerlink" title="视图默认焦点"></a>视图默认焦点</h3><p>在 Android 8.0 中，您可以指定在（重新）创建的操作组件继续运行并且用户按下键盘导航键（例如 Tab 键）之后应接收焦点的 View。要应用“设为默认焦点”设置，请在包含界面元素的布局 XML 文件中将 View 元素的 <code>android:focusedByDefault</code> 属性设置为 true，或者将 true 传递至应用界面逻辑中的 <code>setFocusedByDefault()</code>。</p><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><hr><h2 id="新的-StrictMode-检测程序"><a href="#新的-StrictMode-检测程序" class="headerlink" title="新的 StrictMode 检测程序"></a>新的 StrictMode 检测程序</h2><p>Android 8.0 添加了三个新的 StrictMode 检测程序，帮助识别应用可能出现的错误：</p><ul><li><code>detectUnbufferedIo()</code> 将检测您的应用何时读取或写入未缓冲的数据，这可能极大影响性能。</li><li><code>detectContentUriWithoutPermission()</code> 将检测您的应用在其外部启动 Activity 时何时意外忘记向其他应用授予权限。</li><li><code>detectUntaggedSockets()</code> 将检测您的应用何时使用网络流量，而不使用 setThreadStatsTag(int) 将流量标记用于调试目的。</li></ul><h2 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h2><p>Android 8.0 优化了缓存数据的导航和行为。现在，每个应用均获得一定的磁盘空间配额，用于存储 <code>getCacheQuotaBytes(UUID)</code> 返回的缓存数据。</p><p>当系统需要释放磁盘空间时，将开始从超过配额最多的应用中删除缓存文件。因此，如果将您的缓存数据量始终保持低于配额的水平，则在必须清除系统中的某些文件时，您的缓存文件将能坚持到最后。系统在决定删除您的应用中的哪些缓存文件时，将首先考虑删除最旧的文件（由修改时间确定）。</p><p>您还可以针对每个目录启用两种新行为，以控制系统如何释放缓存数据：</p><ul><li><strong>StorageManager.setCacheBehaviorAtomic()</strong> 可用于指示某个目录及其所有内容应作为一个不可分割的整体进行删除。</li><li><strong>setCacheBehaviorTombstone(File, boolean)</strong> 可用于指示不应删除某个目录内的文件，而应将它们截断到 0 字节长度，使空文件保持完好。</li></ul><p>最后，在需要为大文件分配磁盘空间时，可考虑使用新的 <code>allocateBytes(FileDescriptor, long)</code> API，它将自动清除属于其他应用的缓存文件（根据需要），以满足您的请求。在确定设备是否有足够的磁盘空间保存您的新数据时，请调用 <code>getAllocatableBytes(UUID)</code> 而不要使用 <code>getUsableSpace()</code>，因为前者会考虑系统要为您清除的任何缓存数据。</p><h2 id="内容提供程序分页"><a href="#内容提供程序分页" class="headerlink" title="内容提供程序分页"></a>内容提供程序分页</h2><p>我们已更新内容提供程序以支持加载大型数据集，每次加载一页。例如，一个具有大量图像的照片应用可查询要在页面中显示的数据的子集。内容提供程序返回的每个结果页面由一个 Cursor 对象表示。客户端和提供程序必须实现分页才能利用此功能。</p><p>如需了解有关内容提供程序变更的详细信息，请参阅<a href="https://developer.android.com/reference/android/content/ContentProvider.html" target="_blank" rel="noopener">ContentProvider</a>和<a href="https://developer.android.com/reference/android/content/ContentProviderClient.html" target="_blank" rel="noopener">ContentProviderClient</a>。</p><h2 id="内容刷新请求"><a href="#内容刷新请求" class="headerlink" title="内容刷新请求"></a>内容刷新请求</h2><p>现在，<strong>ContentProvider</strong> 和 <strong>ContentResolver</strong> 类均包含 <code>refresh()</code> 函数，这样，客户端可以更轻松地知道所请求的信息是否为最新信息。</p><p>您可以扩展 <strong>ContentProvider</strong> 以添加自定义的内容刷新逻辑。请务必重写 <code>refresh()</code>函数，以返回 true，告知提供程序的客户端您已尝试自行刷新数据。</p><p>您的客户端应用可通过调用另一个函数（又称 refresh()），显式请求已刷新的内容。在调用此函数时，传入待刷新数据的 URI。</p><blockquote><p><strong>注：</strong>由于您可能通过网络不断请求数据，您应仅在有明显迹象表明内容确已过时时才从客户端调用 refresh()。执行此类内容刷新最常见的原因是响应滑动刷新手势，该手势显式请求当前界面显示最新内容。</p></blockquote><h2 id="JobScheduler-改进"><a href="#JobScheduler-改进" class="headerlink" title="JobScheduler 改进"></a>JobScheduler 改进</h2><p>Android 8.0 引入了对 <strong>JobScheduler</strong> 的多项改进。由于您通常可以使用计划作业替代现在受限的后台服务或隐式广播接收器，这些改进可以让您的应用更轻松地符合新的后台执行限制。</p><p><strong>JobScheduler</strong> 的更新包括：</p><ul><li>您现在可以将工作队列与计划作业关联。要将一个工作项添加到作业的队列中，请调用 JobScheduler.enqueue()。当作业运行时，它可以将待定工作从队列中剥离并进行处理。这种功能可以处理之前需要启动后台服务（尤其是实现 IntentService 的服务）的许多用例。</li><li>您现在可以通过调用 JobInfo.Builder.setClipData() 的方式将 ClipData 与作业关联。利用此选项，您可以将 URI 权限授予与作业关联，类似于这些权限传递到 Context.startService() 的方式。您也可以将 URI 权限授予用于工作队列上的 intent。</li><li>计划作业现在支持多个新的约束条件：<br><code>JobInfo.isRequireStorageNotLow()</code><br>&emsp;&emsp;如果设备的可用存储空间非常低，作业将不会运行。<br><code>JobInfo.isRequireBatteryNotLow()</code><br>&emsp;&emsp;如果电池电量等于或低于临界阈值，作业将不会运行；临界阈值是指设备显示 Low battery warning 系统对话框的电量。<br><code>NETWORK_TYPE_METERED</code><br>&emsp;&emsp;作业需要一个按流量计费的网络连接，比如大多数移动数据网络数据套餐。</li></ul><h2 id="自定义数据存储"><a href="#自定义数据存储" class="headerlink" title="自定义数据存储"></a>自定义数据存储</h2><p>Android 8.0 允许您为首选项提供自定义数据存储，如果您的应用将首选项存储在云或本地数据库中，或者如果首选项特定于某个设备，此功能会非常有用。如需了解有关实现数据存储的详细信息，请参阅<a href="https://developer.android.com/preview/features/custom-data-store.html" target="_blank" rel="noopener">自定义数据存储</a>。</p><h2 id="findViewById-签名变更"><a href="#findViewById-签名变更" class="headerlink" title="findViewById() 签名变更"></a>findViewById() 签名变更</h2><p>现在，findViewById() 函数的全部实例均返回 <code>&lt;T extends View&gt;</code> T，而不是 View。此变更会带来以下影响：</p><ul><li>例如，如果 <code>someMethod(View)</code> 和 <code>someMethod(TextView)</code> 均接受调用 <code>findViewById()</code> 的结果，这可能导致现有代码的返回类型不确定。</li><li>在使用 Java 8 源语言时，这需要在返回类型不受限制时（例如，<code>assertNotNull(findViewById(...)).someViewMethod())</code>）显式转换为 View。</li><li>重写非最终的 <code>findViewById()</code> 函数（例如，Activity.findViewById()）将需要更新其返回类型。</li></ul><h1 id="媒体增强功能"><a href="#媒体增强功能" class="headerlink" title="媒体增强功能"></a>媒体增强功能</h1><hr><p><a href="https://developer.android.com/guide/topics/providers/document-provider.html" target="_blank" rel="noopener">存储访问框架 (SAF)</a> 允许应用显示自定义 <strong>DocumentsProvider</strong>，后者可以为其他应用提供访问数据源中的文件的权限。事实上，文档提供程序甚至可以提供驻留在网络存储区或使用<a href="https://en.wikipedia.org/wiki/Media_Transfer_Protocol" target="_blank" rel="noopener">媒体传输协议 (MTP) </a>等协议的文件的访问权限。</p><p>但是，访问远程数据源中的大媒体文件面临一些挑战：</p><ul><li>媒体播放器需要以寻址方式访问来自文档提供程序的文件。当大媒体文件驻留在远程数据源上时，文档提供程序必须事先提取所有数据，并创建快照文件描述符。媒体播放器无法播放没有文件描述符的文件，因此在文档提供程序完成文件下载前，无法开始播放。</li><li>照片应用等媒体集合管理器必须通过作用域文件夹遍历一系列访问 URI 才能访问存储在外部 SD 卡上的媒体。这种访问模式会让媒体上的批量操作（例如移动、复制和删除）变得非常缓慢。</li><li>媒体集合管理器无法根据文档的 URI 确定其位置。这就让这些类型的应用难以允许用户选择媒体文件的保存位置。<br>Android 8.0 通过改进存储访问框架解决了各个挑战。</li></ul><h3 id="自定义文档提供程序"><a href="#自定义文档提供程序" class="headerlink" title="自定义文档提供程序"></a>自定义文档提供程序</h3><p>从 Android 8.0 开始，存储访问框架允许自定义<a href="https://developer.android.com/guide/topics/providers/create-document-provider.html" target="_blank" rel="noopener">文档提供程序</a>为驻留在远程数据源中的文件创建可寻址的文件描述符。SAF 可打开文件，获取原生可寻址的文件描述符。然后 SAF 向文档提供程序提交离散字节请求。此功能使文档提供程序可以返回媒体播放器应用请求的准确字节范围，而不必事先缓存整个文件。</p><p>要使用此功能，您需要调用新的 <code>StorageManager.openProxyFileDescriptor()</code> 函数。<code>openProxyFileDescriptor()</code> 函数可接受 <strong>ProxyFileDescriptorCallback</strong> 对象作为回调。任何时候，当客户端应用对文档提供程序返回的文件描述符执行文件操作时，SAF 都会调用回调。</p><h3 id="直接文档访问"><a href="#直接文档访问" class="headerlink" title="直接文档访问"></a>直接文档访问</h3><p>从 Android 8.0 开始，您可以使用 <code>getDocumentUri()</code> 函数获得与给定 mediaUri 引用相同文档的 URI。不过，由于返回的 URI 由 <strong>DocumentsProvider</strong> 提供支持，媒体集合管理器可以直接访问文档，不用遍历作用域目录树。因此，媒体管理器能够以明显加快的速度对文档执行文件操作。</p><blockquote><p><strong>注意：</strong><code>getDocumentUri()</code> 函数仅可以定位媒体文件；无法授予应用访问这些文件的权限。要详细了解如何获取媒体文件的访问权限，请参阅参考文档。</p></blockquote><h3 id="文档路径"><a href="#文档路径" class="headerlink" title="文档路径"></a>文档路径</h3><p>在 Android 8.0 中使用存储访问框架时，您可以根据文档的 ID，使用 <code>findDocumentPath()</code> 函数（存在于 <strong>DocumentsContract</strong> 和 <strong>DocumentsProvider</strong> 类中）从文件系统的根目录中确定路径。该函数将在 DocumentsContract.Path 对象中返回此路径。如果文件系统对相同文档有多个定义的路径，该函数将返回访问具有给定 ID 的文档时最常使用的路径。</p><p>此功能在下列情况下特别有用：</p><ul><li>您的应用使用可以显示特定文档位置的“另存为”对话框。</li><li>您的应用在搜索结果视图中显示文件夹并且如果用户选择某个文件夹，应用必须加载此特定文件夹内的子文档。<blockquote><p><strong>注：</strong>如果您的应用仅具有路径中某些文档的访问权限，那么 <code>findDocumentPath()</code> 的返回值将仅包含您的应用可以访问的文件夹和文档。</p></blockquote></li></ul><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><hr><h2 id="WLAN-感知"><a href="#WLAN-感知" class="headerlink" title="WLAN 感知"></a>WLAN 感知</h2><p>Android 8.0 新增了对 WLAN 感知的支持，此技术基于周边感知联网 (NAN) 规范。在具有相应 WLAN 感知硬件的设备上，应用和附近设备可以通过 WLAN 进行搜索和通信，无需依赖互联网接入点。我们正在与硬件合作伙伴合作，以尽快将 WLAN 感知技术应用于设备。要了解有关如何将 WLAN 感知集成到您的应用中的信息，请参阅 <a href="https://developer.android.com/preview/features/wifi-aware.html" target="_blank" rel="noopener">WLAN 感知</a>。</p><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>Android 8.0 通过增加以下功能，增强了平台对蓝牙的支持：</p><ul><li>支持 AVRCP 1.4 标准，该标准支持音乐库浏览。</li><li>支持蓝牙低功耗 (BLE) 5.0 标准。</li><li>将 Sony LDAC 编解码器集成到蓝牙堆叠中。</li></ul><h2 id="配套设备配对"><a href="#配套设备配对" class="headerlink" title="配套设备配对"></a>配套设备配对</h2><p>在尝试通过蓝牙、BLE 和 WLAN 与配套设备配对时，Android 8.0 提供的 API 允许您自定义配对请求对话框。如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/companion-device-pairing.html" target="_blank" rel="noopener">配套设备配对</a>。</p><p>如需了解有关在 Android 上使用<a href="https://developer.android.com/guide/topics/connectivity/bluetooth.html" target="_blank" rel="noopener">蓝牙</a>的详细信息，请参阅蓝牙指南。有关对蓝牙所作的特定于 Android 8.0 的变更，请参阅 <a href="https://developer.android.com/preview/behavior-changes.html" target="_blank" rel="noopener">Android 8.0 行为变更</a>页面的<a href="https://developer.android.com/preview/behavior-changes.html#bt" target="_blank" rel="noopener">蓝牙</a>部分。</p><h1 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h1><hr><h2 id="智能共享"><a href="#智能共享" class="headerlink" title="智能共享"></a>智能共享</h2><p>Android 8.0 了解用户的个性化分享首选项，在通过哪些应用分享各个类型的内容方面，也有着更好的把握。例如，如果用户为一张收据拍照，Android 8.0 可以建议费用跟踪应用；如果用户自拍，一款社交媒体应用可以更好地处理图像。Android 8.0 可以根据用户的个性化首选项自动学习所有这些模式。</p><p>智能分享适用于 image 之外的内容类型，例如 <strong>audio</strong>、<strong>video</strong>、<strong>text</strong> 和 <strong>URL</strong> 等。</p><p>要启用智能分享，请将具有最多三个字符串注释的 <strong>ArrayList</strong> 添加到分享内容的 intent。这些注释应说明内容中的主要部分或主题。下面的代码示例显示了如何向 intent 添加注释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; annotations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">annotations.add(<span class="string">"topic1"</span>);</span><br><span class="line">annotations.add(<span class="string">"topic2"</span>);</span><br><span class="line">annotations.add(<span class="string">"topic3"</span>);</span><br><span class="line"></span><br><span class="line">intent.putStringArrayListExtra(</span><br><span class="line">    Intent.EXTRA_CONTENT_ANNOTATIONS,</span><br><span class="line">    annotations</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>如需了解有关智能分享注释的详细信息，请参阅 <code>EXTRA_CONTENT_ANNOTATIONS</code>。</p><h2 id="智能文本选择"><a href="#智能文本选择" class="headerlink" title="智能文本选择"></a>智能文本选择</h2><p>在兼容设备上，Android 8.0 让应用可以帮助用户以更有意义的方式与文本交互。当用户长按某个实体中可识别格式的单词（例如某个地址或餐馆名称）时，系统会选中整个实体。用户会看到一个浮动工具栏，该工具栏包含可以处理所选文本实体的应用。例如，如果系统识别出某个地址，它可以将用户导向地图应用。</p><p>系统识别的实体包括地址、网址、电话号码和电子邮件地址。如需了解详细信息，请参阅 <strong>TextClassifier</strong>。</p><h1 id="无障碍功能"><a href="#无障碍功能" class="headerlink" title="无障碍功能"></a>无障碍功能</h1><hr><p>Android 8.0 支持开发者使用以下无障碍功能创建自己的无障碍服务。如需了解有关如何让您的应用更便于访问的更多信息，请参阅<a href="https://developer.android.com/guide/topics/ui/accessibility/index.html" target="_blank" rel="noopener">无障碍功能</a>。</p><h2 id="无障碍功能按钮"><a href="#无障碍功能按钮" class="headerlink" title="无障碍功能按钮"></a>无障碍功能按钮</h2><p>您的无障碍服务现在可以请求在系统的导航区域显示无障碍功能按钮，该按钮让用户可从其设备上的任意位置快速激活您的服务功能。要执行此操作，请在某个 <strong>AccessibilityServiceInfo</strong> 对象的 <strong>android:accessibilityFlags</strong> 属性中添加 <strong>FLAG_REQUEST_ACCESSIBILITY_BUTTON</strong> 标志。稍后，您可以使用 <code>registerAccessibilityButtonCallback()</code> 注册回调。</p><blockquote><p><strong>注：</strong>此功能仅适用于提供软件渲染导航区域的设备。请始终使用 <code>isAccessibilityButtonAvailable()</code>，并通过实现 <code>onAvailabilityChanged()</code> 根据无障碍功能按钮的可用性来响应变更。通过该方式，用户可以始终访问您的服务功能，即使该无障碍功能按钮不受支持或变得不可用。</p></blockquote><h2 id="独立的音量调整"><a href="#独立的音量调整" class="headerlink" title="独立的音量调整"></a>独立的音量调整</h2><p>Android 8.0 引入了 <strong>STREAM_ACCESSIBILITY</strong> 音量类别，允许您单独控制无障碍服务音频输出的音量，而不会影响设备上的其他声音。</p><p>要使用这个新的流类型来控制无障碍服务音量，请在无障碍服务中设置 <strong>FLAG_ENABLE_ACCESSIBILITY_VOLUME</strong> 选项。然后，您可以使用 <code>adjustStreamVolume()</code> 更改设备的无障碍服务音频音量。</p><h2 id="指纹手势"><a href="#指纹手势" class="headerlink" title="指纹手势"></a>指纹手势</h2><p>您的无障碍服务也可以响应替代的输入机制，即沿设备的指纹传感器按特定方向滑动（上、下、左和右）。要接收有关这些交互的回调，请完成以下一系列步骤：</p><ol><li>声明 <strong>USE_FINGERPRINT </strong>权限和 <strong>CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES</strong> 功能。</li><li>在 <strong>android:accessibilityFlags</strong> 属性中设置 <strong>FLAG_REQUEST_FINGERPRINT_GESTURES</strong> 标志。</li><li>使用 <code>registerFingerprintGestureCallback()</code> 注册回调。</li></ol><p>请记住，并非所有设备都包含指纹传感器。您可以使用 <code>isHardwareDetected()</code> 函数识别设备是否支持此传感器。即使对于包含指纹传感器的设备，您的服务也只有在指纹传感器不用于身份验证目的时才可使用它。要识别此传感器何时可用，请调用 <code>isGestureDetectionAvailable()</code> 函数并实现 <code>onGestureDetectionAvailabilityChanged()</code> 回调。</p><h2 id="字词级突出显示"><a href="#字词级突出显示" class="headerlink" title="字词级突出显示"></a>字词级突出显示</h2><p>要确定 <strong>TextView</strong> 对象中可见字符的位置，您可以在 <strong>EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY</strong> 中将其作为第一个参数传递到 <code>refreshWithExtraData()</code> 中。随后会更新您为 <code>refreshWithExtraData()</code> 提供的作为第二个参数的 <strong>Bundle</strong> 对象，使之包含一个可打包的 <strong>Rect</strong> 对象数组。每个 <strong>Rect</strong> 对象代表某个特定字符的边界框。</p><p>如果您的服务使用 <strong>TextToSpeech</strong> 对象朗读屏幕上出现的内容，您可以获取有关文本到语音转换引擎何时开始朗读单个合成字词时的准确时间信息，前提是文本到语音转换引擎提供此信息。当引擎即将开始播放特定范围文本的音频时，Text-to-Speech API 会通知您的服务，将使用 <code>onRangeStart()</code> 函数开始朗读此范围的文本。</p><p>如果您创建自己的 <strong>TextToSpeechService</strong> 实现，您可以使用 <code>rangeStart()</code> 函数支持这一新功能。</p><h2 id="标准化单端范围值"><a href="#标准化单端范围值" class="headerlink" title="标准化单端范围值"></a>标准化单端范围值</h2><p><strong>AccessibilityNodeInfo</strong> 的一些实例使用 <code>AccessibilityNodeInfo.RangeInfo</code> 的某个实例来表明界面元素可接受一定范围的值。使用 <code>RangeInfo.obtain()</code> 创建范围或使用 <code>getMin()</code> 和 <code>getMax()</code> 检索此范围的极值时，请注意，Android 8.0 规定了标准化单端范围：</p><ul><li>对于没有最小值的范围，<strong>Float.NEGATIVE_INFINITY</strong> 表示最小值。</li><li>对于没有最大值的范围，<strong>Float.POSITIVE_INFINITY</strong> 表示最大值。</li></ul><h2 id="提示文本"><a href="#提示文本" class="headerlink" title="提示文本"></a>提示文本</h2><p>Android 8.0 包含可用于与文本可编辑对象的提示文本进行交互的多个函数：</p><ul><li><code>isShowingHintText()</code> 和 <code>setShowingHintText()</code> 函数分别显示和设置节点的当前文本内容是否表示节点的提示文本。如果节点不包含可编辑文本，则它不应包含提示文本。</li><li>要访问提示文本本身，请使用 <code>getHintText()</code>。即使某个对象当前未显示提示文本，系统也能成功调用 <code>getHintText()</code>。</li></ul><h2 id="连续的手势分派"><a href="#连续的手势分派" class="headerlink" title="连续的手势分派"></a>连续的手势分派</h2><p>您的服务现在可以使用 <code>GestureDescription.StrokeDescription</code> 构造函数中的最后一个参数 <strong>willContinue</strong>，指定属于同一设定手势的笔划的顺序。</p><h1 id="安全性与隐私"><a href="#安全性与隐私" class="headerlink" title="安全性与隐私"></a>安全性与隐私</h1><hr><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>Android 8.0 引入了多个与电话有关的新权限：</p><ul><li><strong>ANSWER_PHONE_CALLS</strong> 允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用 <code>acceptRingingCall()</code> 函数。</li><li><strong>READ_PHONE_NUMBERS</strong> 权限允许您的应用读取设备中存储的电话号码。<br>这些权限均被划分为<strong>危险</strong>类别，属于 <strong>PHONE</strong> 权限组。</li></ul><p>##新的帐号访问和 Discovery API<br>Android 8.0 对应用访问用户帐号的方式引入多项改进。对于由身份验证器管理的帐号，身份验证器在决定对应用隐藏帐号还是显示帐号时可以使用自己的策略。Android 系统跟踪可以访问特定帐号的应用。</p><p>在以前的 Android 版本中，想要跟踪用户帐号列表的应用必须获取有关所有帐号的更新，包括具有不相关类型的帐号。Android 8.0 添加了 addOnAccountsUpdatedListener(android.accounts.OnAccountsUpdateListener, android.os.Handler, boolean, java.lang.String[]) 函数，其允许应用指定应接收帐号变更的帐号类型列表。</p><h3 id="API-变更-1"><a href="#API-变更-1" class="headerlink" title="API 变更"></a>API 变更</h3><p>AccountManager 提供六个新函数以帮助身份验证器管理哪些应用可以查看某个帐号：</p><ul><li><code>setAccountVisibility(android.accounts.Account, java.lang.String, int)</code>：针对特定用户帐号和软件包组合设置可见性级别。</li><li><code>getAccountVisibility(android.accounts.Account, java.lang.String)</code>：获取特定用户帐号和软件包组合的可见性级别。</li><li><code>getAccountsAndVisibilityForPackage(java.lang.String, java.lang.String)</code>：允许身份验证器获取帐号和给定软件包的可见性级别。</li><li><code>getPackagesAndVisibilityForAccount(android.accounts.Account)</code>：允许身份验证器获取存储的给定帐号的可见性值。</li><li><code>addAccountExplicitly(android.accounts.Account, java.lang.String, android.os.Bundle, java.util.Map&lt;java.lang.String, java.lang.Integer&gt;)</code>：允许身份验证器初始化帐号的可见性值。</li><li><code>addOnAccountsUpdatedListener(android.accounts.OnAccountsUpdateListener, android.os.Handler, boolean, java.lang.String[])</code>：将 <strong>OnAccountsUpdateListener</strong> 侦听器添加到 <strong>AccountManager</strong> 对象。无论设备上的帐号列表何时发生变化，系统都将调用此侦听器。</li></ul><p>Android 8.0 引入两个特殊的软件包名称值，以使用 <code>setAccountVisibility(android.accounts.Account, java.lang.String, int)</code> 函数指定未设置的应用的可见性级别。<strong>PACKAGE_NAME_KEY_LEGACY_VISIBLE</strong> 可见性值应用于具有 <strong>GET_ACCOUNTS</strong> 权限的应用，并且其目标 Android 版本低于 Android 8.0，或其签名与针对任意 Android 版本的身份验证器匹配。<strong>PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE</strong> 为之前未设置的应用提供默认的可见性值，对于此类应用，<strong>PACKAGE_NAME_KEY_LEGACY_VISIBLE</strong> 不适用。</p><p>如需了解有关新的帐号访问和发现 API 的详细信息，请参阅 <strong>AccountManager</strong> 和 <strong>OnAccountsUpdateListener</strong> 参考。</p><p>##Google Safe Browsing API<br>WebView 类现在添加了一个 Safe Browsing API 来增强网络浏览的安全性。如需了解详细信息，请参阅 <a href="https://developer.android.com/preview/features/managing-webview.html#safe-browsing" target="_blank" rel="noopener">Google Safe Browsing API</a>。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="仪器测试"><a href="#仪器测试" class="headerlink" title="仪器测试"></a>仪器测试</h2><p>Android 8.0 为应用的仪器测试提供以下几项额外支持。</p><h3 id="针对非默认应用进程运行"><a href="#针对非默认应用进程运行" class="headerlink" title="针对非默认应用进程运行"></a>针对非默认应用进程运行</h3><p>现在，您可以指定针对您的应用的默认进程以外的进程运行特定仪器测试。如果您的应用包含多个在不同进程中运行的操作组件，此配置非常有用。</p><p>要定义非默认进程仪器测试，请导航至您的清单文件，然后导航至所需的 <code>&lt;instrumentation&gt;</code> 元素。添加 <code>android:targetProcess</code> 属性，并将它的值设置为以下值之一：</p><ul><li>特定进程的名称。</li><li>以逗号分隔的进程名称列表。</li><li>通配符（”*”），允许针对任何执行 <strong>android:targetPackage</strong> 属性中指定的软件包中的代码的已启动进程运行仪器测试。<br>在执行仪器测试时，您可以通过调用 <code>getProcessName()</code> 检查正在测试哪个进程。</li></ul><h3 id="在测试过程中报告结果"><a href="#在测试过程中报告结果" class="headerlink" title="在测试过程中报告结果"></a>在测试过程中报告结果</h3><p>现在，通过调用 <code>addResults()</code>，您可以在执行仪器测试时（而不用等到测试后）报告结果。</p><h2 id="用于测试的模拟-Intent"><a href="#用于测试的模拟-Intent" class="headerlink" title="用于测试的模拟 Intent"></a>用于测试的模拟 Intent</h2><p>为了更轻松地为您应用的操作组件创建隔离、独立的界面测试，Android 8.0 引入了 <code>onStartActivity()</code> 函数。要处理您的测试类调用的特定 intent，您可以在 <code>nstrumentation.ActivityMonitor</code> 类的自定义子类中替换此函数。</p><p>当您的测试类调用 intent 时，该函数将返回一个存根 <code>Instrumentation.ActivityResult</code> 对象，而不是执行 intent 本身。通过在您的测试中使用这种模拟 intent 逻辑，您可以侧重于自己的操作组件如何准备和处理您传递到不同操作组件或完全不同的应用中的 intent。</p><h1 id="运行时和工具"><a href="#运行时和工具" class="headerlink" title="运行时和工具"></a>运行时和工具</h1><hr><h2 id="平台优化"><a href="#平台优化" class="headerlink" title="平台优化"></a>平台优化</h2><p>Android 8.0 为平台引入了运行时优化和其他优化，这些优化将带来多项性能改进。这些优化包括并发压缩垃圾回收、更有效的内存利用和代码区域。</p><p>它们可以加快启动时间，并为 OS 和应用带来更好的性能。</p><h2 id="更新的-Java-支持"><a href="#更新的-Java-支持" class="headerlink" title="更新的 Java 支持"></a>更新的 Java 支持</h2><p>Android 8.0 添加了对更多 OpenJDK Java API 的支持：</p><ul><li>OpenJDK 8 中的 java.time。</li><li>OpenJDK 7 中的 java.nio.file 和 java.lang.invoke。<br>要详细了解这些新添加的软件包中的类和函数，请参阅 API 参考文档。</li></ul><p>如果您想要在 Android Studio 中使用 <a href="https://developer.android.com/studio/preview/features/java8-support.html" target="_blank" rel="noopener">Java 8 语言功能</a>，您应下载最新的预览版本。</p><h2 id="更新的-ICU4J-Android-Framework-API"><a href="#更新的-ICU4J-Android-Framework-API" class="headerlink" title="更新的 ICU4J Android Framework API"></a>更新的 ICU4J Android Framework API</h2><p>Android 8.0 扩展了 ICU4J Android 框架 API—，它是 ICU4J API 的子集—，供应用开发者在 android.icu 软件包中使用。这些 API 使用设备上具有的本地化数据。因此，您无需在 APK 中编译 ICU4J 库，从而减少 APK 占用空间。</p><h1 id="Android-企业版"><a href="#Android-企业版" class="headerlink" title="Android 企业版"></a>Android 企业版</h1><hr><p>已为运行 Android 8.0 的设备引入新的企业功能和 API。重要功能包括如下：</p><ul><li>完全托管的设备中的工作资料使企业可以在管理工作数据与个人数据的同时，将它们分离开来。</li><li>API 委派允许设备所有者和个人资料所有者将应用管理分配给其他应用。</li><li>配置流程中的用户体验改进措施（包含新的自定义选项）缩短了设置时间。</li><li>蓝牙、WLAN、备份和安全性方面的新增控制选项使企业可以更精细地管理设备。网络操作组件日志记录可帮助企业追查问题。</li></ul><p>如需详细了解上述及其他新增 Android 企业版 API 和功能，请参阅<a href="https://developer.android.com/preview/features/work.html" target="_blank" rel="noopener">企业中的 Android</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用户体验&quot;&gt;&lt;a href=&quot;#用户体验&quot; class=&quot;headerlink&quot; title=&quot;用户体验&quot;&gt;&lt;/a&gt;用户体验&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;通知&quot;&gt;&lt;a href=&quot;#通知&quot; class=&quot;headerlink&quot; title=&quot;通知&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
      <category term="Oreo" scheme="http://yoursite.com/tags/Oreo/"/>
    
      <category term="Android 8.0" scheme="http://yoursite.com/tags/Android-8-0/"/>
    
  </entry>
  
  <entry>
    <title>Android 7.0 行为变更</title>
    <link href="http://yoursite.com/2017/01/10/android-7-0-changes/"/>
    <id>http://yoursite.com/2017/01/10/android-7-0-changes/</id>
    <published>2017-01-10T07:15:08.000Z</published>
    <updated>2018-04-10T01:36:21.681Z</updated>
    
    <content type="html"><![CDATA[<p>Android 7.0 除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。</p><p>如果您之前发布过 Android 应用，请注意您的应用可能受到这些平台变化的影响。</p><h1 id="电池和内存"><a href="#电池和内存" class="headerlink" title="电池和内存"></a>电池和内存</h1><hr><p>Android 7.0 包括旨在延长设备电池寿命和减少 RAM 使用的系统行为变更。这些变更可能会影响您的应用访问系统资源，以及您的应用通过特定隐式 intent 与其他应用交互的方式。</p><h2 id="低电耗模式"><a href="#低电耗模式" class="headerlink" title="低电耗模式"></a>低电耗模式</h2><p>Android 6.0（API 级别 23）引入了低电耗模式，当用户设备未插接电源、处于静止状态且屏幕关闭时，该模式会推迟 CPU 和网络活动，从而延长电池寿命。而 Android 7.0 则通过在设备未插接电源且屏幕关闭状态下、但不一定要处于静止状态（例如用户外出时把手持式设备装在口袋里）时应用部分 CPU 和网络限制，进一步增强了低电耗模式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/01/10/android-7-0-changes/doze-diagram-1.png" alt="dhd" title="">                </div>                <div class="image-caption">dhd</div>            </figure><br>图 1. 低电耗模式如何应用第一级系统活动限制以延长电池寿命的图示。</p><p>当设备处于充电状态且屏幕已关闭一定时间后，设备会进入低电耗模式并应用第一部分限制：关闭应用网络访问、推迟作业和同步。如果进入低电耗模式后设备处于静止状态达到一定时间，系统则会对 <code>PowerManager.WakeLock</code>、<code>AlarmManager</code> 闹铃、GPS 和 WLAN 扫描应用余下的低电耗模式限制。无论是应用部分还是全部低电耗模式限制，系统都会唤醒设备以提供简短的维护时间窗口，在此窗口期间，应用程序可以访问网络并执行任何被推迟的作业/同步。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/01/10/android-7-0-changes/doze-diagram-2.png" alt="dhd" title="">                </div>                <div class="image-caption">dhd</div>            </figure><br>图 2. 低电耗模式如何在设备处于静止状态达到一定时间后应用第二级系统活动限制的图示。</p><p>请注意，激活屏幕或插接设备电源时，系统将退出低电耗模式并移除这些处理限制。此项新增的行为不会影响有关使您的应用适应 Android 6.0（API 级别 23）中所推出的旧版本低电耗模式的建议和最佳做法，如<a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="noopener">对低电耗模式和应用待机模式进行针对性优化</a>中所讨论。您仍应遵循这些建议（例如使用 Google 云消息传递 (GCM) 发送和接收消息）并开始安排更新计划以适应新增的低电耗模式行为。</p><h2 id="Project-Svelte：后台优化"><a href="#Project-Svelte：后台优化" class="headerlink" title="Project Svelte：后台优化"></a>Project Svelte：后台优化</h2><p>Android 7.0 移除了三项隐式广播，以帮助优化内存使用和电量消耗。此项变更很有必要，因为隐式广播会在后台频繁启动已注册侦听这些广播的应用。删除这些广播可以显著提升设备性能和用户体验。</p><p>移动设备会经历频繁的连接变更，例如在 WLAN 和移动数据之间切换时。目前，可以通过在应用清单中注册一个接收器来侦听隐式 <code>CONNECTIVITY_ACTION</code> 广播，让应用能够监控这些变更。由于很多应用会注册接收此广播，因此单次网络切换即会导致所有应用被唤醒并同时处理此广播。</p><p>同理，在之前版本的 Android 中，应用可以注册接收来自其他应用（例如相机）的隐式 <code>ACTION_NEW_PICTURE</code> 和 <code>ACTION_NEW_VIDEO</code> 广播。当用户使用相机应用拍摄照片时，这些应用即会被唤醒以处理广播。</p><p>为缓解这些问题，Android 7.0 应用了以下优化措施：</p><ul><li>面向 Android 7.0 开发的应用不会收到 <code>CONNECTIVITY_ACTION</code> 广播，即使它们已有清单条目来请求接受这些事件的通知。在前台运行的应用如果使用 <code>BroadcastReceiver</code> 请求接收通知，则仍可以在主线程中侦听 CONNECTIVITY_CHANGE。</li><li>应用无法发送或接收 <code>ACTION_NEW_PICTURE</code> 或 <code>ACTION_NEW_VIDEO</code> 广播。此项优化会影响所有应用，而不仅仅是面向 Android 7.0 的应用。</li></ul><p>如果您的应用使用任何 intent，您仍需要尽快移除它们的依赖关系，以正确适配 Android 7.0 设备。Android 框架提供多个解决方案来缓解对这些隐式广播的需求。例如，<code>JobScheduler</code> API 提供了一个稳健可靠的机制来安排满足指定条件（例如连入无限流量网络）时所执行的网络操作。您甚至可以使用 <code>JobScheduler</code> 来适应内容提供程序变化。</p><p>如需了解有关 Android N 中后台优化以及如何改写应用的详细信息，请参阅<a href="https://developer.android.com/preview/features/background-optimization.html" target="_blank" rel="noopener">后台优化</a>。</p><h1 id="权限更改"><a href="#权限更改" class="headerlink" title="权限更改"></a>权限更改</h1><hr><p>Android 7.0 做了一些权限更改，这些更改可能会影响您的应用。</p><h2 id="系统权限更改"><a href="#系统权限更改" class="headerlink" title="系统权限更改"></a>系统权限更改</h2><p>为了提高私有文件的安全性，面向 Android 7.0 或更高版本的应用私有目录被限制访问　(0700)。此设置可防止私有文件的元数据泄漏，如它们的大小或存在性。此权限更改有多重副作用：</p><ul><li><p>私有文件的文件权限不应再由所有者放宽，为使用 <code>MODE_WORLD_READABLE</code> 和/或 <code>MODE_WORLD_WRITEABLE</code> 而进行的此类尝试将触发 <code>SecurityException</code>。</p><blockquote><p><strong>注：</strong>迄今为止，这种限制尚不能完全执行。应用仍可能使用原生 API 或 File API 来修改它们的私有目录权限。但是，我们强烈反对放宽私有目录的权限。</p></blockquote></li><li><p>传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。因此，尝试传递 file:// URI 会触发 <code>FileUriExposedException</code>。分享私有文件内容的推荐方法是使用 <code>FileProvider</code>。</p></li><li><code>DownloadManager</code> 不再按文件名分享私人存储的文件。旧版应用在访问 <code>COLUMN_LOCAL_FILENAME</code> 时可能出现无法访问的路径。面向 Android 7.0 或更高版本的应用在尝试访问 <code>COLUMN_LOCAL_FILENAME</code> 时会触发 <code>SecurityException</code>。通过使用 <code>DownloadManager.Request.setDestinationInExternalFilesDir()</code> 或 <code>DownloadManager.Request.setDestinationInExternalPublicDir()</code> 将下载位置设置为公共位置的旧版应用仍可以访问 <code>COLUMN_LOCAL_FILENAME</code> 中的路径，但是我们强烈反对使用这种方法。对于由 <code>DownloadManager</code> 公开的文件，首选的访问方式是使用<code>ContentResolver.openFileDescriptor()</code>。</li></ul><h1 id="在应用间共享文件"><a href="#在应用间共享文件" class="headerlink" title="在应用间共享文件"></a>在应用间共享文件</h1><hr><p>对于面向 Android 7.0 的应用，Android 框架执行的 <code>StrictMode</code> API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。</p><p>要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。进行此授权的最简单方式是使用 FileProvider 类。如需了解有关权限和共享文件的详细信息，请参阅<a href="https://developer.android.com/training/secure-file-sharing/index.html" target="_blank" rel="noopener">共享文件</a>。</p><h1 id="无障碍改进"><a href="#无障碍改进" class="headerlink" title="无障碍改进"></a>无障碍改进</h1><hr><p>为提高平台对于视力不佳或视力受损用户的易用性，Android 7.0 做出了一些更改。这些更改一般并不要求更改您的应用代码，不过您应仔细检查并使用您的应用测试这些功能，以评估它们对用户体验的潜在影响。</p><h2 id="屏幕缩放"><a href="#屏幕缩放" class="headerlink" title="屏幕缩放"></a>屏幕缩放</h2><p>Android 7.0 支持用户设置显示尺寸，以放大或缩小屏幕上的所有元素，从而提升设备对视力不佳用户的可访问性。用户无法将屏幕缩放至低于最小屏幕宽度 <code>sw320dp</code>，该宽度是 Nexus 4 的宽度，也是常规中等大小手机的宽度。<br><img src="/2017/01/10/android-7-0-changes/screen-zoom-1.png" style="width:45%; float:left"><br><img src="/2017/01/10/android-7-0-changes/screen-zoom-2.png" style="width:45%; float:left"><br> <div style="clear:both"></div><br>图 3. 右侧屏幕显示的是一台运行 Android 7.0 系统映像的设备增大显示尺寸后的效果。</p><p>当设备密度发生更改时，系统会以如下方式通知正在运行的应用：</p><ul><li>如果是面向 API 级别 23 或更低版本系统的应用，系统会自动终止其所有后台进程。这意味着如果用户切换离开此类应用，转而打开 Settings 屏幕并更改 <strong>Display size</strong> 设置，则系统会像处理内存不足的情况一样终止该应用。如果应用具有任何前台进程，则系统会如处理运行时更改中所述将配置变更通知给这些进程，就像对待设备屏幕方向变更一样。</li><li>如果是面向 Android 7.0 的应用，则其所有进程（前台和后台）都会收到有关配置变更的通知，如<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时更改</a>中所述。</li></ul><p>大多数应用并不需要进行任何更改即可支持此功能，不过前提是这些应用遵循 Android 最佳做法。具体要检查的事项：</p><ul><li>在屏幕宽度为 sw320dp 的设备上测试您的应用，并确保其充分运行。</li><li><p>当设备配置发生变更时，更新任何与密度相关的缓存信息，例如缓存位图或从网络加载的资源。当应用从暂停状态恢复运行时，检查配置变更。</p><blockquote><p><strong>注：</strong>如果您要缓存与配置相关的数据，则最好也包括相关元数据，例如该数据对应的屏幕尺寸或像素密度。保存这些元数据便于您在配置变更后决定是否需要刷新缓存数据。</p></blockquote></li><li><p>避免用像素单位指定尺寸，因为像素不会随屏幕密度缩放。应改为使用与密度无关像素 (dp) 单位指定尺寸。</p></li></ul><h2 id="设置向导中的视觉设置"><a href="#设置向导中的视觉设置" class="headerlink" title="设置向导中的视觉设置"></a>设置向导中的视觉设置</h2><p>Android 7.0 在“Welcome”屏幕中加入了“Vision Settings”，用户可以在新设备上设置以下无障碍功能设置：<strong>Magnification gesture</strong>、<strong>Font size</strong>、<strong>Display size</strong> 和话语提示。此项变更让您可以更容易发现与不同屏幕设置有关的错误。要评估此功能的影响，您应在启用这些设置的状态下测试应用。您可以在 <strong>Settings &gt; Accessibility</strong> 中找到这些设置。</p><h1 id="NDK-应用链接至平台库"><a href="#NDK-应用链接至平台库" class="headerlink" title="NDK 应用链接至平台库"></a>NDK 应用链接至平台库</h1><hr><p>从 Android 7.0 开始，系统将阻止应用动态链接非公开 NDK 库，这种库可能会导致您的应用崩溃。此行为变更旨在为跨平台更新和不同设备提供统一的应用体验。即使您的代码可能不会链接私有库，但您的应用中的第三方静态库可能会这么做。因此，所有开发者都应进行相应检查，确保他们的应用不会在运行 Android 7.0 的设备上崩溃。如果您的应用使用原生代码，则只能使用<a href="https://developer.android.com/ndk/guides/stable_apis.html" target="_blank" rel="noopener">公开 NDK API</a>。</p><p>您的应用可通过以下三种方式尝试访问私有平台 API：</p><ul><li>您的应用直接访问私有平台库。您应更新您的应用以添加该应用的库副本，或使用<a href="https://developer.android.com/ndk/guides/stable_apis.html" target="_blank" rel="noopener">公开 NDK API</a>。</li><li>您的应用使用一个可访问私有平台库的第三方库。即使您确定您的应用不会直接访问私有库，您仍应针对此情景测试您的应用。</li><li>您的应用引用一个其 APK 中未包含的库。例如，如果您尝试使用您自己的 OpenSSL 副本，但忘记将它与应用的 APK 进行捆绑，则可能会出现此情况。正常情况下，此应用可在包含 libcrypto.so 的 Android 平台版本上运行。不过，此应用在不包含此库的新版 Android（例如，Android 6.0 和更高的版本）上会崩溃。为修复此问题，请确保您的 APK 捆绑您的所有非 NDK 库。</li></ul><p>应用不应使用 NDK 中未包含的原生库，因为这些库可能会发生更改或在不同 Android 版本之间的可用性不同。例如，从 OpenSSL 切换至 BoringSSL 即属于此类更改。此外，由于不属于 NDK 中的平台库没有兼容性要求，因此不同的设备可能提供不同级别的兼容性。</p><p>为降低此限制可能对当前发布的应用的影响，面向 API 级别 23 或更低级别的应用在 Android N 上可暂时访问颇为常用的一组库，例如 <code>libandroid_runtime.so</code>、<code>libcutils.so</code>、<code>libcrypto.so</code> 和 <code>libssl.so</code>。如果您的应用加载其中某个库，logcat 会生成一个警告，并在目标设备上显示一个 Toast 来通知您。如果您看到这些警告，您应更新您的应用以添加该应用自己的库副本，或仅使用公开 NDK API。将来发布的 Android 平台可能会完全限制对私有库的使用，并导致您的应用崩溃。</p><p>所有应用在调用既非公开又不可暂时访问的 API 时都会生成一个运行时错误。结果就是 <code>System.loadLibrary</code> 和 <code>dlopen(3)</code> 同时返回 NULL，并可能导致您的应用崩溃。您应检查应用代码以移除对私有平台 API 的使用，并使用预览版设备或模拟器全面测试应用。如果您不确定您的应用是否使用私有库，您可以检查 logcat 以识别运行时错误。</p><p>下表描述的是根据应用使用的私有原生库及其目标 API 级别 (android:targetSdkVersion)，应用预期显示的行为。<br>| Item      |    Value | Qty  |<br>| :——– | ——–:| :–: |<br>| Computer  | 1600 USD |  5   |<br>| Phone     |   12 USD |  12  |<br>| Pipe      |    1 USD | 234  |</p><table><thead><tr><th style="text-align:left">库</th><th style="text-align:left">目标 API 级别</th><th style="text-align:left">通过动态链接器进行运行时访问</th><th style="text-align:left">N Developer Preview 行为</th><th style="text-align:left">最终 Android N 版本行为</th><th style="text-align:left">未来的 Android 平台行为</th></tr></thead><tbody><tr><td style="text-align:left">公开 NDK</td><td style="text-align:left">任意</td><td style="text-align:left">可访问</td><td style="text-align:left">合乎预期</td><td style="text-align:left">合乎预期</td><td style="text-align:left">合乎预期</td></tr><tr><td style="text-align:left">私有（暂时可访问的私有库）</td><td style="text-align:left">23 或更低</td><td style="text-align:left">暂时可访问</td><td style="text-align:left">合乎预期，但您会在目标设备上收到一个 logcat 警告和一条消息。</td><td style="text-align:left">合乎预期，但您会收到一个 logcat 警告。</td><td style="text-align:left">运行时错误</td></tr><tr><td style="text-align:left">私有（暂时可访问的私有库）</td><td style="text-align:left">24 或更高</td><td style="text-align:left">受限</td><td style="text-align:left">运行时错误</td><td style="text-align:left">运行时错误</td><td style="text-align:left">运行时错误</td></tr><tr><td style="text-align:left">私有（其他）</td><td style="text-align:left">任意</td><td style="text-align:left">受限</td><td style="text-align:left">运行时错误</td><td style="text-align:left">运行时错误</td><td style="text-align:left">运行时错误</td></tr></tbody></table><h2 id="检查您的应用是否使用私有库"><a href="#检查您的应用是否使用私有库" class="headerlink" title="检查您的应用是否使用私有库"></a>检查您的应用是否使用私有库</h2><p>为帮助您识别加载私有库的问题，logcat 可能会生成一个警告或运行时错误。例如，如果您的应用面向 API 级别 23 或更低级别，并在运行 Android 7.0 的设备上尝试访问私有库，您可能会看到一个类似于下面所示的警告：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">51.502</span> <span class="number">31234</span> <span class="number">31234</span> W linker  : library <span class="string">"libandroid_runtime.so"</span></span><br><span class="line">(<span class="string">"/system/lib/libandroid_runtime.so"</span>) needed <span class="keyword">or</span> dlopened by</span><br><span class="line"><span class="string">"/data/app/com.popular-app.android-2/lib/arm/libapplib.so"</span> is <span class="keyword">not</span> accessible</span><br><span class="line"><span class="keyword">for</span> the <span class="keyword">namespace</span> <span class="string">"classloader-namespace"</span> - the access is temporarily granted</span><br><span class="line">as a workaround <span class="keyword">for</span> http:<span class="comment">//b/26394120</span></span><br></pre></td></tr></table></figure></p><p>这些 logcat 警告通知您哪个库正在尝试访问私有平台 API，但不会导致您的应用崩溃。但是，如果应用面向 API 级别 24 或更高级别，logcat 会生成以下运行时错误，您的应用可能会崩溃：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: dlopen failed: library <span class="string">"libcutils.so"</span></span><br><span class="line">(<span class="string">"/system/lib/libcutils.so"</span>) needed <span class="keyword">or</span> dlopened by</span><br><span class="line"><span class="string">"/system/lib/libnativeloader.so"</span> is <span class="keyword">not</span> accessible <span class="keyword">for</span> the <span class="keyword">namespace</span></span><br><span class="line"><span class="string">"classloader-namespace"</span></span><br><span class="line">  at java.lang.Runtime.loadLibrary0(Runtime.java:<span class="number">977</span>)</span><br><span class="line">  at java.lang.System.loadLibrary(System.java:<span class="number">1602</span>)</span><br></pre></td></tr></table></figure></p><p>如果您的应用使用动态链接到私有平台 API 的第三方库，您可能也会看到上述 logcat 输出。利用 Android 7.0DK 中的 readelf 工具，您可以通过运行以下命令生成给定 .so 文件的所有动态链接的共享库列表：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-android-readelf -dW libMyLibrary.so</span><br></pre></td></tr></table></figure></p><h2 id="更新您的应用"><a href="#更新您的应用" class="headerlink" title="更新您的应用"></a>更新您的应用</h2><p>通过下面的一些步骤，您可以修复上述类型的错误并确保您的应用不会在将来的更新版平台上崩溃：</p><ul><li>如果您的应用使用私有平台库，您应更新它，以添加该应用自己的库副本或使用<a href="https://developer.android.com/ndk/guides/stable_apis.html" target="_blank" rel="noopener">公开 NDK API</a>。</li><li>如果您的应用使用访问私有符号的第三方库，则联系库作者以更新库。</li><li>请确保将您的所有非 NDK 库与您的 APK 打包在一起。</li><li><p>使用标准 JNI 函数而非来自 libandroid_runtime.so 的 getJavaVM 和 getJNIEnv：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AndroidRuntime::getJavaVM -&gt; GetJavaVM from &lt;jni.h&gt;</span><br><span class="line">AndroidRuntime::getJNIEnv -&gt; JavaVM::GetEnv <span class="keyword">or</span></span><br><span class="line">JavaVM::AttachCurrentThread from &lt;jni.h&gt;.</span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>system_property_get 而非来自 libcutils.so 的私有 property_get 符号。为此，请使用 </strong>system_property_get 及以下 include 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/system_properties.h&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注：</strong>系统属性的可用性和内容未通过 CTS 进行测试。应执行进一步修复以避免同时使用这些属性。</p></blockquote><ul><li>使用来自 <code>libcrypto.so</code> 的 SSL_ctrl 符号的本地版本。例如，您应在您的 .so 文件中静态链接 <code>libcyrpto.a</code>，或从 <strong>BoringSSL/OpenSSL</strong> 添加一个动态链接的 <code>libcrypto.so</code> 版本，并将其打包到您的 APK 中。</li></ul><h1 id="Android-for-Work"><a href="#Android-for-Work" class="headerlink" title="Android for Work"></a>Android for Work</h1><hr><p>Android 7.0 包含一些针对面向 Android for Work 的应用的变更，包括对证书安装、密码重置、二级用户管理、设备标识符访问权限的变更。如果您是要针对 Android for Work 环境开发应用，则应仔细检查这些变更并相应地修改您的应用。</p><ul><li>您必须先安装授权证书安装程序，然后 DPC 才能对其进行设置。对于面向 N SDK 的配置文件和设备所有者应用，您应在设备规范控制器 (DPC) 调用 <code>DevicePolicyManager.setCertInstallerPackage()</code> 之前安装授权证书安装程序。如果尚未安装此安装程序，则系统会引发 <code>IllegalArgumentException</code>。</li><li>针对设备管理员的重置密码限制现在也适用于配置文件所有者。设备管理员无法再使用 <code>DevicePolicyManager.resetPassword()</code> 来清除或更改已经设置的密码。设备管理员仍可以设置密码，但只能在设备没有密码、PIN 码或图案时这样做。</li><li>即使设置了限制，设备所有者和配置文件所有者仍可以管理帐户。而且，即使具有 <code>DISALLOW_MODIFY_ACCOUNTS</code> 用户限制，设备所有者和配置文件所有者仍可调用 Account Management API。</li><li>设备所有者可以更轻松地管理二级用户。当设备在设备所有者模式下运行时，系统将自动设置 DISALLOW_ADD_USER 限制。这样可以防止用户创建非托管二级用户。此外，<code>CreateUser()</code> 和 <code>createAndInitializeUser()</code> 方法已弃用，取而代之的是 <code>DevicePolicyManager.createAndManageUser()</code> 方法。</li><li>设备所有者可以访问设备标识符。设备所有者可以使用 <code>DevicePolicyManagewr.getWifiMacAddress()</code> 访问设备的 WLAN MAC 地址。如果设备上从未启用 WLAN，则此方法将返回一个 null 值。</li><li>工作模式设置控制工作应用访问。当工作模式关闭时，系统启动器通过使工作应用显示为灰色来指示它们不可用。启用工作模式会再次恢复正常行为。</li><li>从 Settings UI 安装包含客户端证书链和对应的私钥的 PKCS #12 文件时，系统不再将该证书链中的 CA 证书安装到受信任的凭据存储空间。当应用稍后尝试检索客户端证书链时，这不会影响 <code>KeyChain.getCertificateChain()</code> 的结果。如果需要，使用 .crt 或 .cer 文件扩展名的 DER 编码格式通过 Settings UI 单独将 CA 证书安装到受信任的凭据存储空间。</li><li>从 Android 7.0 开始，可针对每个用户管理指纹登记和存储空间。如果配置文件所有者的设备规范客户端 (DPC) 面向 Android N 设备上的 Android N 之前的版本，则用户仍可以在该设备上设置指纹，但工作应用不能访问设备指纹。当 DPC 面向 Android N 和更高版本时，用户可以通过转到 <strong>Settings &gt; Security &gt; Work profile security</strong> 专门为托管配置文件设置指纹。</li><li><code>DevicePolicyManager.getStorageEncryptionStatus()</code> 返回新的加密状态 <code>ENCRYPTION_STATUS_ACTIVE_PER_USER</code>，以表明加密处于活动状态，且加密密钥与用户关联。仅当 DPC 面向 API 级别 24 和更高级别时才会返回新的状态。对于面向更早的 API 级别的应用，即使加密密钥是用户或配置文件特有的，系统也会返回 <code>ENCRYPTION_STATUS_ACTIVE</code>。</li><li>在 Android 7.0 中，如果设备通过单独的工作挑战安装了托管配置文件，则原本通常会影响整个设备的多个方法将会改变其行为方式。这些方法将仅应用于托管配置文件，而不是影响整个设备。（此类方法的完整列表位于 <code>DevicePolicyManager.getParentProfileInstance()</code> 文档中。）例如，<code>DevicePolicyManager.lockNow()</code> 只锁定托管配置文件，而不是锁定整个设备。对于上述每个方法，您可以通过对 DevicePolicyManager 的父实例调用该方法来获取以前的行为；您可以通过调用 <code>DevicePolicyManager.getParentProfileInstance()</code> 获取此父项。例如，如果您调用父实例的 <code>lockNow()</code> 方法，则整个设备将被锁定。</li></ul><p>如需了解有关 Android 7.0 中针对 Android for Work 所做变更的详细信息，请参阅 Android for Work 更新。</p><h1 id="注解保留"><a href="#注解保留" class="headerlink" title="注解保留"></a>注解保留</h1><hr><p>Android 7.0 修复了一个注解可见性被忽略的错误。这种问题会导致应用可在运行时访问原本不允许访问的注解。这些注解包括：</p><ul><li><code>VISIBILITY_BUILD</code>：仅应编译时可见。</li><li><code>VISIBILITY_SYSTEM</code>：运行时应可见，但仅限底层系统。<br>如果您的应用依赖这种行为，请为运行时必须可用的注解添加保留政策。您可通过使用 <code>@Retention(RetentionPolicy.RUNTIME)</code> 来执行此操作。</li></ul><h1 id="其他重要说明"><a href="#其他重要说明" class="headerlink" title="其他重要说明"></a>其他重要说明</h1><hr><ul><li><p>如果一个应用在 Android 7.0 上运行，但却是针对更低 API 级别开发的，那么在用户更改显示尺寸时，系统将终止此应用进程。应用必须能够妥善处理此情景。否则，当用户从最近使用记录中恢复运行应用时，应用将会出现崩溃现象。<br>您应测试应用以确保不会发生此行为。要进行此测试，您可以通过 DDMS 手动终止应用，以造成相同的崩溃现象。<br>在密度发生更改时，系统不会自动终止面向 N 及更高版本的应用；不过，这些应用仍可能对配置变更做出不良响应。</p></li><li><p>Android 7.0 上的应用应能够妥善处理配置变更，并且在后续启动时不会出现崩溃现象。您可以通过更改字体大小 <code>(Setting &gt;Display &gt; Font size)</code> 并随后从最近使用记录中恢复运行应用，来验证应用行为。</p></li><li>由于之前的 Android 版本中的一项错误，系统未能将对主线程上的一个 TCP 套接字的写入操作举报为违反严格模式。Android 7.0 修复了此错误。呈现出这种行为的应用现在会引发 <code>android.os.NetworkOnMainThreadException</code>。一般情况下，我们不建议在主线程上执行网络操作，因为这些操作通常会出现可能导致 ANR 和卡顿的高尾延迟。</li><li><code>Debug.startMethodTracing()</code> 方法系列现在默认在您的共享存储空间上的软件包特定目录中存储输出，而非 SD 卡根目录。这意味着应用不再需要请求 <code>WRITE_EXTERNAL_STORAGE</code> 权限来使用这些 API 。</li><li>许多平台 API 现在开始检查在 <code>Binder</code> 事务间发送的大负载，系统现在会将 <code>TransactionTooLargeExceptions</code> 作为 RuntimeExceptions 再次引发，而不再只是默默记录或抑制它们。一个常见例子是在 <code>Activity.onSaveInstanceState()</code> 上存储过多数据，导致 ActivityThread.StopInfo 在您的应用面向 Android 7.0 时引发 RuntimeException。</li><li>如果应用向 View 发布 <code>Runnable</code> 任务，并且 View 未附加到窗口，系统会用 View 为 <code>Runnable</code> 任务排队；在 View 附加到窗口之前，不会执行 <code>Runnable</code> 任务。此行为会修复以下错误：<ul><li>如果一项应用是从并非预期窗口 UI 线程的其他线程发布到 View，则 <code>Runnable</code> 可能会因此运行错误的线程。</li><li>如果 <code>Runnable</code> 任务是从并非环路线程的其他线程发布，则应用可能会曝光 Runnable 任务。</li></ul></li><li>如果 Android 7.0 上一项有 <code>DELETE_PACKAGES</code> 权限的应用尝试删除一个软件包，但另一项应用已经安装了这个软件包，则系统需要用户进行确认。在这种情况下，应用在调用 <code>PackageInstaller.uninstall()</code> 时预计的返回状态应为 <code>STATUS_PENDING_USER_ACTION</code>。</li><li>名为 Crypto 的 JCA 提供程序已弃用，因为它仅有的 SHA1PRNG 算法为弱加密。应用无法再使用 SHA1PRNG（不安全地）派生密钥，因为不再提供此提供程序。如需了解详细信息，请参阅博文 <a href="http://android-developers.blogspot.com/2016/06/security-crypto-provider-deprecated-in.html" target="_blank" rel="noopener">Android N 中已弃用“Crypto”安全提供程序</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 7.0 除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。&lt;/p&gt;
&lt;p&gt;如果您之前发布过 Android 应用，请注意您的应用可能受到这些平台变化的影响。&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
      <category term="Nougat" scheme="http://yoursite.com/tags/Nougat/"/>
    
      <category term="Android 7.0" scheme="http://yoursite.com/tags/Android-7-0/"/>
    
  </entry>
  
  <entry>
    <title>Android 7.0 API 概览</title>
    <link href="http://yoursite.com/2016/12/30/android-7-0/"/>
    <id>http://yoursite.com/2016/12/30/android-7-0/</id>
    <published>2016-12-30T06:12:49.000Z</published>
    <updated>2018-04-10T01:30:24.205Z</updated>
    
    <content type="html"><![CDATA[<p>Android 7.0 Nougat 为用户和开发者引入多种新功能。本文重点介绍面向开发者的新功能。</p><p>请务必查阅 Android 7.0 行为变更以了解平台变更可能影响您的应用的领域。</p><p>要详细了解 Android 7.0 的消费者功能，请访问 <a href="https://www.android.com" target="_blank" rel="noopener">www.android.com</a>。</p><h1 id="多窗口支持"><a href="#多窗口支持" class="headerlink" title="多窗口支持"></a>多窗口支持</h1><hr><p>在 Android 7.0 中，我们为该平台引入了一个新的而且非常需要的多任务处理功能 — 多窗口支持。</p><p>现在，用户可以一次在屏幕上打开两个应用。</p><ul><li>在运行 Android 7.0 的手机和平板电脑上，用户可以并排运行两个应用，或者处于分屏模式时一个应用位于另一个应用之上。用户可以通过拖动两个应用之间的分隔线来调整应用。</li><li>在 Android TV 设备上，应用可以将自身置于画中画模式，从而让它们可以在用户浏览或与其他应用交互时继续显示内容。<br><p style="overflow:hidden"><br><img src="/2016/12/30/android-7-0/mw-portrait.png" style="width:200px;float:left;margin-right:40px"><br><span><br>多窗口支持为您提供新的吸引用户方式，特别是在平板电脑和其他更大屏幕的设备上。您甚至可以在您的应用中启用拖放，从而使用户可以方便地将内容拖放到您的应用或从其中拖出内容—这是一个非常好的增强用户体验的方式。<br><br><br><br>向您的应用添加多窗口支持并配置多窗口显示的处理方式非常简单。例如，您可以指定您的 Activity 允许的最小尺寸，从而防止用户将 Activity 调整到该尺寸以下。您还可以为应用停用多窗口显示，这可确保系统将仅以全屏模式显示应用。<br><br><br><br></span></p></li></ul><p></p><p></p><h1 id="通知增强功能"><a href="#通知增强功能" class="headerlink" title="通知增强功能"></a>通知增强功能</h1><hr><p>在 Android 7.0 中，我们重新设计了通知，使其更易于使用并且速度更快。部分变更包括：</p><ul><li><strong>模板更新：</strong>我们正在更新通知模板，新强调了英雄形象和化身。开发者将能够充分利用新模板，只需进行少量的代码调整。</li><li><strong>消息传递样式自定义：</strong>您可以自定义更多与您的使用 MessagingStyle 类的通知相关的用户界面标签。您可以配置消息、会话标题和内容视图。</li><li><strong>捆绑通知：</strong>系统可以将消息组合在一起（例如，按消息主题）并显示组。用户可以适当地进行拒绝或归档等操作。如果您已实现 Android Wear 的通知，那么您已经很熟悉此模式。</li><li><strong>直接回复：</strong>对于实时通信应用，Android 系统支持内联回复，以便用户可以直接在通知界面中快速回复短信。</li><li><strong>自定义视图：</strong>两个新的 API 让您在通知中使用自定义视图时可以充分利用系统装饰元素，如通知标题和操作。<br><img src="/2016/12/30/android-7-0/notifications-1.png" style="width:30%; margin:10px; float:left;"> <img src="/2016/12/30/android-7-0/notifications-3.png" style="width:30%; margin:10px; float:left;"><img src="/2016/12/30/android-7-0/notifications-2.png" style="width:30%; margin:10px;"><br>图 2. 绑定的通知和直接回复。</li></ul><p>要了解如何实现新功能的信息，请参阅<a href="https://developer.android.com/preview/features/notification-updates.html" target="_blank" rel="noopener">通知</a>指南。</p><h1 id="配置文件指导的-JIT-AOT-编译"><a href="#配置文件指导的-JIT-AOT-编译" class="headerlink" title="配置文件指导的 JIT/AOT 编译"></a>配置文件指导的 JIT/AOT 编译</h1><hr><p>在 Android 7.0 中，我们添加了即时 (JIT) 编译器，对 ART 进行代码分析，让它可以在应用运行时持续提升 Android 应用的性能。JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。</p><p>配置文件指导的编译让 Android 运行组件能够根据应用的实际使用以及设备上的情况管理每个应用的 AOT/JIT 编译。例如，Android 运行组件维护每个应用热方法的配置文件，并且可以预编译和缓存这些方法以实现最佳性能。对于应用的其他部分，在实际使用之前不会进行编译。</p><p>除提升应用的关键部分的性能外，配置文件指导的编译还有助于减少整个 RAM 占用，包括关联的二进制文件。此功能对于低内存设备非常尤其重要。</p><p>Android 运行组件在管理配置文件指导的编译时，可最大程度降低对设备电池的影响。仅当设备处于空闲状态和充电时才进行编译，从而可以通过提前执行该工作节约时间和省电。</p><h1 id="快速的应用安装路径"><a href="#快速的应用安装路径" class="headerlink" title="快速的应用安装路径"></a>快速的应用安装路径</h1><hr><p>Android 运行组件的 JIT 编译器最实际的好处之一是应用安装和系统更新的速度。即使在 Android 6.0 中需要几分钟进行优化和安装的大型应用，现在只需几秒钟就可以完成安装。系统更新也变得更快，因为省去了优化步骤。</p><h1 id="随时随地低电耗模式…"><a href="#随时随地低电耗模式…" class="headerlink" title="随时随地低电耗模式…"></a>随时随地低电耗模式…</h1><hr><p>Android 6.0 推出了低电耗模式，即设备处于空闲状态时，通过推迟应用的 CPU 和网络活动以实现省电目的的系统模式，例如，设备放在桌上或抽屉里时。</p><p>现在，在 Android 7.0 中，低电耗模式又前进了一步，随时随地可以省电。只要屏幕关闭了一段时间，且设备未插入电源，低电耗模式就会对应用使用熟悉的 CPU 和网络限制。这意味着用户即使将设备放入口袋里也可以省电。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://developer.android.com/images/android-7.0/doze-diagram-1.png" alt="dd" title="">                </div>                <div class="image-caption">dd</div>            </figure><p>图 3. 低电耗模式现在应用限制以延长电池寿命，即使设备未处于静止状态。</p><p>屏幕关闭片刻后，设备在使用电池时，低电耗模式将限制网络访问，同时延迟作业和同步。在短暂的维护时间范围后，其允许应用访问网络，并执行延迟的作业/同步。打开屏幕或将设备插入电源会使设备退出低电耗模式。</p><p>当设备再次处于静止状态时，屏幕关闭且使用电池一段时间，低电耗模式针对 <code>PowerManager.WakeLock</code>、<code>AlarmManager</code> 警报和 GPS/WLAN 扫描应用完整 CPU 和网络限制。</p><p>无论设备是否处于运动状态，将应用调整到低电耗模式的最佳做法均相同，因此，如果您已更新应用以妥善处理低电耗模式，则一切就绪。如果不是，请立即开始<a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html#assessing_your_app" target="_blank" rel="noopener">将应用调整到低电耗模式</a></p><h1 id="Project-Svelte：后台优化"><a href="#Project-Svelte：后台优化" class="headerlink" title="Project Svelte：后台优化"></a>Project Svelte：后台优化</h1><hr><p>Project Svelte 在持续改善，以最大程度减少生态系统中一系列 Android 设备中系统和应用使用的 RAM。在 Android 7.0 中，Project Svelte 注重优化在后台中运行应用的方式。</p><p>后台处理是大多数应用的一个重要部分。处理得当，可让您实现非常棒的用户体验 — 即时、快速和情境感知。如果处理不得当，后台处理会毫无必要地消耗 RAM（和电池），同时影响其他应用的系统性能。</p><p>自 Android 5.0 发布以来，<code>JobScheduler</code> 已成为执行后台工作的首选方式，其工作方式有利于用户。应用可以在安排作业的同时允许系统基于内存、电源和连接情况进行优化。<code>JobScheduler</code> 可实现控制和简洁性，我们想要所有应用都使用它。</p><p>另一个非常好的选择是 <code>GCMNetworkManager</code>（Google Play 服务的一部分），其在旧版 Android 中提供类似的作业安排和兼容性。</p><p>我们在继续扩展 <code>JobScheduler</code> 和 <code>GCMNetworkManager</code>，以符合多个用例 — 例如，在 Android 7.0 中，现在，您可以基于内容提供程序中的更改安排后台工作。同时，我们开始弃用一些较旧的模式，这些模式会降低系统性能，特别是低内存设备的系统性能。</p><p>在 Android 7.0 中，我们删除了三个常用隐式广播 — <code>CONNECTIVITY_ACTION</code>、<code>ACTION_NEW_PICTURE</code> 和<code>ACTION_NEW_VIDEO</code> — 因为这些广播可能会一次唤醒多个应用的后台进程，同时会耗尽内存和电池。如果您的应用收到这些广播，请充分利用 Android 7.0 以迁移到 JobScheduler 和相关的 API。</p><p>如需了解详情，请查看<a href="https://developer.android.com/preview/features/background-optimization.html" target="_blank" rel="noopener">后台优化</a>文档。</p><h1 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h1><hr><p>Android 7.0 可同步移动到 <code>SurfaceView</code> 类，此类在某些情况下提供的电池性能优于 <code>TextureView</code>：在渲染视频或 3D 内容时，包含滚动和动画视频位置的应用在使用 <code>SurfaceView</code> 时比 <code>TextureView</code> 耗电更少。</p><p><code>SurfaceView</code> 类可减少屏幕合成对电池的消耗，因为它是在专用硬件中合成，与应用窗口内容分隔开。因此，它产生的中间副本少于 TextureView。<br>现在，<code>SurfaceView</code> 对象的内容位置和包含的应用内容同步更新。这一变化导致的一个结果是，在画面移动时，SurfaceView 中播放的视频的简单的平移或缩放不再在画面侧面产生黑条。</p><p>从 Android 7.0 开始，我们强烈建议您使用 <code>SurfaceView</code> 代替 <code>TextureView</code>，以实现省电。</p><h1 id="流量节省程序"><a href="#流量节省程序" class="headerlink" title="流量节省程序"></a>流量节省程序</h1><hr><p style="overflow:hidden"><br><img src="/2016/12/30/android-7-0/datasaver.png" style="width:50%;float:left;margin-right:40px"><br><span style="font-size:14px"><br>在移动设备的整个生命周期，移动数据网络计划的成本通常会超出设备本身的成本。对于许多用户而言，移动数据网络是他们想要节省的昂贵资源。<br><br><br>Android 7.0 推出了流量节省模式，这是一项新的系统服务，有助于减少应用使用的移动数据网络，无论是在漫游，账单周期即将结束，还是使用少量的预付费数据包。流量节省程序让用户可以控制应用使用移动数据网络的方式，同时让开发者打开流量节省程序时可以提供更多有效的服务。<br><br><br>用户在 Settings 中启用流量节省程序且设备位于按流量计费的网络上时，系统屏蔽后台流量消耗，同时指示应用在前台尽可能使用较少的流量 — 例如，通过限制用于流媒体服务的比特率、降低图像质量、延迟最佳的预缓冲等方法来实现。用户可以将特定应用加入白名单以允许后台按流量计费的流量消耗，即使在打开流量节省程序时也是如此。<br><br><br>Android 7.0 扩展了 ConnectivityManager，以便为应用检索用户的流量节省程序首选项并监控首选项变更提供一种方式。所有应用均应检查用户是否已启用流量节省程序并努力限制前台和后台流量消耗。<br></span><br></p><h1 id="Vulkan-API"><a href="#Vulkan-API" class="headerlink" title="Vulkan API"></a>Vulkan API</h1><hr><p>Android 7.0 将一项新的 3D 渲染 API <a href="http://www.khronos.org/vulkan" target="_blank" rel="noopener">Vulkan™</a> 集成到平台中。就像 <a href="https://www.khronos.org/opengles/" target="_blank" rel="noopener">OpenGL™</a> ES 一样，Vulkan 是 3D 图形和渲染的一项开放标准，由 Khronos Group 维护。</p><p>Vulkan 是完全从零开始设计，以最小化驱动器中的 CPU 开销，并能让您的应用更直接地控制 GPU 操作。Vulkan 还允许多个线程同时执行工作，如命令缓冲区构建，以获得更好的并行化。</p><p>Vulkan 开发工具和库都已卷入 Android 7.0DK。它们包括：</p><ul><li>标头</li><li>验证层（调试库）</li><li>SPIR-V 着色程序编译器</li><li>SPIR-V 运行时着色器编译库</li></ul><p>Vulkan 仅适用于已启用 Vulkan 硬件的设备上的应用，如 Nexus 5X、Nexus 6P 和 Nexus Player。我们正在与合作伙伴密切合作，以尽快使 Vulkan 能面向更多的设备。</p><p>如需了解详细信息，请参阅 <a href="https://developer.android.com/ndk/guides/graphics/index.html" target="_blank" rel="noopener">API 文档</a>。</p><h1 id="Quick-Settings-Tile-API"><a href="#Quick-Settings-Tile-API" class="headerlink" title="Quick Settings Tile API"></a>Quick Settings Tile API</h1><hr><p><img src="/2016/12/30/android-7-0/quicksettings.png" style="width:260px; float:right; margin-left:20px"></p><p>“快速设置”通常用于直接从通知栏显示关键设置和操作，非常简单。在 Android 7.0 中，我们已扩展“快速设置”的范围，使其更加有用更方便。</p><p>我们为额外的“快速设置”图块添加了更多空间，用户可以通过向左或向右滑动跨分页的显示区域访问它们。我们还让用户可以控制显示哪些“快速设置”图块以及显示的位置 — 用户可以通过拖放图块来添加或移动图块。</p><p>对于开发者，Android 7.0 还添加了一个新的 API，从而让您可以定义自己的“快速设置”图块，使用户可以轻松访问您应用中的关键控件和操作。</p><p>对于急需或频繁使用的控件和操作，保留“快速设置”图块，且不应将其用作启动应用的快捷方式。</p><p>定义图块后，您可以将它们显示给用户，用户可通过拖放将图块添加到“快速设置”。</p><p>如需了解有关创建应用图块的信息，请参阅可下载的 API 参考中的文件 android.service.quicksettings.Tile。</p><h1 id="号码屏蔽"><a href="#号码屏蔽" class="headerlink" title="号码屏蔽"></a>号码屏蔽</h1><hr><p>Android 7.0 现在支持在平台中进行号码屏蔽，提供框架 API，让服务提供商可以维护屏蔽的号码列表。默认短信应用、默认手机应用和运营商应用可以对屏蔽的号码列表进行读取和写入操作。其他应用则无法访问此列表。</p><p>通过使号码屏蔽成为平台的标准功能，Android 为应用提供一致的方式来支持广泛的设备上的号码屏蔽。应用可以利用的其他优势包括：</p><ul><li>还会屏蔽已屏蔽的来电号码发出的短信</li><li>通过 Backup &amp; Restore（备份和还原）功能可以跨重置和设备保留屏蔽的号码</li><li>多个应用可以使用相同的屏蔽号码列表</li></ul><p>此外，通过 Android 的运营商应用集成表示运营商可以读取设备上屏蔽的号码列表，并为用户执行服务端屏蔽，以阻止不需要的来电和短信通过任何介质（如 VOIP 端点或转接电话）到达用户。</p><p>如需了解详细信息，请参阅可下载的 <a href="https://developer.android.com/preview/setup-sdk.html#docs-dl" target="_blank" rel="noopener">API 参考</a>中的 <code>android.provider.BlockedNumberContract</code>。</p><h1 id="来电过滤"><a href="#来电过滤" class="headerlink" title="来电过滤"></a>来电过滤</h1><hr><p>Android 7.0 允许默认的手机应用过滤来电。手机应用执行此操作的方式是实现新的 <code>CallScreeningService</code>，该方法允许手机应用基于来电的 <code>Call.Details</code> 执行大量操作，例如：</p><ul><li>拒绝来电</li><li>不允许来电到达通话记录</li><li>不向用户显示来电通知</li></ul><p>如需了解详细信息，请参阅可下载的 <a href="https://developer.android.com/preview/setup-sdk.html#docs-dl" target="_blank" rel="noopener">API 参考</a>中的 <code>android.telecom.CallScreeningService</code>。</p><h1 id="多语言区域支持，更多语言"><a href="#多语言区域支持，更多语言" class="headerlink" title="多语言区域支持，更多语言"></a>多语言区域支持，更多语言</h1><hr><p>Android 7.0 现在允许用户在设置中选择多个语言区域，以更好地支持双语用例。应用可以使用新的 API 获取用户选择的语言区域，然后为多区域设置用户提供更成熟的用户体验 — 如以多个语言显示搜索结果，并且不会以用户了解的语言翻译网页。</p><p>除多语言区域支持外，Android 7.0 还扩展了用户可用的语言范围。它针对常用语言提供超过 25 种的变体，如英语、西班牙语、法语和阿拉伯语。它还针对 100 多种新语言添加了部分支持。</p><p>应用可以通过调用 <code>LocaleList.GetDefault()</code> 获取用户设置的语言区域列表。为支持扩展的语言区域数量，Android 7.0 正在改变其解析资源的方式。请务必使用新的资源解析逻辑测试和验证您的应用是否能如期运行。</p><p>要了解新资源解析行为和应遵循的最佳做法，请参阅<a href="https://developer.android.com/preview/features/multilingual-support.html" target="_blank" rel="noopener">多语言支持</a>。</p><h1 id="新增的表情符号"><a href="#新增的表情符号" class="headerlink" title="新增的表情符号"></a>新增的表情符号</h1><hr><p>Android 7.0 引入更多表情符号和表情符号相关功能，包括肤色表情符号和支持变量选择符。如果您的应用支持表情符号，请遵循以下准则，以便能充分利用这些表情符号相关功能优势。</p><ul><li><strong>在插入之前，检查设备是否包含表情符号。</strong>要检查系统字体中有哪些表情符号，使用 <code>hasGlyph(String)</code> 方法。</li><li><strong>检查表情符号是否支持变量选择符。</strong>变量选择符使您能够呈现一些彩色或黑白的表情符号。在移动设备上，应用应呈现彩色的表情符号，而不是黑白的。但是，如果您的应用显示嵌入在文本中的表情符号，那应使用黑白变量。要确定表情符号是否有变量，使用变量选择符。如需有关支持变量的字符的完整清单，请参阅<a href="http://www.unicode.org/Public/9.0.0/ucd/StandardizedVariants-9.0.0d1.txt" target="_blank" rel="noopener">变量的 Unicode 文档</a>中的表情符号变量序列部分。</li><li><strong>检查表情符号是否支持肤色。</strong>Android 7.0 允许用户按照他们的喜好修改表情符号呈现的肤色。键盘应用应为有多个肤色的表情符号提供可视化的指示，并应允许用户选择他们喜欢的肤色。要确定哪些系统表情符号有肤色修改器，使用 <code>hasGlyph(String)</code> 方法。您可以通过读取 Unicode 文档来确定哪些表情符号使用肤色。<h1 id="Android-中的-ICU4J-API"><a href="#Android-中的-ICU4J-API" class="headerlink" title="Android 中的 ICU4J API"></a>Android 中的 ICU4J API</h1></li></ul><hr><p>Android 7.0 目前在 Android 框架（位于 android.icu 软件包下）中提供 <code>ICU4J</code> API 的子集。迁移很简单，主要是需要从 com.java.icu 命名空间更改为 android.icu。如果您已在您的应用中使用 ICU4J 捆绑包，切换到 Android 框架中提供的 android.icu API 可以大量节省 APK 大小。</p><p>要详细了解 Android ICU4J API，请参阅 <a href="https://developer.android.com/preview/features/icu4j-framework.html" target="_blank" rel="noopener">ICU4J 支持</a>。</p><h1 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h1><hr><h2 id="Chrome-和-WebView-配合使用"><a href="#Chrome-和-WebView-配合使用" class="headerlink" title="Chrome 和 WebView 配合使用"></a>Chrome 和 WebView 配合使用</h2><p>从 Android 7.0 及更高版本中的 Chrome 版本 51 开始，您的设备中的 Chrome APK 用于提供和渲染 Android 系统 WebView。这种方法改善了设备本身的内存使用率，同时减少保持 WebView 更新所需的带宽（因为只要保持启用 Chrome，单机版 WebView APK 将不再进行更新）。</p><p>您可以启用开发者选项和选择 WebView 实现，选择您的 WebView 提供商。您可以使用设备上安装的任何兼容的 Chrome 版本（Dev、Beta 或 Stable）或单机版 Webview APK，作为 WebView 实现。</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>从 Android 7.0 中的 Chrome 版本 51 开始，WebView 将开发者选项“多进程 WebView”被启用时，在一个单独的沙盒进程中运行网页内容。</p><p>我们正在寻求关于 N 中的兼容性和运行时性能的反馈，并随后将在未来 Android 版本中启用多进程 WebView。在这个版本中，可预期启动时间回归、总内存使用和软件渲染性能。</p><p>如果您在多进程模式中遇到意外问题，请告诉我们。请通过 Chromium 错误跟踪程序联系 WebView 团队。</p><h2 id="Javascript-在页面加载之前运行"><a href="#Javascript-在页面加载之前运行" class="headerlink" title="Javascript 在页面加载之前运行"></a>Javascript 在页面加载之前运行</h2><p>从以 Android 7.0 为目标平台的应用开始，JavaScript 上下文会在加载新页面时重置。目前，新 WebView 实例中加载的第一个页面会继承上下文。</p><p>想要在 WebView 中注入 Javascript 的开发者应在页面开始加载后执行脚本。</p><h2 id="不安全起点上的地理定位"><a href="#不安全起点上的地理定位" class="headerlink" title="不安全起点上的地理定位"></a>不安全起点上的地理定位</h2><p>从以 Android 7.0 为目标平台的应用开始，地理定位 API 将仅在安全的起点（通过 HTTPS）上被允许。此政策的目的是在用户使用不安全连接时保护他们的私人信息。</p><h2 id="测试-WebView-测试版"><a href="#测试-WebView-测试版" class="headerlink" title="测试 WebView 测试版"></a>测试 WebView 测试版</h2><p>WebViewis 定期更新，因此我们建议您经常使用 WebView 的测试版本测试应用的兼容性。要在 Android 7.0 上着手测试 WebView 的预发布版本，请下载并安装 Chrome Dev 或 Chrome 测试版，然后按上述说明在开发者选项下面选择它作为 WebView 实现。请通过 Chromium 错误跟踪程序报告问题，以便我们可以在发布新的 WebView 版本前修复问题。</p><p>如果您遇到其他任何问题，可随时通过我们的 G+ 社区与 WebView 团队联系。</p><h1 id="OpenGL™-ES-3-2-API"><a href="#OpenGL™-ES-3-2-API" class="headerlink" title="OpenGL™ ES 3.2 API"></a>OpenGL™ ES 3.2 API</h1><hr><p>Android 7.0 添加了框架接口和对 OpenGL ES 3.2 的平台支持，包括：</p><ul><li>来自 <a href="https://www.khronos.org/registry/gles/extensions/ANDROID/ANDROID_extension_pack_es31a.txt" target="_blank" rel="noopener">Android 扩展包</a> (AEP) 的所有扩展（EXT_texture_sRGB_decode 除外）。</li><li>针对 HDR 的浮点帧缓冲和延迟着色。</li><li>BaseVertex 绘图调用可实现更好的批处理和流媒体服务。</li><li>强大的缓冲区访问控制可减少 WebGL 开销。</li></ul><p>Android 7.0 上适用于 OpenGL ES 3.2 的框架 API 与 GLES32 类一起提供。使用 OpenGL ES 3.2 时，请务必通过 <code>&lt;uses-feature&gt;</code> 标记和 <code>android:glEsVersion</code> 属性在您的清单文件中声明要求。</p><p>如需了解有关使用 OpenGL ES 的信息，包括如何在运行时检查设备支持的 OpenGL ES 版本，请参阅 OpenGL ES API 指南。</p><h1 id="Android-TV-录制"><a href="#Android-TV-录制" class="headerlink" title="Android TV 录制"></a>Android TV 录制</h1><hr><p>Android 7.0 通过新的录制 API 添加了从 Android TV 输入服务录制和播放内容的功能。构建在现有时移 API 之上，TV 输入服务可以控制能够录制的渠道数据、保存录制的会话的方式，同时可通过录制的内容管理用户交互。</p><p>如需了解详细信息，请参阅 <a href="https://developer.android.com/preview/features/tv-recording-api.html" target="_blank" rel="noopener">Android TV Recording API</a>。</p><h1 id="Android-for-Work"><a href="#Android-for-Work" class="headerlink" title="Android for Work"></a>Android for Work</h1><hr><p>Android for Work 针对运行 Android 7.0 的设备添加了许多新功能和 API。部分重要内容如下— 有关变更的完整列表，请参阅 <a href="https://developer.android.com/preview/features/afw.html" target="_blank" rel="noopener">Android for Work 更新</a>。</p><h2 id="工作资料安全性挑战"><a href="#工作资料安全性挑战" class="headerlink" title="工作资料安全性挑战"></a>工作资料安全性挑战</h2><p>面向 N SDK 的配置文件所有者可以为在工作资料中运行的应用指定单独的安全性挑战。当用户尝试打开任何工作应用时将显示工作挑战。成功完成安全性挑战可解锁工作资料并将其解密（如果需要）。对于配置文件所有者，<code>ACTION_SET_NEW_PASSWORD</code> 提示用户设置工作挑战，<code>ACTION_SET_NEW_PARENT_PROFILE_PASSWORD</code> 提示用户设置设备锁。</p><p>配置文件所有者可以使用 <code>setPasswordQuality()</code>、<code>setPasswordMinimumLength()</code> 和相关方法针对工作挑战设置不同的密码策略（例如，PIN 码必须多长，或是否可以使用指纹解锁配置文件）。配置文件所有者还可以使用新的 <code>getParentProfileInstance()</code> 方法返回的 <code>DevicePolicyManager</code> 实例设置设备锁定。此外，配置文件所有者可以使用新的 <code>setOrganizationColor()</code> 和 <code>setOrganizationName()</code> 方法针对工作挑战自定义凭据屏幕。</p><h2 id="关闭工作"><a href="#关闭工作" class="headerlink" title="关闭工作"></a>关闭工作</h2><p>在有工作资料的设备上，用户可以切换工作模式。工作模式关闭时，管理的用户临时关闭，其停用托管工作资料应用、后台同步和通知。这包括配置文件所有者应用。关闭工作模式时，系统显示永久状态图标，以提醒用户他们无法启动工作应用。启动器指示该工作应用和小部件无法访问。</p><h2 id="Always-on-VPN"><a href="#Always-on-VPN" class="headerlink" title="Always on VPN"></a>Always on VPN</h2><p>设备所有者和配置文件所有者可以确保工作应用始终通过指定的 VPN 连接。系统在设备启动后自动启动该 VPN。</p><p>新的 <code>DevicePolicyManager</code> 方法为 <code>setAlwaysOnVpnPackage()</code> 和 <code>getAlwaysOnVpnPackage()</code>。</p><p>由于 VPN 服务无需应用交互即可由系统直接绑定，因此，VPN 客户端必须针对 Always on VPN 处理新的入口点。和以前一样，由与操作 <code>android.net.VpnService</code> 匹配的 intent 过滤器将服务指示给系统。</p><p>用户还可以使用 <strong>Settings&gt;More&gt;Vpn</strong> 手动设置实现 <code>VPNService</code> 方法的 Always on VPN 客户端。通过“设置”启用 Always on VPN 的选项仅在 VPN 客户端以 API 级别 24 为目标时可用。</p><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>应用可以用企业颜色和徽标来自定义配置文件所有者和设备所有者配置流程。<code>DevicePolicyManager.EXTRA_PROVISIONING_MAIN_COLOR</code> 自定义流程颜色。<code>DevicePolicyManager.EXTRA_PROVISIONING_LOGO_URI</code> 用企业徽标自定义流程。</p><h1 id="无障碍增强功能"><a href="#无障碍增强功能" class="headerlink" title="无障碍增强功能"></a>无障碍增强功能</h1><hr><p>Android 7.0 现在针对新的设备设置直接在欢迎屏幕上提供“Vision Settings”。这使用户可以更容易发现和配置他们设备上的无障碍功能，包括放大手势、字体大小、显示屏尺寸和话语提示。</p><p>随着这些无障碍功能更为突出，在启用这些功能后，您的用户更可能试用您的应用。请务必提前启用这些设置测试您的应用。您可以通过 Settings &gt; Accessibility 启用它们。</p><p>还是在 Android 7.0 中，无障碍服务现在可以帮助具有动作障碍的用户触摸屏幕。全新的 API 允许使用人脸追踪、眼球追踪、点扫描等功能构建服务，以满足这些用户的需求。</p><p>如需了解详细信息，请参阅可下载的 <a href="https://developer.android.com/preview/setup-sdk.html#docs-dl" target="_blank" rel="noopener">API 参考</a>中的 <code>android.accessibilityservice.GestureDescription</code>。</p><h1 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h1><hr><p>直接启动可以缩短设备启动时间，让注册的应用具有有限的功能，即使在意外重启后。例如，如果当用户睡觉时加密的设备重启，那么注册的警报、消息和来电现在可以和往常一样继续通知用户。这也意味着重启后无障碍服务会立即可用。</p><p>在 Android 7.0 中，直接启动充分利用基于文件的加密，以针对系统和应用数据启用细化的加密策略。系统针对选定的系统数据和显式注册的应用数据使用设备加密存储。默认情况下，凭据加密存储可用于所有其他系统数据、用户数据、应用及应用数据。</p><p>启动时，系统在受限的模式中启动，仅访问设备加密数据，不会对应用或数据进行常规访问。如果您有想要在此模式下运行的组件，您可以通过在清单中设置标记注册它们。重启后，系统通过广播 LOCKED_BOOT_COMPLETED intent 激活注册的组件。系统确保注册的设备加密的应用数据在解锁前可用。所有其他数据在用户确认锁定屏幕凭据进行解密前均不可用。</p><p>如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/direct-boot.html" target="_blank" rel="noopener">直接启动</a>。</p><h1 id="密钥认证"><a href="#密钥认证" class="headerlink" title="密钥认证"></a>密钥认证</h1><hr><p>Android 7.0 引入密钥认证，这是一个新的安全工具，可帮助您确保设备的硬件支持的密钥库中存储的密钥对适当保护您的应用使用的敏感信息。借助此工具，您可以更加放心地让您的应用与驻留在安全硬件中的密钥交互，即使运行您的应用的设备已被破解 root 权限。如果您在应用中使用硬件支持的密钥库中的密钥，您应使用此工具，尤其当您使用密钥验证应用中的敏感信息时。</p><p>通过密钥认证，您可以在设备的可信执行环境 (TEE) 中验证在设备的硬件支持的密钥库中创建和存储的 RSA 或 EC 密钥对。通过此工具，您还可以使用设备服务，例如您的应用的后端服务器，确定和有效验证密钥对的使用和有效性。这些功能为保护密钥对提供额外的安全级别，即使有人破解设备的 root 权限或损害运行于设备的 Android 平台的安全。</p><blockquote><p><strong>注：</strong>仅少部分运行 Android 7.0 的设备支持硬件级密钥认证；其他所有运行 Android 7.0 的设备则使用软件级密钥认证。在生产级环境中验证设备的硬件支持的密钥之属性前，您应确保设备支持硬件级密钥认证。为此，您应确保认证证书链包含由 Google 认证根密钥签署的根证书，且密钥说明数据结构中的 attestationSecurityLevel 元素设置为 TrustedEnvironment 安全级别。</p></blockquote><p>如需了解详细信息，请参阅密钥认证开发者文档。</p><h1 id="网络安全性配置"><a href="#网络安全性配置" class="headerlink" title="网络安全性配置"></a>网络安全性配置</h1><hr><p>在 Android 7.0 中，通过使用说明性“网络安全性配置”（而不是使用传统的易出错的编程 API（例如，X509TrustManager）），应用可以安全地自定义其安全（HTTPS、TLS）连接的行为，无需任何代码修改。</p><p>支持的功能：</p><ul><li><strong>自定义信任锚。</strong>让应用可以针对安全连接自定义哪些证书颁发机构 (CA) 值得信赖。例如，信任特定的自签署证书或限制应用信任的公共 CA 集。</li><li><strong>仅调试重写。</strong>让应用开发者可以安全调试其应用的安全连接，而不会增加安装基础的风险。</li><li><strong>明文流量选择退出。</strong>让应用可以防止自身意外使用明文流量。</li><li><strong>证书固定。</strong>这是一项高级功能，让应用可以针对安全连接限制哪些服务器密钥受信任。</li></ul><p>如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/security-config.html" target="_blank" rel="noopener">网络安全性配置</a>。</p><h1 id="默认受信任的证书颁发机构"><a href="#默认受信任的证书颁发机构" class="headerlink" title="默认受信任的证书颁发机构"></a>默认受信任的证书颁发机构</h1><hr><p>默认情况下，面向 Android 7.0 的应用仅信任系统提供的证书，且不再信任用户添加的证书颁发机构 (CA)。如果面向 Android N 的应用希望信任用户添加的 CA，则应使用<a href="https://developer.android.com/preview/features/security-config.html" target="_blank" rel="noopener">网络安全性配置</a>以指定信任用户 CA 的方式。</p><h1 id="APK-signature-scheme-v2"><a href="#APK-signature-scheme-v2" class="headerlink" title="APK signature scheme v2"></a>APK signature scheme v2</h1><hr><p>Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。</p><p>虽然我们建议您对您的应用采用 APK Signature Scheme v2，但这项新方案并非强制性的。如果您的应用在使用 APK Signature Scheme v2 时不能正确开发，您可以停用这项新方案。禁用过程会导致 Android Studio 2.2 和 Android Plugin for Gradle 2.2 仅使用传统签名方案来签署您的应用。要仅用传统方案签署，打开模块级 <code>build.gradle</code> 文件，然后将行 v2SigningEnabled false 添加到您的版本签名配置中：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  defaultConfig &#123; ... &#125;</span><br><span class="line">  signingConfigs &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">      storeFile <span class="keyword">file</span>(<span class="string">"myreleasekey.keystore"</span>)</span><br><span class="line">      storePassword <span class="string">"password"</span></span><br><span class="line">      keyAlias <span class="string">"MyReleaseKey"</span></span><br><span class="line">      keyPassword <span class="string">"password"</span></span><br><span class="line">      v2SigningEnabled <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：</strong>如果您使用 APK Signature Scheme v2 签署您的应用，并对应用进行了进一步更改，则应用的签名将无效。出于这个原因，请在使用 APK Signature Scheme v2 签署您的应用之前、而非之后使用 zipalign 等工具。</p></blockquote><p>如需了解详细信息，请阅读相关的 Android Studio 文档，这些文档介绍了如何在 Android Studio 中签署应用以及如何使用 Android Plugin for Gradle <a href="https://developer.android.com/studio/build/build-variants.html#signing" target="_blank" rel="noopener">为签署应用配置构建文件</a>。</p><h1 id="作用域目录访问"><a href="#作用域目录访问" class="headerlink" title="作用域目录访问"></a>作用域目录访问</h1><hr><p>在 Android 7.0 中，应用可以使用新的 API 请求访问特定的外部存储目录，包括可移动媒体上的目录，如 SD 卡。新 API 大大简化了应用访问标准外部存储目录的方式，如 Pictures 目录。应用（如照片应用）可以使用这些 API（而不是使用 READ_EXTERNAL_STORAGE），其授予所有存储目录的访问权限或存储访问框架，从而让用户可以导航到目录。</p><p>此外，新的 API 简化了用户向应用授予外部存储访问权限的步骤。当您使用新的 API 时，系统使用一个简单的权限 UI，其清楚地详细介绍应用正在请求访问的目录。</p><p>如需了解详细信息，请参阅作用域目录访问开发者文档。</p><h1 id="键盘快捷键辅助工具"><a href="#键盘快捷键辅助工具" class="headerlink" title="键盘快捷键辅助工具"></a>键盘快捷键辅助工具</h1><hr><p>在 Android 7.0 中，用户可以按“Meta + /”触发“键盘快捷键”屏幕，它会显示的系统和对焦的应用中可用的所有快捷键。如果快捷键存在，系统自动从应用菜单检索这些快捷键。您也可以为屏幕提供微调的快捷键列表。您可以通过重写新 Activity.onProvideKeyboardShortcuts() 的方法来进行这项操作，如可下载的 API 参考中所述。</p><blockquote><p><strong>注：</strong>所有键盘都没有 Meta 键：在 Macintosh 键盘上，它是 Command 键；在 Windows 键盘上，它是 Windows 键；而在 Pixel C 和 Chrome 操作系统键盘上，它是 Search 键。</p></blockquote><p>要在您的应用的任何地方触发键盘快捷键辅助工具，为相关 Activity 调用 Activity.requestKeyboardShortcutsHelper()。</p><h1 id="Custom-Pointer-API"><a href="#Custom-Pointer-API" class="headerlink" title="Custom Pointer API"></a>Custom Pointer API</h1><hr><p>Android 7.0 引入 Custom Pointer API，以便您可以自定义指针的外观、 可见性和行为。此功能在用户使用鼠标或触控板与 UI 对象交互尤为有用。默认指针使用标准图标。此 API 还包含多种高级功能，例如根据鼠标或触控板特定移动情况改变指针图标外观。</p><p>要设置指针图标，请替换 View 类的 onResolvePointerIcon() 方法。此方法使用 PointerIcon 对象绘制与特定移动事件对应的图标。</p><h1 id="Sustained-Performance-API"><a href="#Sustained-Performance-API" class="headerlink" title="Sustained Performance API"></a>Sustained Performance API</h1><hr><p>长期运行的应用的性能可能会显著波动，因为系统会阻止系统芯片在设备组件达到温度限制时启动。这种波动是建立高性能长期运行应用的应用开发者的移动目标。</p><p>为解决这些限制，Android 7.0 包括了对持续性能模式的支持，帮助原始设备制造商 (OEM) 提供关于长期运行应用的设备性能能力的提示。应用开发者可以使用这些提示来根据可预测的一致设备性能水平调整长期应用。</p><p>应用开发者只能在 Nexus 6P 设备的 Android 7.0 中尝试这款新 API。要使用此功能，为您希望以持续性能模式运行的窗口设置持续性能窗口标记。使用 Window.setSustainedPerformanceMode() 方法设置此标记。当窗口不再对焦时，系统会自动停用此模式。</p><h1 id="VR-支持"><a href="#VR-支持" class="headerlink" title="VR 支持"></a>VR 支持</h1><hr><p>Android 7.0 添加了新的 VR 模式的平台支持和优化，以使开发者能为用户打造高质量移动 VR 体验。增加了一些性能增强特性，包括允许 VR 应用访问某个专属的 CPU 核心。在您的应用中，您可以充分利用到专为 VR 设计的智能头部跟踪和立体声通知功能。最重要的是，Android 7.0 的图形延时非常低。如需了解有关开发面向 Android 7.0 的 VR 应用的完整信息，请参阅<a href="https://developers.google.com/vr/android/" target="_blank" rel="noopener">面向 Android 的 Google VR SDK</a>。</p><h1 id="打印服务增强"><a href="#打印服务增强" class="headerlink" title="打印服务增强"></a>打印服务增强</h1><hr><p>在 Android 7.0 中，打印服务开发者现在可以公开关于个别打印机和打印作业的其他信息。</p><p>在列出各打印机时，打印服务现在可以通过两种方式来设置按打印机的图标：</p><ul><li>您可以通过调用 PrinterInfo.Builder.setResourceIconId() 设置源于资源 ID 的图标</li><li>您可以通过调用 PrinterInfo.Builder.setHasCustomPrinterIcon()，并针对使用 android.printservice.PrinterDiscoverySession.onRequestCustomPrinterIcon() 请求图标的情况设置回调来显示源自网络的图标</li></ul><p>此外，您还可以通过调用 PrinterInfo.Builder.setInfoIntent() 提供按打印机活动，以显示其他信息。</p><p>您可以通过分别调用 android.printservice.PrintJob.setProgress() 和 android.printservice.PrintJob.setStatus() 在打印任务通知中指示打印任务的进度和状态。</p><p>如需了解有关这些方法的详细信息，请参阅可下载的 <a href="https://developer.android.com/preview/setup-sdk.html#docs-dl" target="_blank" rel="noopener">API 参考</a>。</p><h1 id="FrameMetricsListener-API"><a href="#FrameMetricsListener-API" class="headerlink" title="FrameMetricsListener API"></a>FrameMetricsListener API</h1><hr><p>FrameMetricsListener API 允许应用监测它的 UI 渲染性能。API 通过公开流式传输 Pub/Sub API 来提供此能力，以传递应用当前窗口的帧计时信息。返回的数据相当于 adb shell dumpsys gfxinfo framestats 显示的数据，但不限定于在过去的 120 帧内。</p><p>您可以使用 <code>FrameMetricsListener</code> 来衡量生产中的交互级 UI 性能，无需 USB 连接。此 API 允许在比 adb shell dumpsys gfxinfo 更高的粒度上收集数据。因为系统可以从应用中的特定交互中收集数据，因此更高的粒度变得可行；系统不需要采集关于完整应用性能的全局概要或清除任何全局状态。您可以使用这种能力来针对应用的真实使用案例收集性能数据和捕捉 UI 性能回归。</p><p>要监测一个窗口，实现 <code>FrameMetricsListener.onMetricsAvailable()</code> 回调方法，并在窗口上注册。如需了解详细信息，请参阅可下载的 API 参考中的 FrameMetricsListener 类文档。</p><p>API 提供了一个包含计时数据的 <code>FrameMetrics</code> 对象，其渲染子系统会在一帧长度内报告各种里程碑。支持的指标有：<code>UNKNOWN_DELAY_DURATION</code>、<code>INPUT_HANDLING_DURATION</code>、<code>ANIMATION_DURATION</code>、<code>LAYOUT_MEASURE_DURATION</code>、<code>DRAW_DURATION</code>、 <code>SYNC_DURATION</code>、<code>COMMAND_ISSUE_DURATION</code>、<code>SWAP_BUFFERS_DURATION</code>、<code>TOTAL_DURATION</code> 和 <code>FIRST_DRAW_FRAME</code>。</p><h1 id="虚拟文件"><a href="#虚拟文件" class="headerlink" title="虚拟文件"></a>虚拟文件</h1><hr><p>在较早的 Android 版本中，您的应用可以使用存储访问框架来允许用户从他们的云存储帐户中选择文件，如 Google Drive。但是，不能表示没有直接字节码表示的文件；每个文件都必须提供一个输入流。</p><p>Android 7.0 在存储访问框架中添加了虚拟文件的概念。虚拟文件功能可以让您的 <code>DocumentsProvider</code> 返回可与 <code>ACTION_VIEW</code> intent 使用的文件 URI，即使它们没有直接字节码表示。Android 7.0 还允许您为用户文件（虚拟或其他类）提供备用格式。</p><p>为获得您的应用中的虚拟文件的 URI，首先您应创建一个 Intent 以打开文件选择器 UI。由于应用不能使用 <code>openInputStream()</code> 方法来直接打开一个虚拟文件，因此如果您包括了 CATEGORY_OPENABLE 类别，您的应用不会收到任何虚拟文件。</p><p>在用户选择之后，系统调用 <code>onActivityResult()</code> 方法。您的应用可以检索虚拟文件的 URI，并得到一个输入流，这表现在以下片段中的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Other Activity code ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span> REQUEST_CODE = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We listen to the OnActivityResult event to respond to the user's selection.</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">    Intent resultData)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE &amp;&amp;</span><br><span class="line">            resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line"></span><br><span class="line">            Uri uri = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (resultData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                uri = resultData.getData();</span><br><span class="line"></span><br><span class="line">                ContentResolver resolver = getContentResolver();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Before attempting to coerce a file into a MIME type,</span></span><br><span class="line">                <span class="comment">// check to see what alternative MIME types are available to</span></span><br><span class="line">                <span class="comment">// coerce this file into.</span></span><br><span class="line">                String[] streamTypes =</span><br><span class="line">                  resolver.getStreamTypes(uri, <span class="string">"*/*"</span>);</span><br><span class="line"></span><br><span class="line">                AssetFileDescriptor descriptor =</span><br><span class="line">                    resolver.openTypedAssetFileDescriptor(</span><br><span class="line">                        uri,</span><br><span class="line">                        streamTypes[<span class="number">0</span>],</span><br><span class="line">                        <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Retrieve a stream to the virtual file.</span></span><br><span class="line">                InputStream inputStream = descriptor.createInputStream();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        Log.e(<span class="string">"EXCEPTION"</span>, <span class="string">"ERROR: "</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>如需了解有关访问用户文件的详细信息，请参阅存储访问框架指南。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 7.0 Nougat 为用户和开发者引入多种新功能。本文重点介绍面向开发者的新功能。&lt;/p&gt;
&lt;p&gt;请务必查阅 Android 7.0 行为变更以了解平台变更可能影响您的应用的领域。&lt;/p&gt;
&lt;p&gt;要详细了解 Android 7.0 的消费者功能，请访问 &lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
      <category term="Nougat" scheme="http://yoursite.com/tags/Nougat/"/>
    
      <category term="Android 7.0" scheme="http://yoursite.com/tags/Android-7-0/"/>
    
  </entry>
  
  <entry>
    <title>Android 6.0 变更</title>
    <link href="http://yoursite.com/2016/05/12/android-6-0-changes/"/>
    <id>http://yoursite.com/2016/05/12/android-6-0-changes/</id>
    <published>2016-05-12T11:56:45.000Z</published>
    <updated>2018-04-10T01:33:55.366Z</updated>
    
    <content type="html"><![CDATA[<p>Android 6.0（API 级别 23）除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。</p><p>如果您之前发布过 Android 应用，请注意您的应用可能受到这些平台变更的影响。</p><h1 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h1><hr><p>此版本引入了一种新的权限模式，如今，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，同时为应用开发者精简了安装和自动更新过程。用户可为所安装的各个应用分别授予或撤销权限。</p><p>对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。要确定您的应用是否已被授予权限，请调用新增的 <code>checkSelfPermission()</code> 方法。要请求权限，请调用新增的 <code>requestPermissions()</code> 方法。即使您的应用并不以 Android 6.0（API 级别 23）为目标平台，您也应该在新权限模式下测试您的应用。</p><p>如需了解有关在您的应用中支持新权限模式的详情，请参阅<a href="https://developer.android.com/training/permissions/index.html" target="_blank" rel="noopener">使用系统权限</a>。如需了解有关如何评估新模式对应用的影响的提示，请参阅<a href="https://developer.android.com/training/permissions/best-practices.html#testing" target="_blank" rel="noopener">权限最佳做法</a>。</p><h1 id="低电耗模式和应用待机模式"><a href="#低电耗模式和应用待机模式" class="headerlink" title="低电耗模式和应用待机模式"></a>低电耗模式和应用待机模式</h1><hr><p>此版本引入了针对空闲设备和应用的最新节能优化技术。这些功能会影响所有应用，因此请务必在这些新模式下测试您的应用。</p><ul><li><strong>低电耗模式：</strong>如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。</li><li><strong>应用待机模式：</strong>应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业。<br>要详细了解这些节能变更，请参阅<a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="noopener">对低电耗模式和应用待机模式进行针对性优化</a>。</li></ul><h1 id="取消支持-Apache-HTTP-客户端"><a href="#取消支持-Apache-HTTP-客户端" class="headerlink" title="取消支持 Apache HTTP 客户端"></a>取消支持 Apache HTTP 客户端</h1><hr><p>Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 <code>HttpURLConnection</code> 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 <code>build.gradle</code> 文件中声明以下编译时依赖项：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    useLibrary <span class="string">'org.apache.http.legacy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="BoringSSL"><a href="#BoringSSL" class="headerlink" title="BoringSSL"></a>BoringSSL</h1><hr><p>Android 正在从使用 OpenSSL 库转向使用 BoringSSL 库。如果您要在应用中使用 Android NDK，请勿链接到并非 NDK API 组成部分的加密库，如 libcrypto.so 和 libssl.so。这些库并非公共 API，可能会在不同版本和设备上毫无征兆地发生变化或出现故障。此外，您还可能让自己暴露在安全漏洞的风险之下。请改为修改原生代码，以通过 JNI 调用 Java 加密 API，或静态链接到您选择的加密库。</p><h1 id="硬件标识符访问权"><a href="#硬件标识符访问权" class="headerlink" title="硬件标识符访问权"></a>硬件标识符访问权</h1><hr><p>为给用户提供更严格的数据保护，从此版本开始，对于使用 WLAN API 和 Bluetooth API 的应用，Android 移除了对设备本地硬件标识符的编程访问权。<code>WifiInfo.getMacAddress()</code> 方法和 <code>BluetoothAdapter.getAddress()</code> 方法现在会返回常量值 02:00:00:00:00:00。</p><p>现在，要通过蓝牙和 WLAN 扫描访问附近外部设备的硬件标识符，您的应用必须拥有 <code>ACCESS_FINE_LOCATION</code> 或 <code>ACCESS_COARSE_LOCATION</code> 权限。</p><ul><li>WifiManager.getScanResults()</li><li>BluetoothDevice.ACTION_FOUND</li><li>BluetoothLeScanner.startScan()<blockquote><p><strong>注：</strong>当运行 Android 6.0（API 级别 23）的设备发起后台 WLAN 或蓝牙扫描时，在外部设备看来，该操作的发起来源是一个随机化 MAC 地址。</p></blockquote></li></ul><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><hr><p>此版本移除了 <code>Notification.setLatestEventInfo()</code> 方法。请改用 <code>Notification.Builder</code> 类来构建通知。要重复更新通知，请重复使用 <code>Notification.Builder</code> 实例。调用 <code>build()</code> 方法可获取更新后的 <code>Notification</code> 实例。</p><p><code>adb shell dumpsys notification</code> 命令不再打印输出您的通知文本。请改用 <code>adb shell dumpsys notification --noredact</code> 命令打印输出 notification 对象中的文本。</p><h1 id="音频管理器变更"><a href="#音频管理器变更" class="headerlink" title="音频管理器变更"></a>音频管理器变更</h1><hr><p>不再支持通过 <code>AudioManager</code> 类直接设置音量或将特定音频流静音。<code>setStreamSolo()</code> 方法已弃用，您应该改为调用 <code>requestAudioFocus()</code> 方法。类似地，<code>setStreamMute()</code> 方法也已弃用，请改为调用 <code>adjustStreamVolume()</code> 方法并传入方向值 <code>ADJUST_MUTE</code> 或 <code>ADJUST_UNMUTE</code>。</p><h1 id="文本选择"><a href="#文本选择" class="headerlink" title="文本选择"></a>文本选择</h1><hr><p><img src="/2016/05/12/android-6-0-changes/text-selection.gif" style="width:300px; float: right; margin-left:20px"><br>现在，当用户在您的应用中选择文本时，您可以在一个浮动工具栏中显示“剪切”、“复制”和“粘贴”等文本选择操作。其在用户交互实现上与为单个视图启用上下文操作模式中所述的上下文操作栏类似。</p><p>要实现可用于文本选择的浮动工具栏，请在您的现有应用中做出以下更改：</p><ol><li>在 <code>View</code> 对象或 <code>Activity</code> 对象中，将 <code>ActionMode</code> 调用从 <code>startActionMode(Callback)</code> 更改为 <code>startActionMode(Callback, ActionMode.TYPE_FLOATING)</code>。</li><li>改为使用 <code>ActionMode.Callback</code> 的现有实现扩展 <code>ActionMode.Callback2</code>。</li><li>替代 <code>onGetContentRect()</code> 方法，用于提供 Rect 内容对象（如文本选择矩形）在视图中的坐标。</li><li>如果矩形的定位不再有效，并且这是唯一需要声明为无效的元素，请调用 <code>invalidateContentRect()</code> 方法。</li></ol><p>请注意，如果您使用 Android 支持库 22.2 修订版，浮动工具栏不向后兼容，默认情况下 appcompat 会获得对 <code>ActionMode</code> 对象的控制权。这会禁止显示浮动工具栏。要在 ActionMode 中启用 <code>AppCompatActivity</code> 支持，请调用 <code>getDelegate()</code>，然后对返回的 <code>setHandleNativeActionModesEnabled()</code> 对象调用 <code>AppCompatDelegate</code>，并将输入参数设置为 false。此调用会将 <code>ActionMode</code> 对象的控制权交还给框架。在运行 Android 6.0（API 级别 23）的设备上，框架可以支持 <code>ActionBar</code> 模式或浮动工具栏模式；而在运行 Android 5.1（API 级别 22）或之前版本的设备上，框架仅支持 <code>ActionBar</code> 模式。</p><h1 id="浏览器书签变更"><a href="#浏览器书签变更" class="headerlink" title="浏览器书签变更"></a>浏览器书签变更</h1><hr><p>此版本移除了对全局书签的支持。<code>android.provider.Browser.getAllBookmarks()</code> 和 <code>android.provider.Browser.saveBookmark()</code> 方法现已移除。同样，<code>READ_HISTORY_BOOKMARKS</code> 权限和 <code>WRITE_HISTORY_BOOKMARKS</code> 权限也已移除。如果您的应用以 Android 6.0（API 级别 23）或更高版本为目标平台，请勿从全局提供程序访问书签或使用书签权限。您的应用应改为在内部存储书签数据。</p><h1 id="Android-密钥库变更"><a href="#Android-密钥库变更" class="headerlink" title="Android 密钥库变更"></a>Android 密钥库变更</h1><hr><p>从此版本开始，Android 密钥库提供程序不再支持 DSA。但仍支持 ECDSA。</p><p>停用或重置安全锁定屏幕时（例如，由用户或设备管理员执行此类操作时），系统将不再删除需要闲时加密的密钥，但在上述事件期间会删除需要闲时加密的密钥。</p><h1 id="WLAN-和网络连接变更"><a href="#WLAN-和网络连接变更" class="headerlink" title="WLAN 和网络连接变更"></a>WLAN 和网络连接变更</h1><hr><p>此版本对 WLAN API 和 Networking API 引入了以下行为变更。</p><ul><li>现在，您的应用只能更改由您创建的 <code>WifiConfiguration</code> 对象的状态。系统不允许您修改或删除由用户或其他应用创建的 <code>WifiConfiguration</code> 对象。</li><li>在之前的版本中，如果应用利用带有 disableAllOthers=true 设置的 <code>enableNetwork()</code> 强制设备连接特定 WLAN 网络，设备将会断开与移动数据网络等其他网络的连接。在此版本中，设备不再断开与上述其他网络的连接。如果您的应用的 targetSdkVersion 为 “20” 或更低，则会固定连接所选 WLAN 网络。如果您的应用的 targetSdkVersion 为 “21” 或更高，请使用多网络 API（如 <code>openConnection()</code>、<code>bindSocket()</code> 和新增的 <code>bindProcessToNetwork()</code> 方法）来确保通过所选网络传送网络流量。</li></ul><h1 id="相机服务变更"><a href="#相机服务变更" class="headerlink" title="相机服务变更"></a>相机服务变更</h1><hr><p>在此版本中，相机服务中共享资源的访问模式已从之前的“先到先得”访问模式更改为高优先级进程优先的访问模式。对服务行为的变更包括：</p><ul><li>根据客户端应用进程的“优先级”授予对相机子系统资源的访问权，包括打开和配置相机设备。带有对用户可见 Activity 或前台 Activity 的应用进程一般会被授予较高的优先级，从而使相机资源的获取和使用更加可靠；</li><li>当高优先级的应用尝试使用相机时，系统可能会“驱逐”正在使用相机客户端的低优先级应用。在已弃用的 Camera API 中，这会导致系统为被驱逐的客户端调用 onError()。在 Camera2 API 中，这会导致系统为被驱逐的客户端调用 onDisconnected()；</li><li>在配备相应相机硬件的设备上，不同的应用进程可同时独立打开和使用不同的相机设备。但现在，如果在多进程用例中同时访问相机会造成任何打开的相机设备的性能或能力严重下降，相机服务会检测到这种情况并禁止同时访问。即使并没有其他应用直接尝试访问同一相机设备，此变更也可能导致低优先级客户端被“驱逐”。</li><li>更改当前用户会导致之前用户帐户拥有的应用内活动相机客户端被驱逐。对相机的访问仅限于访问当前设备用户拥有的用户个人资料。举例来说，这意味着，当用户切换到其他帐户后，“来宾”帐户实际上无法让使用相机子系统的进程保持运行状态。</li></ul><h1 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h1><hr><p>ART 运行时环境现在可正确实现 <code>newInstance()</code> 方法的访问规则。此变更修正了之前版本中 Dalvik 无法正确检查访问规则的问题。如果您的应用使用 newInstance() 方法，并且您想重写访问检查，请调用 <code>setAccessible()</code> 方法（将输入参数设置为 true）。如果您的应用使用 v7 appcompat 库或 v7 recyclerview 库，则您必须更新应用以使用这些库的最新版本。否则，请务必更新从 XML 引用的任何自定义类，以便能够访问它们的类构造函数。</p><p>此版本更新了动态链接程序的行为。动态链接程序现在可以识别库的 soname 与其路径之间的差异（公开错误 6670），并且现在已实现了按 soname 搜索。之前包含错误的 DT_NEEDED 条目（通常是开发计算机文件系统上的绝对路径）却仍工作正常的应用，如今可能会出现加载失败。</p><p>现已正确实现 dlopen(3) RTLD_LOCAL 标记。请注意，RTLD_LOCAL 是默认值，因此不显式使用 RTLD_LOCAL 的 dlopen(3) 调用将受到影响（除非您的应用显式使用 RTLD_GLOBAL）。使用 RTLD_LOCAL 时，在随后通过调用 dlopen(3) 加载的库中并不能使用这些符号（这与由 DT_NEEDED 条目引用的情况截然不同）。</p><p>在之前版本的 Android 上，如果您的应用请求系统加载包含文本重定位信息的共享库，系统会显示警告，但仍允许加载共享库。从此版本开始，如果您的应用的目标 SDK 版本为 23 或更高，则系统会拒绝加载该库。为帮助您检测库是否加载失败，您的应用应该记录 dlopen(3) 失败日志，并在日志中加入 dlerror(3) 调用返回的问题描述文本。要详细了解如何处理文本重定位，请参阅此指南。</p><h1 id="APK-验证"><a href="#APK-验证" class="headerlink" title="APK 验证"></a>APK 验证</h1><hr><p>该平台现在执行的 APK 验证更为严格。如果在清单中声明的文件在 APK 中并不存在，该 APK 将被视为已损坏。移除任何内容后必须重新签署 APK。</p><h1 id="USB-连接"><a href="#USB-连接" class="headerlink" title="USB 连接"></a>USB 连接</h1><hr><p>默认情况下，现在通过 USB 端口进行的设备连接设置为仅充电模式。要通过 USB 连接访问设备及其内容，用户必须明确地为此类交互授予权限。如果您的应用支持用户通过 USB 端口与设备进行交互，请将必须显式启用交互考虑在内。</p><h1 id="Android-for-Work-变更"><a href="#Android-for-Work-变更" class="headerlink" title="Android for Work 变更"></a>Android for Work 变更</h1><hr><p>此版本包含下列针对 Android for Work 的行为变更：</p><ul><li><strong>个人上下文中的工作联系人：</strong>Google 拨号器通话记录现在会在用户查看通话记录时显示工作联系人。将 setCrossProfileCallerIdDisabled() 设置为 true 可在 Google 拨号器通话记录中隐藏托管配置文件联系人。仅当您将 setBluetoothContactSharingDisabled() 设置为 false 时，才可以通过蓝牙将工作联系人随个人联系人一起显示给设备。默认情况下，它设置为 true。</li><li><strong>WLAN 配置删除：</strong>现在，当删除某个托管配置文件时，将会移除由配置文件所有者添加的 WLAN 配置（例如，通过调用 addNetwork() 方法添加的配置）。</li><li><strong>WLAN 配置锁定：</strong>如果 WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN 不为零，则用户无法再修改或删除任何由活动设备所有者创建的 WLAN 配置。用户仍可创建和修改其自己的 WLAN 配置。活动设备所有者拥有编辑或删除任何 WLAN 配置（包括并非由其创建的配置）的权限。</li><li><strong>通过添加 Google 帐户下载设备规范控制器：</strong>向托管环境以外的设备添加需要通过设备规范控制器 (DPC) 应用管理的 Google 帐户时，帐户添加流程现在会提示用户安装相应的 WPC。在设备初始设置向导中通过 Settings &gt; Accounts 添加帐户时，也会出现此行为。</li><li><strong>对特定 DevicePolicyManager API 行为的变更：</strong><ul><li>调用 setCameraDisabled() 方法只会影响调用该方法的用户的相机；从托管配置文件调用它不会影响主用户运行的相机应用。</li><li>此外，setKeyguardDisabledFeatures() 方法现在除了可供设备所有者使用外，还可供配置文件所有 者使用。</li><li>配置文件所有者可设置以下键盘锁限制：<pre><code>- KEYGUARD_DISABLE_TRUST_AGENTS 和 KEYGUARD_DISABLE_FINGERPRINT，它们影响配置文件上级用户的键盘锁设置。- KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS，它只影响应用在托管配置文件中生成的通知。</code></pre></li><li>DevicePolicyManager.createAndInitializeUser() 方法和 DevicePolicyManager.createUser() 方法已弃用。</li><li>当给定用户的应用在前台运行时，setScreenCaptureDisabled() 方法现在也会屏蔽辅助结构。</li><li>EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM 现在默认为 SHA-256。出于向后兼容性考虑，仍然支持 SHA-1，但未来将会取消该支持。  EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM 现在只接受 SHA-256。<ul><li>Android 6.0（API 级别 23）中曾经存在的 Device initializer API 现已删除</li><li>EXTRA_PROVISIONING_RESET_PROTECTION_PARAMETERS 已删除，因此 NFC 占位配置无法通过编程解锁受恢复出厂设置保护的设备</li><li>您现在可以使用 EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE extra 在对托管设备进行 NFC 配置期间向设备所有者应用传递数据。</li><li>Android for Work API 针对 M 运行时权限（包括 Work 配置文件、辅助层及其他内容）进行了优化。新增的 DevicePolicyManager 权限 API 不会影响 M 之前版本的应用。</li><li>当用户退出通过 ACTION_PROVISION_MANAGED_PROFILE 或 ACTION_PROVISION_MANAGED_DEVICE intent 发起的设置流程的同步部分时，系统现在会返回 RESULT_CANCELED 结果代码。</li></ul></li></ul></li><li>对其他 API 的变更：<ul><li>流量消耗：android.app.usage.NetworkUsageStats 类已重命名为 NetworkStats。</li></ul></li><li>对全局设置的变更：<ul><li>这些设置不再通过 setGlobalSettings() 进行设置：<ul><li>BLUETOOTH_ON</li><li>DEVELOPMENT_SETTINGS_ENABLED</li><li>MODE_RINGER</li><li>NETWORK_PREFERENCE</li><li>WIFI_ON</li></ul></li><li>这些全局设置现在可通过 setGlobalSettings() 进行设置：<br>  -WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 6.0（API 级别 23）除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。&lt;/p&gt;
&lt;p&gt;如果您之前发布过 Android 应用，请注意您的应用可能受到这些平台变更的影响。&lt;/
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
      <category term="Marshmallow" scheme="http://yoursite.com/tags/Marshmallow/"/>
    
      <category term="Android 6.0" scheme="http://yoursite.com/tags/Android-6-0/"/>
    
  </entry>
  
  <entry>
    <title>Android 6.0 API 概述</title>
    <link href="http://yoursite.com/2016/04/30/android-6-0/"/>
    <id>http://yoursite.com/2016/04/30/android-6-0/</id>
    <published>2016-04-30T08:29:28.000Z</published>
    <updated>2018-04-10T01:33:39.221Z</updated>
    
    <content type="html"><![CDATA[<p>Android 6.0 (M) 为用户和应用开发者提供了新功能。本文旨在介绍其中最值得关注的 API。</p><h2 id="着手开发"><a href="#着手开发" class="headerlink" title="着手开发"></a>着手开发</h2><p>要着手开发 Android 6.0 应用，您必须先获得 Android SDK，然后使用 SDK 管理器下载 Android 6.0 SDK Platform 和系统映像。</p><h2 id="更新目标-API-级别"><a href="#更新目标-API-级别" class="headerlink" title="更新目标 API 级别"></a>更新目标 API 级别</h2><p>要进一步优化您的应用在运行 Android 的设备上的性能，请将您的 targetSdkVersion 设置为”23”，在 Android 系统映像上安装您的应用并进行测试，然后发布更新了此变更的应用。</p><p>您可以通过在代码中加入条件，在执行您的 minSdkVersion 不支持的 API 之前检查系统 API 级别，实现在使用 Android API 的同时仍为旧版本提供支持。要详细了解如何保持向后兼容性，请阅读支持不同平台版本。</p><p>如需了解有关 API 级别工作方式的详细信息，请阅读什么是 API 级别？</p><h1 id="指纹身份验证"><a href="#指纹身份验证" class="headerlink" title="指纹身份验证"></a>指纹身份验证</h1><hr><p>此版本提供了一些新的 API，在受支持的设备上，用户只需扫描其指纹即可完成身份验证，这些 API 还可与 <a href="https://developer.android.com/training/articles/keystore.html" target="_blank" rel="noopener">Android 密钥库系统</a>结合使用。</p><p>要通过指纹扫描验证用户身份，请获取新 <code>FingerprintManager</code> 类的实例，并调用 <code>authenticate()</code>方法。您的应用必须运行在带有指纹传感器的兼容设备上。您必须在应用中实现指纹身份验证流的用户界面，并在 UI 中使用标准 Android 指纹图标。<a href="https://developer.android.com/samples/FingerprintDialog/index.html" target="_blank" rel="noopener">FingerprintDialog 示例</a>中包含有 Android 指纹图标 (c_fp_40px.png)。请注意，如果您要开发多个使用指纹身份验证的应用，每个应用必须独立验证用户的指纹。</p><p>要在您的应用中使用此功能，请先在清单中添加 <code>USE_FINGERPRINT</code> 权限。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.permission.USE_FINGERPRINT"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>要查看指纹身份验证的应用实现，请参阅<a href="https://developer.android.com/samples/FingerprintDialog/index.html" target="_blank" rel="noopener">FingerprintDialog 示例</a>。要查看有关将这些身份验证 API 与其他 Android API 结合使用方法的演示，请观看视频 <a href="https://www.youtube.com/watch?v=VOn7VrTRlA4" target="_blank" rel="noopener">Fingerprint API 和 Payment API</a>。<br><img src="/2016/04/30/android-6-0/fingerprint-screen.png" style="width:200px; float:right"><br>如果您要测试此功能，请执行以下步骤：</p><ol><li>如果您尚未安装 Android SDK 工具 24.3 修订版，请执行此操作。</li><li>转到 <strong>Settings &gt; Security &gt; Fingerprint</strong>，然后按照登记说明在模拟器中登记新指纹。</li><li>使用模拟器通过以下命令模拟指纹触摸事件。使用同一命令模拟锁屏上或应用中的指纹触摸事件。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -e emu finger touch &lt;finger_id&gt;</span><br></pre></td></tr></table></figure></li></ol><p>在 Windows 上，您可能需要运行带有 finger touch &lt;finger_id&gt; 参数的 telnet 127.0.0.1 <emulator-id> 命令。</emulator-id></p><h1 id="确认凭据"><a href="#确认凭据" class="headerlink" title="确认凭据"></a>确认凭据</h1><hr><p>您的应用可以根据用户在多久之前最后一次解锁设备来验证其身份。此功能让用户不必费心记忆应用特定密码，您也无需实现自己的身份验证用户界面。您的应用应当利用此功能并结合实现公钥或私钥，以进行用户身份验证。</p><p>要设置成功验证用户身份后可再次使用同一密钥的超时持续时间，请在设置<a href="https://developer.android.com/reference/javax/crypto/KeyGenerator.html" target="_blank" rel="noopener">KeyGenerator</a> 或<a href="https://developer.android.com/reference/java/security/KeyPairGenerator.html" target="_blank" rel="noopener">KeyPairGenerator</a> 时调用新增的 <code>setUserAuthenticationValidityDurationSeconds()</code> 方法。</p><p>避免过多显示重新验证对话框 – 您的应用应尝试先使用加密对象，如果超时到期，请使用 createConfirmDeviceCredentialIntent() 方法在您的应用内重新验证用户身份。</p><p>要查看此功能的应用实现，请参阅 <a href="https://developer.android.com/samples/ConfirmCredential/index.html" target="_blank" rel="noopener">ConfirmCredential 示例</a>。</p><h1 id="应用链接"><a href="#应用链接" class="headerlink" title="应用链接"></a>应用链接</h1><hr><p>此版本通过提供功能更强大的应用链接，增强了 Android 的 intent 系统。您可以利用此功能将应用与您拥有的某个 Web 域关联。平台可以根据此关联确定在处理特定 Web 链接时默认使用的应用，跳过提示用户选择应用的步骤。要了解如何实现此功能，请参阅<a href="https://developer.android.com/training/app-links/index.html" target="_blank" rel="noopener">处理应用链接</a>。</p><h1 id="自动备份应用"><a href="#自动备份应用" class="headerlink" title="自动备份应用"></a>自动备份应用</h1><hr><p>现在，系统可以自动为应用执行完整数据备份和恢复。您的应用的目标平台必须是 Android 6.0（API 级别 23），才能启用此行为；您无需额外添加任何代码。如果用户删除其 Google 帐户，其备份数据也会随之删除。要了解该功能的工作方式以及配置文件系统备份内容的方法，请参阅<a href="https://developer.android.com/training/backup/autosyncapi.html" target="_blank" rel="noopener">配置应用自动备份</a>。</p><h1 id="直接共享"><a href="#直接共享" class="headerlink" title="直接共享"></a>直接共享</h1><hr><p><img src="/2016/04/30/android-6-0/direct-share-screen.png" style="width:200px; float:right; margin_left:20px"><br>此版本为您提供的一些 API 可让用户直观、快捷地进行共享。现在，您可以定义可在您的应用内启动特定 Activity 的直接共享目标。这些直接共享目标通过“共享”菜单公开给用户。此功能让用户可以向其他应用内的目标（如联系人）共享内容。例如，直接共享目标可以启动另一社交网络应用中的某个 Activity，让用户可以直接向该应用中的某位朋友或某个社区共享内容。</p><p>要启用直接共享目标，您必须定义一个类，用于扩展 <code>ChooserTargetService</code> 类。在清单中声明您的服务。在该声明内，指定 <code>BIND_CHOOSER_TARGET_SERVICE</code> 权限和一个使用 <code>SERVICE_INTERFACE</code> 操作的 intent 过滤器。</p><p>以下示例展示了如何在清单中声明 <code>ChooserTargetService</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".ChooserTargetService"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/service_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:permission</span>=<span class="string">"android.permission.BIND_CHOOSER_TARGET_SERVICE"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.service.chooser.ChooserTargetService"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>对于您想要向 <code>ChooserTargetService</code> 公开的每个 Activity，请在您的应用清单中为其添加一个名为 <strong>“android.service.chooser.chooser_target_service”</strong> 的 <code>&lt;meta-data&gt;</code> 元素。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MyShareActivity”</span></span></span><br><span class="line"><span class="tag"><span class="string">        android:label="</span>@<span class="attr">string</span>/<span class="attr">share_activity_label</span>"&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.service.chooser.chooser_target_service"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">".ChooserTargetService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="语音交互"><a href="#语音交互" class="headerlink" title="语音交互"></a>语音交互</h1><hr><p>此版本提供了一个新的语音交互 API，与语音操作一起使用时，可让您为应用打造对话式语音体验。调用 <code>isVoiceInteraction()</code> 方法可确定是否是响应语音操作触发了您的 Activity。如果是这样，则您的应用可以使用 <code>VoiceInteractor</code> 类请求用户进行语音确认、从选项列表中进行选择以及执行其他操作。</p><p>大多数语音交互都由用户语音操作发起。但语音交互 Activity 也可在没有用户输入的情况下启动。例如，通过语音交互启动的另一应用也可发送 intent 来启动语音交互。要确定您的 Activity 是由用户语音查询还是另一语音交互应用启动，请调用 <code>isVoiceInteractionRoot()</code> 方法。如果另一应用启动了您的 Activity，该方法会返回 false。您的应用可能随即提示用户确认其有意执行此操作。</p><p>要详细了解如何实现语音操作，请参阅<a href="https://developers.google.com/voice-actions/interaction/" target="_blank" rel="noopener">语音操作开发者网站</a>。</p><h1 id="Assist-API"><a href="#Assist-API" class="headerlink" title="Assist API"></a>Assist API</h1><hr><p>此版本提供了一种让用户通过助手程序与应用进行互动的新方式。要使用此功能，用户必须启用助手以使用当前上下文。启用助手后，用户可通过长按首页按钮在任何应用内召唤助手。</p><p>您的应用可通过设置 <code>FLAG_SECURE</code> 标记选择不与助手共享当前上下文。除了平台传递给助手的一组标准信息外，您的应用还可利用新增的 <code>AssistContent</code> 类共享其他信息。</p><p>要为助手提供您的应用内的其他上下文，请执行以下步骤：</p><ol><li>实现 <code>Application.OnProvideAssistDataListener</code> 接口。</li><li>利用 <code>registerOnProvideAssistDataListener()</code> 注册此侦听器。</li><li>要提供特定于 Activity 的上下文信息，请重写 <code>onProvideAssistData()</code> 回调和新的 <code>onProvideAssistContent()</code> 回调（可选操作）。<h1 id="可采用的存储设备"><a href="#可采用的存储设备" class="headerlink" title="可采用的存储设备"></a>可采用的存储设备</h1></li></ol><hr><p>使用此版本时，用户可以采用 SD 卡等外部存储设备。采用外部存储设备可加密和格式化设备，使其具有类似内部存储设备的行为。用户可以利用此特性在存储设备之间移动应用及其私有数据。移动应用时，系统会遵守清单中的 <code>android:installLocation</code> 首选项。</p><p>请注意，在内部存储设备与外部存储设备之间移动应用时，如果您的应用访问以下 API 或字段，它们返回的文件路径将会动态变化。强烈建议：在生成文件路径时，请始终动态调用这些 API。请勿使用硬编码文件路径或之前生成的永久性完全限定文件路径。</p><ul><li><code>Context</code> 方法：<ul><li><code>getFilesDir()</code></li><li><code>getCacheDir()</code></li><li><code>getCodeCacheDir()</code></li><li><code>getDatabasePath()</code></li><li><code>getDir()</code></li><li><code>getNoBackupFilesDir()</code></li><li><code>getFileStreamPath()</code></li><li><code>getPackageCodePath()</code></li><li><code>getPackageResourcePath()</code></li></ul></li><li><code>ApplicationInfo</code> 字段：<ul><li><code>dataDir</code></li><li><code>sourceDir</code></li><li><code>nativeLibraryDir</code></li><li><code>publicSourceDir</code></li><li><code>splitSourceDirs</code></li><li><code>splitPublicSourceDirs</code></li></ul></li></ul><p>要调试此功能，您可以将一个 USB 驱动器通过一根 USB On-The-Go (OTG) 电缆连接到 Android 设备并运行以下命令启用该 USB 驱动器：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell sm <span class="built_in">set</span>-force-adoptable <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><hr><p>此版本针对通知功能引入了下列 API 变更：</p><ul><li>新增了 <code>INTERRUPTION_FILTER_ALARMS</code> 过滤级别，它对应于新增的“仅闹铃”免打扰模式。</li><li>新增了 <code>CATEGORY_REMINDER</code> 类别值，用于区分用户安排的提醒与其他事件 (<code>CATEGORY_EVENT</code>) 和闹铃 (<code>CATEGORY_ALARM</code>)。</li><li>新增了 <code>Icon</code> 类，您可以通过 <code>setSmallIcon()</code>方法和 <code>setLargeIcon()</code>方法将其附加到通知上。同理，<code>addAction()</code> 方法现在接受 <code>Icon</code> 对象，而不接受可绘制资源 ID。</li><li>新增了 <code>getActiveNotifications()</code> 方法，让您的应用能够了解哪些通知目前处于活动状态。要查看使用此功能的应用实现，请参阅 <code>ActiveNotifications</code> 示例。</li></ul><h1 id="蓝牙触控笔支持"><a href="#蓝牙触控笔支持" class="headerlink" title="蓝牙触控笔支持"></a>蓝牙触控笔支持</h1><hr><p>此版本改善了对用户使用蓝牙触控笔进行输入的支持。用户可将兼容的蓝牙触控笔与其手机或平板电脑配对并建立连接。连接后，来自触摸屏的位置信息将与来自触控笔的压力和按键信息融合，从而实现比单纯使用触摸屏更丰富的表达。您的应用可以通过在 Activity 中注册 <code>View.OnContextClickListener</code> 对象和 <code>GestureDetector.OnContextClickListener</code> 对象，侦听触控笔按键动作并执行辅助操作。</p><p>可使用 <code>MotionEvent</code> 方法和常量来检测触控笔按键交互：</p><ul><li>如果用户使用带按键的触控笔触按应用屏幕，<code>getTooltype()</code> 方法会返回 <code>TOOL_TYPE_STYLUS</code>。</li><li>对于以 Android 6.0（API 级别 23）为目标平台的应用，当用户按触控笔的主按键时，<code>getButtonState()</code> 方法会返回 <code>BUTTON_STYLUS_PRIMARY</code>。如果触控笔有辅助按键，当用户按下它时，该方法会返回 <code>BUTTON_STYLUS_SECONDARY</code>。如果用户同时按下两个按键，该方法会同时返回通过 OR 运算符连接起来的两个值 (<code>BUTTON_STYLUS_PRIMARY|BUTTON_STYLUS_SECONDARY</code>)。</li><li>对于以较低平台版本为目标的应用，<code>getButtonState()</code> 方法返回 <code>BUTTON_SECONDARY</code>（按下触控笔主按键时）、<code>BUTTON_TERTIARY</code>（按下触控笔辅助按键时）之一或同时返回这两者。</li></ul><h1 id="改进的蓝牙低功耗扫描"><a href="#改进的蓝牙低功耗扫描" class="headerlink" title="改进的蓝牙低功耗扫描"></a>改进的蓝牙低功耗扫描</h1><hr><p>如果您的应用执行蓝牙低功耗扫描，可以使用新增的 <code>setCallbackType()</code> 方法指定您只希望在下列条件下通知回调：首次找到与设置的 <code>ScanFilter</code> 匹配的播发数据包，或者已过很长时间后才再次看到该数据包。这种扫描方法与旧平台版本中提供的方法相比更加节能。</p><h1 id="Hotspot-2-0-第-1-版支持"><a href="#Hotspot-2-0-第-1-版支持" class="headerlink" title="Hotspot 2.0 第 1 版支持"></a>Hotspot 2.0 第 1 版支持</h1><hr><p>此版本在 Nexus 6 和 Nexus 9 设备上添加了对 Hotspot 2.0 第 1 版规范的支持。要在您的应用中配置 Hotspot 2.0 凭据，请使用 <code>WifiEnterpriseConfig</code> 类的新方法，如 <code>setPlmn()</code> 方法和 <code>setRealm()</code> 方法。在 <code>WifiConfiguration</code> 对象中，您可以设置 <code>FQDN</code> 字段和 <code>providerFriendlyName</code> 字段。新增的 <code>isPasspointNetwork()</code> 方法可指示检测到的网络是否为 Hotspot 2.0 接入点。</p><h1 id="4K-显示模式"><a href="#4K-显示模式" class="headerlink" title="4K 显示模式"></a>4K 显示模式</h1><hr><p>现在，平台允许应用在兼容硬件上请求将显示分辨率升级到 4K 渲染。要查询当前物理分辨率，请使用新增的 <code>Display.Mode</code> API。请注意，如果 UI 是以较低逻辑分辨率绘制并通过放大达到更高的物理分辨率，则 <code>getPhysicalWidth()</code> 方法返回的物理分辨率可能不同于 <code>getSize()</code> 所报告的逻辑分辨率。</p><p>您可以通过设置应用窗口的 <code>preferredDisplayModeId</code> 属性请求系统更改应用运行时的物理分辨率。如果您想切换到 4K 显示分辨率，此功能会很有帮助。在 4K 显示模式下，UI 仍然以原始分辨率（如 1080p）渲染，通过放大达到 4K，但 <code>SurfaceView</code> 对象可能会以原生分辨率显示内容。</p><h1 id="主题化-ColorStateList"><a href="#主题化-ColorStateList" class="headerlink" title="主题化 ColorStateList"></a>主题化 ColorStateList</h1><hr><p>对于运行 Android 6.0（API 级别 23）的设备，现在支持在 <code>ColorStateList</code> 中使用主题属性。<code>Resources.getColorStateList()</code> 方法和 <code>Resources.getColor()</code> 方法已弃用。如果您要调用这些 API，请改为调用新增的 <code>Context.getColorStateList()</code> 方法或 <code>Context.getColor()</code> 方法。还可在 v4 appcompat 库中通过 <code>ContextCompat</code> 使用这些方法。</p><h1 id="音频功能"><a href="#音频功能" class="headerlink" title="音频功能"></a>音频功能</h1><hr><p>此版本增强了 Android 上的音频处理功能，包括：</p><ul><li>通过新增的 <code>android.media.midi</code> API 提供了对 <code>MIDI</code> 协议的支持。使用这些 API 可发送和接收 <code>MIDI</code> 事件。</li><li>新增了 <code>AudioRecord.Builder</code> 类和 <code>AudioTrack.Builder</code> 类，分别用于创建数字音频采集和回放对象，还可用于配置音频源和接收器属性来替换系统默认值。</li><li>用于关联音频和输入设备的 API 钩子。如果您的应用允许用户通过与 Android TV 相连的游戏控制器或遥控器启动语音搜索，此功能尤为有用。系统会在用户启动搜索时调用新增的 <code>onSearchRequested()</code> 回调。要确定用户的输入设备是否内置麦克风，请从该回调检索 InputDevice 对象，然后调用新的 <code>hasMicrophone()</code> 方法。</li><li>新增了 <code>getDevices()</code> 方法，让您可以检索系统当前连接的所有音频设备的列表。如果您想让系统在音频设备连接或断开时通知应用，还可以注册一个 <code>AudioDeviceCallback</code> 对象。</li></ul><h1 id="视频功能"><a href="#视频功能" class="headerlink" title="视频功能"></a>视频功能</h1><hr><p>此版本为视频处理 API 添加了新功能，包括：</p><ul><li>新增了 <code>MediaSync</code> 类，可帮助应用同步渲染音频流和视频流。音频缓冲区以非锁定方式提交，并通过回调返回。此外，它还支持动态回放速率。</li><li>新增了 <code>EVENT_SESSION_RECLAIMED</code> 事件，它表示应用打开的会话已被资源管理器收回。如果您的应用使用 DRM 会话，则应处理此事件，并确保不使用收回的会话。</li><li>新增了 <code>ERROR_RECLAIMED</code> 错误代码，它表示资源管理器收回了编解码器使用的媒体资源。出现此异常时，必须释放编解码器，因为它已转入终止状态。</li><li>新增了 <code>getMaxSupportedInstances()</code> 接口，用于获取有关支持的编解码器实例最大并发数量的提示。</li><li>新增了 <code>setPlaybackParams()</code> 方法，用于设置快动作回放或慢动作回放的媒体回放速率。此外，它还会随视频一起自动拉长或加速音频回放。</li></ul><h2 id="相机功能"><a href="#相机功能" class="headerlink" title="#相机功能"></a>#相机功能</h2><p>此版本提供了下列用于访问相机闪光灯和相机图像再处理的新 API：</p><h2 id="Flashlight-API"><a href="#Flashlight-API" class="headerlink" title="Flashlight API"></a>Flashlight API</h2><p>如果相机设备带有闪光灯，您可以通过调用 <code>setTorchMode()</code> 方法，在不打开相机设备的情况下打开或关闭闪光灯的火炬模式。应用对闪光灯或相机设备不享有独占所有权。每当相机设备不可用，或者开启火炬的其他相机资源不可用时，火炬模式即会被关闭并变为不可用状态。其他应用也可调用 <code>setTorchMode()</code> 来关闭火炬模式。当最后一个开启火炬模式的应用关闭时，火炬模式就会被关闭。</p><p>您可以注册一个回调，通过调用 <code>registerTorchCallback()</code> 方法接收有关火炬模式状态的通知。第一次注册回调时，系统会立即调用它，并返回所有当前已知配备闪光灯的相机设备的火炬模式状态。如果成功开启或关闭火炬模式，系统会调用 <code>onTorchModeChanged()</code> 方法。</p><h2 id="Reprocessing-API"><a href="#Reprocessing-API" class="headerlink" title="Reprocessing API"></a>Reprocessing API</h2><p><code>Camera2</code> API 进行了扩展，以支持 YUV 和专用不透明格式图像再处理。要确定这些再处理功能是否可用，请调用 <code>getCameraCharacteristics()</code> 并检查有无 <code>REPROCESS_MAX_CAPTURE_STALL</code> 密钥。如果设备支持再处理，您可以通过调用 <code>createReprocessableCaptureSession()</code> 创建一个可再处理的相机采集会话并创建输入缓冲区再处理请求。</p><p>使用 <code>ImageWriter</code> 类可将输入缓冲区流与相机再处理输入相连。要获得空白缓冲区，请遵循以下编程模型：</p><ol><li>调用 <code>dequeueInputImage()</code> 方法。</li><li>在输入缓冲区中填充数据。</li><li>通过调用 <code>queueInputImage()</code>方法将缓冲区发送至相机。</li></ol><p>如果您将 <code>ImageWriter</code> 对象与 <code>PRIVATE</code> 图像一起使用，您的应用并不能直接访问图像数据。请改为调用 <code>queueInputImage()</code> 方法，将 <code>PRIVATE</code> 图像直接传递给 <code>ImageWriter</code>，而不进行任何缓冲区复制。</p><p><code>ImageReader</code> 类现在支持 PRIVATE 格式图像流。凭借此支持特性，您的应用可使 <code>ImageReader</code> 输出图像保持为循环图像队列，还可选择一个或多个图像并将其发送给 <code>ImageWriter</code> 进行相机再处理。</p><h1 id="Android-for-Work-功能"><a href="#Android-for-Work-功能" class="headerlink" title="Android for Work 功能"></a>Android for Work 功能</h1><hr><p>此版本提供了下列用于 Android for Work 的新 API：</p><ul><li><strong>用于企业所有、单一用途设备的增强型控件：</strong>现在，设备所有者可以通过控制以下设置来改善 企业所有、单一用途 (COSU) 设备的管理：<ul><li>通过 <code>setKeyguardDisabled()</code> 方法停用或重新启用键盘锁。</li><li>通过 <code>setStatusBarDisabled()</code> 方法停用或重新启用状态栏（包括快速设置、通知以及启动 Google 即时的向上划动导航手势）。</li><li>通过 <code>UserManager</code> 常量 <code>DISALLOW_SAFE_BOOT</code> 停用或重新启用安全启动。</li><li>通过 <code>STAY_ON_WHILE_PLUGGED_IN</code> 常量防止屏幕在插入电源的情况下关闭。</li></ul></li><li><strong>设备所有者静默式安装和卸载应用：</strong>现在，设备所有者可使用 <code>PackageInstaller</code> API 在不依赖 Google Play for Work 的情况下静默式安装和卸载应用。现在，您可以通过设备所有者配置设备，从而无需用户干预即可获取并安装应用。此功能可用于在不激活 Google 帐户的情况下实现信息亭或其他此类设备的一键式配置。</li><li><strong>静默式企业证书访问：</strong> 现在，当应用调用 <code>choosePrivateKeyAlias()</code> 时，配置文件所有者或设备所有者可以在系统提示用户选择证书前调用 <code>onChoosePrivateKeyAlias()</code> 方法，静默式向发出请求的应用提供别名。此功能让您可以在无需用户交互的情况下授予托管应用访问证书的权限。</li><li><strong>自动接受系统更新：</strong>现在，设备所有者可以通过 <code>setSystemUpdatePolicy()</code> 设置一个系统更新政策来自动接受系统更新（例如对于信息亭设备），或者推迟更新并在至多 30 天的时间内防止用户获取更新。此外，管理员还可设置每日必须获取更新的时间窗口，例如在信息亭设备无人使用的时段。有可用的系统更新时，系统会检查设备规范控制器应用是否设置了系统更新政策，并相应地执行操作。</li><li><strong>授权证书安装：</strong>配置文件所有者或设备所有者现在可以授权第三方应用调用以下 <code>DevicePolicyManager</code> 证书管理 API：<ul><li><code>getInstalledCaCerts()</code></li><li><code>hasCaCertInstalled()</code></li><li><code>installCaCert()</code></li><li><code>uninstallCaCert()</code></li><li><code>uninstallAllUserCaCerts()</code></li><li><code>installKeyPair()</code><br><img src="/2016/04/30/android-6-0/work-profile-screen.png" style="width:200px; float:right; margin_left:20px"></li></ul></li><li><strong>流量消耗情况跟踪：</strong>现在，配置文件所有者或设备所有者可以利用新增的 <code>NetworkStatsManager</code> 方法查询 <strong>Settings &gt; Data Usage</strong> 中显示的流量使用情况统计信息。配置文件所有者会被自动授予查询其管理的配置文件相关数据的权限，而设备所有者则被授予对其管理的主要用户使用情况数据的访问权。</li><li><p><strong>运行时权限管理：</strong>配置文件所有者或设备所有者可以利用 <code>setPermissionPolicy()</code> 设置适用于所有应用全部运行时请求的权限政策，以提示用户授予权限，或自动以静默方式授予或拒绝权限。如果设置后一种政策，则用户将无法修改配置文件所有者或设备所有者在应用权限屏幕的 Settings 内所做的选择。</p></li><li><p><strong>Settings 中的 VPN：</strong>现在，<strong>Settings &gt; More &gt; VPN</strong> 中会显示 VPN 应用。此外，现在，关于 VPN 使用情况的通知取决于该 VPN 的配置方式。对于配置文件所有者，通知取决于该 VPN 是针对托管配置文件、个人配置文件还是同时针对这两者进行配置。对于设备所有者，通知取决于 VPN 是否针对整个设备进行配置。</p></li><li><strong>工作状态通知：</strong>现在，每当来自托管配置文件的应用具有前台 Activity 时，状态栏就会出现一个公文包图标。此外，如果设备直接解锁到托管配置文件中某个应用的 Activity，则会显示一个 Toast，通知用户他们位于托管配置文件内。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 6.0 (M) 为用户和应用开发者提供了新功能。本文旨在介绍其中最值得关注的 API。&lt;/p&gt;
&lt;h2 id=&quot;着手开发&quot;&gt;&lt;a href=&quot;#着手开发&quot; class=&quot;headerlink&quot; title=&quot;着手开发&quot;&gt;&lt;/a&gt;着手开发&lt;/h2&gt;&lt;p&gt;要着手
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
      <category term="Marshmallow" scheme="http://yoursite.com/tags/Marshmallow/"/>
    
      <category term="Android 6.0" scheme="http://yoursite.com/tags/Android-6-0/"/>
    
  </entry>
  
  <entry>
    <title>Android 5.0 变更</title>
    <link href="http://yoursite.com/2015/08/27/android-5-0-changes/"/>
    <id>http://yoursite.com/2015/08/27/android-5-0-changes/</id>
    <published>2015-08-27T11:55:06.000Z</published>
    <updated>2018-04-10T01:34:32.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Runtime-ART"><a href="#Android-Runtime-ART" class="headerlink" title="Android Runtime (ART)"></a>Android Runtime (ART)</h1><hr><p>在 Android 5.0 中，ART 运行时取代 Dalvik 成为平台默认设置。Android 4.4 中已引入处于实验阶段的 ART 运行时。</p><p>有关 ART 的新功能概述，请参阅 <a href="https://source.android.com/devices/tech/dalvik/art.html" target="_blank" rel="noopener">ART 简介</a>部分主要的新功能包括：</p><ul><li>预先 (AOT) 编译</li><li>改进的垃圾回收 (GC)</li><li>改进的调试支持</li></ul><p>大多数 Android 应用无需任何更改就可以在 ART 下工作。不过，部分适合 Dalvik 的技术并不适用于 ART。如需了解有关最重要问题的信息，请参阅<a href="https://developer.android.com/guide/practices/verifying-apps-art.html" target="_blank" rel="noopener">在 Android Runtime (ART) 上验证应用行为</a>。如存在以下情况，应特别注意：</p><ul><li>您的应用使用 Java 原生接口 (JNI) 运行 C/C++ 代码。</li><li>您使用生成非标准代码的开发工具（例如，一些代码混淆工具）。</li><li>您使用与压缩垃圾回收不兼容的技术。</li></ul><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><hr><p>请确保您的通知考虑了上述 Android 5.0 变更。要详细了解如何为 Android 5.0 及更高版本设计通知，请参阅<a href="https://material.google.com/patterns/notifications.html" target="_blank" rel="noopener">通知设计指南</a>。</p><h2 id="Material-Design-样式"><a href="#Material-Design-样式" class="headerlink" title="Material Design 样式"></a>Material Design 样式</h2><p>在白色（或非常浅）的背景上使用深色文本绘制通知，以便与新的 Material Design 小部件匹配。请确保您的所有通知都与新的配色方案协调一致。如果您的通知看上去不协调，请进行修正：</p><ul><li>使用 <code>setColor()</code> 在您的图标图像后面的圆形中设置重点色彩。</li><li>更新或移除使用色彩的资源。系统在操作图标和主要通知图标中忽略所有非阿尔法通道。您应假设这些图标仅支持阿尔法通道。系统用白色绘制通知图标，用深灰色绘制操作图标。</li></ul><h1 id="声音和振动"><a href="#声音和振动" class="headerlink" title="声音和振动"></a>声音和振动</h1><p>如果您当前使用 <code>Ringtone</code>、<code>MediaPlayer</code> 或 <code>Vibrator</code> 类向通知中添加声音和振动，则移除此代码，以便系统可以在“优先”模式中正确显示通知。取而代之的是，使用 <code>Notification.Builder</code> 方法添加声音和振动。</p><p>将设备设为 <code>RINGER_MODE_SILENT</code> 可使设备进入新的优先模式。如果您将设备设为 <code>RINGER_MODE_NORMAL</code> 或 <code>RINGER_MODE_VIBRATE</code>，则设备将退出优先模式。</p><p>以前，Android 使用 <code>STREAM_MUSIC</code> 作为主流式传输来控制平板电脑设备上的音量。在 Android 5.0 中，手机和平板电脑设备的主音量流式传输现已合并，由 <code>STREAM_RING</code> 或 <code>STREAM_NOTIFICATION</code> 进行控制。</p><h2 id="锁定屏幕可见性"><a href="#锁定屏幕可见性" class="headerlink" title="锁定屏幕可见性"></a>锁定屏幕可见性</h2><p>默认情况下，在 Android 5.0 中，通知现在显示在用户的锁定屏幕上。用户可以选择保护敏感信息不被公开，在此情况下，系统会自动删减通知显示的文本。要自定义此删减的通知，请使用 <code>setPublicVersion()</code>。</p><p>如果通知不包含个人信息，或者您想允许媒体播放控件显示在通知上，则调用 <code>setVisibility()</code> 方法并将通知的可见性级别设为 <code>VISIBILITY_PUBLIC</code>。</p><h1 id="媒体播放"><a href="#媒体播放" class="headerlink" title="媒体播放"></a>媒体播放</h1><p>如果您要实现显示媒体播放状态或传输控件的通知，请考虑使用新的 <code>Notification.MediaStyle</code> 模板，而不是自定义 <code>RemoteViews.RemoteView</code> 对象。无论您选择使用哪个方法，请务必将通知的可见性设为 <code>VISIBILITY_PUBLIC</code>，以便可通过锁定屏幕访问您的控件。请注意，从 Android 5.0 开始，系统不再将 <code>RemoteControlClient</code> 对象显示在锁定屏幕上。如需了解详细信息，请参阅如果您的应用使用 <code>RemoteControlClient</code>。</p><h2 id="浮动通知"><a href="#浮动通知" class="headerlink" title="浮动通知"></a>浮动通知</h2><p>现在，当设备处于活动状态时（即，设备未锁定且其屏幕已打开），通知可以显示在小型浮动窗口中（也称为“浮动通知”）。这些通知看上去类似于精简版的通知，只是浮动通知还显示操作按钮。用户可以在不离开当前应用的情况下处理或清除浮动通知。</p><p>可能触发浮动通知的条件示例包括：</p><ul><li>用户的 Activity 处于全屏模式中（应用使用 fullScreenIntent）</li><li>通知具有较高的优先级并使用铃声或振动</li></ul><p>如果您的应用在以上任何情形下实现通知，请确保系统正确显示浮动通知。</p><h1 id="媒体控件和-RemoteControlClient"><a href="#媒体控件和-RemoteControlClient" class="headerlink" title="媒体控件和 RemoteControlClient"></a>媒体控件和 RemoteControlClient</h1><hr><p><code>RemoteControlClient</code> 类现已弃用。请尽快切换到新的 <code>MediaSession</code> API。</p><p>Android 5.0 中的锁定屏幕不会为 <code>MediaSession</code> 或 <code>RemoteControlClient</code> 显示传输控件。不过，您的应用可以通过一个通知从锁定屏幕提供媒体播放控件。这让您的应用可以对媒体按钮的显示进行更多控制，同时为使用锁定设备和未锁定设备的用户提供一致的体验。</p><p>为实现此目的，Android 5.0 引入了一个新的 <code>Notification.MediaStyle</code> 模板。<code>Notification.MediaStyle</code> 将您使用 <code>Notification.Builder.addAction()</code> 添加的通知操作转换为精简按钮，嵌入到应用的媒体播放通知中。将您的会话令牌传递到 <code>setSession()</code> 方法以告知系统该通知控制进行中的媒体会话。</p><p>请务必将通知的可见性设为 <code>VISIBILITY_PUBLIC</code>，以将通知标记为安全，从而显示在任何锁定屏幕上（以安全方式或其他方式）。如需了解详细信息，请参阅锁定屏幕通知。</p><p>要让应用在 Android TV 或 Wear 平台上运行时显示媒体播放控件，则实现 MediaSession 类。如果您的应用需要在 Android 设备上接收媒体按钮事件，您还应实现 MediaSession。</p><h1 id="getRecentTasks"><a href="#getRecentTasks" class="headerlink" title="getRecentTasks()"></a>getRecentTasks()</h1><hr><p>Android 5.0 中引入新的“并发文档和 Activity 任务”功能后（请参阅下文<a href="https://developer.android.com/about/versions/android-5.0-changes.html#Recents" target="_blank" rel="noopener">最近使用的应用屏幕中的并发文档和 Activity</a>），为提升用户隐私的安全性，现已弃用 <code>ActivityManager.getRecentTasks()</code> 方法。对于向后兼容性，此方法仍会返回它的一小部分数据，包括调用应用自己的任务和可能的一些其他非敏感任务（如首页）。如果您的应用使用此方法检索它自己的任务，则改用 <code>getAppTasks()</code> 检索该信息。</p><h1 id="Android-NDK-中的-64-位支持"><a href="#Android-NDK-中的-64-位支持" class="headerlink" title="Android NDK 中的 64 位支持"></a>Android NDK 中的 64 位支持</h1><hr><p>Android 5.0 引入了对 64 位系统的支持。64 位增强功能可增加地址空间和提升性能，同时仍完全支持现有的 32 位应用。64 位支持也可改进用于加密的 OpenSSL 的性能。此外，该版本还引入了新的原生媒体 NDK API，以及原生 OpenGL ES (GLES) 3.1 支持。</p><p>要使用 Android 5.0 中提供的 64 位支持，请从 Android NDK 页面下载和安装 NDK Revision 10c。有关对 NDK 进行的重要变更和问题修复的更多信息，请参阅 Revision 10c 版本说明。</p><h1 id="绑定到服务"><a href="#绑定到服务" class="headerlink" title="绑定到服务"></a>绑定到服务</h1><hr><p><code>Context.bindService()</code> 方法现在需要显式 <code>Intent</code>，如果提供隐式 intent，将引发异常。为确保应用的安全性，请使用显式 intent 启动或绑定 <code>Service</code>，且不要为服务声明 intent 过滤器。</p><h1 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h1><hr><p>Android 5.0 更改了应用的默认行为。</p><ul><li>如果您的应用是面向 API 级别 21 或更高级别：<ul><li>默认情况下，系统会阻止混合内容和第三方 Cookie。要允许混合内容和第三方 Cookie，请分别使用 <code>setMixedContentMode()</code> 和 <code>setAcceptThirdPartyCookies()</code> 方法。</li><li>系统现在可以智能地选择要绘制的 HTML 文档部分。这个新的默认行为有助于减少内存占用和提升性能。如果您要一次渲染整个文档，可通过调用 <code>enableSlowWholeDocumentDraw()</code> 停用此优化。</li></ul></li><li>如果您的应用是面向低于 21 的 API 级别：系统允许混合内容和第三方 Cookie，并始终一次渲染整个文档。</li></ul><h1 id="自定义权限唯一性要求"><a href="#自定义权限唯一性要求" class="headerlink" title="自定义权限唯一性要求"></a>自定义权限唯一性要求</h1><hr><p>根据权限概述中所述，Android 应用可以定义以专有方式管理组件访问权限的自定义权限，无需使用平台预定义的系统权限。应用在其清单文件中声明的 <code>&lt;permission&gt;</code> 元素中定义自定义权限。</p><p>少数情况下定义自定义权限是合规且安全的方法。不过，创建自定义权限有时并无必要，甚至可能会给应用带来潜在风险，具体取决于分配给权限的保护级别。</p><p>Android 5.0 其中一项行为变更确保只有一个应用可以定义给定自定义权限，除非使用与定义权限的其他应用相同的密钥进行签名。</p><h2 id="使用重复的自定义权限的应用"><a href="#使用重复的自定义权限的应用" class="headerlink" title="使用重复的自定义权限的应用"></a>使用重复的自定义权限的应用</h2><p>任何应用都可以定义它需要的任何自定义权限，因此，可能会出现多个应用定义相同的自定义权限的情况。例如，如果两个应用提供相似的功能，它们可能会为其自定义权限派生出相同的逻辑名称。应用可能还纳入了本身包含相同自定义权限定义的通用公共库或代码示例。</p><p>在 Android 4.4 和更早的版本中，用户可以在给定设备上安装多个此类应用，不过系统会分配由第一个安装的应用指定的保护级别。</p><p>从 Android 5.0 开始，对于使用不同密钥签名的应用，系统会强制执行新的自定义权限唯一性限制。现在，设备上只有一个应用可以定义给定的自定义权限（按其名称确定），除非定义此权限的其他应用使用相同密钥签名。如果用户尝试安装的应用具有重复自定义权限且签名密钥不同于定义此权限的驻留应用，则系统将阻止安装。</p><h2 id="您的应用需要注意的事项"><a href="#您的应用需要注意的事项" class="headerlink" title="您的应用需要注意的事项"></a>您的应用需要注意的事项</h2><p>在 Android 5.0 和更新的版本中，应用可以和以前一样继续定义自己的自定义权限，并通过 <code>&lt;uses-permission&gt;</code> 机制请求其他应用的自定义权限。不过，对于 Android 5.0 中引入的新要求，您应仔细评估可能给您的应用带来的影响。</p><p>下面是一些需要考虑的因素：</p><ul><li>您的应用是否在其清单文件中声明任何 <code>&lt;permission&gt;</code> 元素？如果是，那么这些权限是否确实是您的应用或服务正常运行不可或缺的？或者，能否使用系统默认权限代替它们？</li><li>如果您的应用中具有 <code>&lt;permission&gt;</code> 元素，您是否知道它们来自哪里？</li><li>您实际上是否打算让其他应用通过 <code>&lt;uses-permission&gt;</code> 请求您的自定义权限？</li><li>您是否在您包含 <code>&lt;permission&gt;</code> 元素的应用中使用样板文件或示例代码？那些权限元素确实是不可或缺的吗？</li><li>您的自定义权限使用的名称是简单名称还是基于其他应用可能共享的通用术语？</li></ul><h2 id="新安装和更新"><a href="#新安装和更新" class="headerlink" title="新安装和更新"></a>新安装和更新</h2><p>如上所述，在运行 Android 4.4 或更早版本的设备上新安装和更新您的应用不会受影响，且行为没有任何变化。在运行 Android 5.0 或更新版本的设备上进行新安装和更新时，如果应用定义一个已由现有驻留应用定义的自定义权限，则系统会阻止安装您的应用。</p><h2 id="使用-Android-5-0-系统更新的现有安装"><a href="#使用-Android-5-0-系统更新的现有安装" class="headerlink" title="使用 Android 5.0 系统更新的现有安装"></a>使用 Android 5.0 系统更新的现有安装</h2><p>如果您的应用使用自定义更新且已广泛分发和安装，那么，当用户收到将设备升级到 Android 5.0 的更新时，您的应用可能会受影响。在安装系统更新后，系统重新验证已安装的应用，包括检查它们的自定义权限。如果您的应用定义一个已由另一个通过验证的应用定义的自定义权限，且您的应用没有使用与该应用相同的密钥签名，则系统不会重新安装您的应用。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>在运行 Android 5.0 或更新版本的设备上，我们建议您立即检查您的应用，进行任何所需的调整，并尽快向您的用户发布更新版本。</p><ul><li>如果您在应用中使用自定义权限，则考虑它们的来源以及您是否确实需要它们。从您的应用中移除所有 <code>&lt;permission&gt;</code> 元素，除非您确定它们是应用正常运行所必需的元素。</li><li>尽可能考虑使用系统默认权限替代您的自定义权限。</li><li>如果您的应用需要自定义权限，则重命名您的自定义权限，使其成为您的应用独有的权限，例如，将它们追加到应用的完整软件包名称。</li><li>如果您有一组使用不同密钥签名的应用，且这些应用通过自定义权限访问共享组件，则确保此自定义权限在共享组件中仅定义一次。使用共享组件的应用不应自己定义自定义权限，而应通过 <code>&lt;uses-permission&gt;</code> 机制请求访问权限。</li><li>如果您有一组使用相同密钥签名的应用，则每个应用都可以根据需要定义相同的 自定义权限， 系统允许以常规方式安装这些应用。</li></ul><h1 id="TLS-SSL-默认配置变更"><a href="#TLS-SSL-默认配置变更" class="headerlink" title="TLS/SSL 默认配置变更"></a>TLS/SSL 默认配置变更</h1><p>Android 5.0 针对 HTTPS 和其他 TLS/SSL 通信引入了对应用使用的默认 TLS/SSL 配置的变更：</p><ul><li>TLSv1.2 和 TLSv1.1 协议现已启用，</li><li>AES-GCM (AEAD) 加密套件现已启用，</li><li>MD5、3DES、导出和静态密钥 ECDH 加密套件现已停用，</li><li>首选使用 Forward Secrecy 加密套件（ECDHE 和 DHE）。</li></ul><p>在下面列出的少数情况下，这些变更可能会导致 HTTPS 或 TLS/SSL 连接断开。</p><p>请注意，来自 Google Play 服务的安全性 ProviderInstaller 自 Android 2.3 开始就已在 Android 平台版本上提供这些变更。</p><h2 id="服务器不支持任何已启用的加密套件"><a href="#服务器不支持任何已启用的加密套件" class="headerlink" title="服务器不支持任何已启用的加密套件"></a>服务器不支持任何已启用的加密套件</h2><p>例如，服务器可能仅支持 3DES 或 MD5 加密套件。首选的修复方法是改进服务器的配置，以启用更强更现代的加密套件和协议。理想情况下，应启用 TLSv1.2 和 AES-GCM 以及 Forward Secrecy 加密套件（ECDHE、DHE），且最好使用后者。</p><p>也可以修改应用以使用自定义 SSLSocketFactory 与服务器通信。出厂时应精心设计以创建 SSLSocket 实例，除默认加密套件外，此实例还应启用服务器所需的部分加密套件。</p><h2 id="应用对用于连接服务器的加密套件做出错误的假设"><a href="#应用对用于连接服务器的加密套件做出错误的假设" class="headerlink" title="应用对用于连接服务器的加密套件做出错误的假设"></a>应用对用于连接服务器的加密套件做出错误的假设</h2><p>例如，某些应用包含中断的自定义 X509TrustManager，因为它预计 authType 参数将成为 RSA，但出现了 ECDHE_RSA 或 DHE_RSA。</p><h2 id="服务器不支持-TLSv1-1、TLSv1-2-或新的-TLS-扩展"><a href="#服务器不支持-TLSv1-1、TLSv1-2-或新的-TLS-扩展" class="headerlink" title="服务器不支持 TLSv1.1、TLSv1.2 或新的 TLS 扩展"></a>服务器不支持 TLSv1.1、TLSv1.2 或新的 TLS 扩展</h2><p>例如，与服务器握手的 TLS/SSL 被错误地拒绝或出现停顿。首选的修复方法是升级服务器以符合 TLS/SSL 协议。这使服务器可以成功地协商这些更新的协议或协商 TLSv1 或更早的协议，并忽略它不理解的传输层安全协议扩展程序。在某些情况下，在服务器上禁用 TLSv1.1 和 TLSv1.2 可以作为权宜之计，直到升级服务器软件。</p><p>也可以修改应用以使用自定义 SSLSocketFactory 与服务器通信。出厂时应精心设计以创建 SSLSocket 实例，该实例仅包含已启用且服务器可以正确为其提供支持的协议。</p><h1 id="支持托管配置文件"><a href="#支持托管配置文件" class="headerlink" title="支持托管配置文件"></a>支持托管配置文件</h1><hr><p>设备管理员可以向设备添加托管配置文件。此配置文件由管理员所有，让管理员控制托管配置文件的同时，允许由用户控制其自己的个人配置文件及其存储空间。此变更会通过下列方式影响您的现有应用的行为。</p><h2 id="处理-Intent"><a href="#处理-Intent" class="headerlink" title="处理 Intent"></a>处理 Intent</h2><p>设备管理员可以从托管配置文件限制对系统应用的访问权限。在此情况下，如果应用从托管文件触发一个通常由该应用处理的 intent，且托管文件上没有适合此 intent 的处理程序，则此 intent 会引发异常。例如，设备管理员可以限制托管配置文件上的应用访问系统的相机应用。如果您的应用在托管配置文件上运行，并为 <code>MediaStore.ACTION_IMAGE_CAPTURE</code> 调用 <code>startActivityForResult()</code>，且托管配置文件上没有可以处理此 intent 的应用，则会导致 <code>ActivityNotFoundException</code>。</p><p>为防止出现此情况，您可以在触发任何 intent 之前检查是否至少有一个适合此 intent 的处理程序。要检查是否存在有效的处理程序，请调用 <code>Intent.resolveActivity()</code>。您可以在<a href="https://developer.android.com/training/camera/photobasics.html#TaskCaptureIntent" target="_blank" rel="noopener">轻松拍照：使用相机应用拍摄照片</a>中查看执行上述操作的示例。</p><h2 id="在各个配置文件中共享文件"><a href="#在各个配置文件中共享文件" class="headerlink" title="在各个配置文件中共享文件"></a>在各个配置文件中共享文件</h2><p>每个配置文件都有自己的文件存储空间。文件 URI 指的是文件存储空间中的特定位置，这意味着在一个配置文件上有效的文件 URI 在另一个文件上是无效的。对于只访问自己创建的文件的应用而言，这通常不是什么问题。不过，如果应用向某个 intent 附加文件，则附加文件 URI 并不安全，因为在某些情况下，可能会在其他配置文件上处理该 intent。例如，设备管理员可能会指定图像采集事件应由个人配置文件上的相机应用处理。如果此 intent 由托管配置文件上的应用触发，则相机需要能够将图像写入托管配置文件的应用可以读取的位置。</p><p>为安全起见，如果您需要将文件附加到某个可能会从一个配置文件移动到另一个配置文件的 intent，您应为该文件创建并使用内容 URI。有关共享文件及内容 URI 的更多信息，请参阅<a href="https://developer.android.com/training/secure-file-sharing/index.html" target="_blank" rel="noopener">共享文件</a>。例如，设备管理员可能会制定将由个人配置文件中的相机处理的 ACTION_IMAGE_CAPTURE 白名单。触发的 intent 的 EXTRA_OUTPUT 应包含指定照片应存储在何处的内容 URI。相机应用可以将图像写入该 URI 指定的位置，触发 intent 的应用将能够读取该文件，即使应用位于其他配置文件上。</p><h2 id="已移除锁定屏幕小部件支持"><a href="#已移除锁定屏幕小部件支持" class="headerlink" title="已移除锁定屏幕小部件支持"></a>已移除锁定屏幕小部件支持</h2><p>Android 5.0 移除了对锁定屏幕小部件的支持；它继续为主屏幕上的小组件提供支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-Runtime-ART&quot;&gt;&lt;a href=&quot;#Android-Runtime-ART&quot; class=&quot;headerlink&quot; title=&quot;Android Runtime (ART)&quot;&gt;&lt;/a&gt;Android Runtime (ART)&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Lollipop" scheme="http://yoursite.com/tags/Lollipop/"/>
    
      <category term="Android 5.0" scheme="http://yoursite.com/tags/Android-5-0/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
  </entry>
  
  <entry>
    <title>Android 5.0 API 概述</title>
    <link href="http://yoursite.com/2015/08/23/android-5-0/"/>
    <id>http://yoursite.com/2015/08/23/android-5-0/</id>
    <published>2015-08-23T14:12:13.000Z</published>
    <updated>2018-04-10T01:34:14.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h1><hr><h2 id="Material-Design-支持"><a href="#Material-Design-支持" class="headerlink" title="Material Design 支持"></a>Material Design 支持</h2><p>Android 5.0 添加了对 Android 的新 Material Design 样式的支持。您可以创建具有 Material Design 功能的应用，实现动态视觉效果，利用其中的 UI 元素转换赋予用户自然的感觉。此支持包括：</p><ul><li>Material Design 主题</li><li>视图阴影</li><li>RecyclerView 小部件</li><li>可绘制动画和造型效果</li><li>Material Design 动画和 Activity 转换效果</li><li>针对基于视图状态的视图属性的动画生成器</li><li>可自定义的 UI 小部件和具有可由您控制的调色板的应用栏</li><li>基于 XML 矢量图形的动画和非动画可绘制对象</li><li>要详细了解如何为您的应用添加 Material Design 功能，请参阅 <a href="https://developer.android.com/training/material/index.html" target="_blank" rel="noopener">Material Design</a></li></ul><h2 id="最近使用的应用屏幕中的并发文档和-Activity"><a href="#最近使用的应用屏幕中的并发文档和-Activity" class="headerlink" title="最近使用的应用屏幕中的并发文档和 Activity"></a>最近使用的应用屏幕中的并发文档和 Activity</h2><p>在之前的版本中，<a href="https://developer.android.com/guide/components/recents.html" target="_blank" rel="noopener">最近使用的应用屏幕</a>只能为最近与用户交互过的每个应用显示一项任务。现在，您的应用可以根据需要为其他并发文档 Activity 打开更多任务。此功能简化了多任务处理，通过在所有应用中提供一致的切换体验，让用户能够在最近使用的应用屏幕中的各个 Activity 和文档之间快速切换。此类并行任务示例可能包括：网络浏览器应用中打开的标签页、效率类应用中的文档、游戏中的并行对局或信息应用中的聊天。您的应用可以通过 <code>ActivityManager.AppTask</code> 类管理它的任务。</p><p>为插入逻辑换行符以便系统将您的 Activity 视为新任务，请在使用 <code>startActivity()</code> 启动 Activity 时使用 <code>FLAG_ACTIVITY_NEW_DOCUMENT</code>。您还可以通过在清单中将 <code>&lt;activity&gt;</code> 元素的 <code>documentLaunchMode</code> 属性设置为 “intoExisting” 或 “always” 来获得此行为。</p><p>为避免使最近使用的应用屏幕变得混乱，您可以在应用中设置该屏幕中可显示的任务数上限。要实现此目的，请设置 <code>&lt;application&gt;</code> 属性 <code>android:maxRecents</code>。目前可指定的上限为每位用户 50 个任务（RAM 较低设备为 25 个）。</p><p>可将最近使用的应用屏幕中的任务设置为在重启后保留。要控制持久化行为，请使用 <code>android:persistableMode</code> 属性。您还可以通过调用 <code>setTaskDescription()</code> 方法，更改 Activity 在最近使用的应用屏幕中的视觉属性，如 Activity 的颜色、标签和图标。</p><h2 id="WebView-更新"><a href="#WebView-更新" class="headerlink" title="WebView 更新"></a>WebView 更新</h2><p>Android 5.0 将 <code>WebView</code> 实现更新至 Chromium M37，增强了安全性和稳定性，并修复了一些问题。运行在 Android 5.0 上的 <code>WebView</code> 的默认用户代理字符串已更新，以纳入 37.0.0.0 作为版本号。</p><p>此版本引入了 <code>PermissionRequest</code> 类，让您的应用可以通过 <code>getUserMedia()</code> 等网络 API 授予 WebView 访问相机和麦克风之类受保护资源的权限。您的应用必须对这些资源拥有相应的 Android 权限，才能向 WebView 授予权限。</p><p>借助新的 <code>onShowFileChooser()</code> 方法，您现在可以在 WebView 中使用输入表单字段，然后启动文件选择器从 Android 设备中选择图像和文件。</p><p>此外，此版本还提供了对 <code>WebAudio</code>、<code>WebGL</code> 和 <code>WebRTC</code> 开放标准的支持。要详细了解此版本包含的新功能，请参阅 <a href="https://developer.chrome.com/multidevice/webview/overview" target="_blank" rel="noopener">WebView for Android</a>。</p><h2 id="屏幕采集和共享"><a href="#屏幕采集和共享" class="headerlink" title="屏幕采集和共享"></a>屏幕采集和共享</h2><p>Android 5.0 引入了新的 <code>android.media.projection API</code>，让您可以为应用添加屏幕采集和屏幕共享功能。例如，如果您想在视频会议应用中启用屏幕共享，便可使用此功能。</p><p>新增的 <code>createVirtualDisplay()</code> 方法允许您的应用将主屏幕（默认显示）的内容采集到一个 <code>Surface</code> 对象中，然后您的应用便可将其发送至整个网络。该 API 只允许采集非安全屏幕内容，不允许采集系统音频。要开始采集屏幕，您的应用必须先使用通过 <code>createScreenCaptureIntent()</code> 方法获得的 <code>Intent</code> 启动屏幕采集对话框，请求用户授予权限。</p><p>如需查看新 API 使用方法的示例，请参阅示例项目中的 <code>MediaProjectionDemo</code> 类。</p><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><hr><h2 id="锁定屏幕通知"><a href="#锁定屏幕通知" class="headerlink" title="锁定屏幕通知"></a>锁定屏幕通知</h2><p>Android 5.0 中的锁定屏幕可以显示通知。用户可以通过“Settings” 选择是否允许在安全的锁定屏幕上显示敏感的通知内容。</p><p>您的应用可以控制在安全锁定屏幕上显示的通知中可见信息的详细程度。要控制可见性级别，请调用 <code>setVisibility()</code>，然后指定以下值之一：</p><ul><li><code>VISIBILITY_PRIVATE</code>：显示通知图标等基本信息，但隐藏通知的完整内容。</li><li><code>VISIBILITY_PUBLIC</code>：显示通知的完整内容。</li><li><code>VISIBILITY_SECRET</code>：不显示任何内容，甚至不显示通知图标。<br>当可视性级别为 VISIBILITY_PRIVATE 时，您还可以提供隐藏个人详情的删减版通知内容。例如，短信应用可能会显示一条通知，指出“您有3 条新短信”，但是隐藏了短信内容和发件人。要提供此替换版本的通知，请先使用 <code>Notification.Builder</code> 创建替换通知。创建专用通知对象时，请通过 <code>setPublicVersion()</code> 方法为其附加替换通知。</li></ul><h2 id="通知元数据"><a href="#通知元数据" class="headerlink" title="通知元数据"></a>通知元数据</h2><p>Android 5.0 使用与您的应用通知关联的元数据，以更智能的方式对通知排序。要设置元数据，请在构建通知时调用 <code>Notification.Builder</code> 中的下列方法：</p><ul><li><code>setCategory()</code>：当设备处于“优先”模式时，指示系统如何处理应用通知（例如，通知代表来电、即时通讯还是闹铃）。</li><li><code>setPriority()</code>：标记通知的重要性是高于还是低于普通通知。如果优先级字段设置为 <code>PRIORITY_MAX</code> 或<code>PRIORITY_HIGH</code> 的通知还有声音或振动，则会将其显示在小型浮动窗口中。</li><li><code>addPerson()</code>：让您可以添加一名或多名与通知有关的人员。您的应用可以使用此名单指示系统将指定人员发出的通知归成一组，或者将这些人员发出的通知视为更重要的通知。<h1 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h1></li></ul><hr><h2 id="对-OpenGL-ES-3-1-的支持"><a href="#对-OpenGL-ES-3-1-的支持" class="headerlink" title="对 OpenGL ES 3.1 的支持"></a>对 OpenGL ES 3.1 的支持</h2><p>Android 5.0 添加了 Java 接口和对 OpenGLES 3.1 的原生支持。OpenGL ES 3.1 中提供的主要新功能包括：</p><ul><li>计算着色器</li><li>单独的着色器对象</li><li>间接绘制命令</li><li>多重采样和模具纹理</li><li>着色语言改进</li><li>高级混合模式和调试专用扩展</li><li>向后兼容 OpenGL ES 2.0 和 3.0</li></ul><p>Android 上 OpenGL ES 3.1 的 Java 接口随 GLES31 提供。使用 OpenGL ES 3.1 时，请务必在清单文件中使用 <code>&lt;uses-feature&gt;</code> 标记和 <code>android:glEsVersion</code> 属性对其进行声明。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:glEsVersion</span>=<span class="string">"0x00030001"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>如需了解有关如何使用 OpenGL ES（包括如何在运行时检查设备支持的 OpenGL ES 版本）的详细信息，请参阅 <a href="https://developer.android.com/guide/topics/graphics/opengl.html" target="_blank" rel="noopener">OpenGL ES API 指南</a>。</p><h2 id="Android-扩展包"><a href="#Android-扩展包" class="headerlink" title="Android 扩展包"></a>Android 扩展包</h2><p>除了 OpenGL ES 3.1 外，此版本还提供了一个扩展包，其中包括 Java 接口和对高级图形功能的原生支持。Android 将这些扩展视作单个软件包。（如果存在 <code>ANDROID_extension_pack_es31a</code> 扩展，您的应用可以假定扩展包中的所有扩展都存在，只需使用一条 <code>#extension</code> 语句便可启用着色语言功能。）</p><p>该扩展包支持：</p><ul><li>有保证的着色器存储缓冲区、图像和原子 Fragment 着色器支持（在 OpenGL ES 3.1 中，Fragment 着色器支持为可选支持）。</li><li>镶嵌和几何着色器</li><li>ASTC (LDR) 纹理压缩格式</li><li>每采样内插和着色</li><li>帧缓冲区中每个颜色附件采用不同混合模式</li></ul><p>该扩展包的 Java 接口随 GLES31Ext 提供。在您的应用清单中，您可以将应用声明为必须安装在支持该扩展包的设备上。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">“android.hardware.opengles.aep”</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:required</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h1><hr><h2 id="用于高级相机功能的-Camera-API"><a href="#用于高级相机功能的-Camera-API" class="headerlink" title="用于高级相机功能的 Camera API"></a>用于高级相机功能的 Camera API</h2><p>Android 5.0 引入了新的 <code>android.hardware.camera2</code> API 来简化精细照片采集和图像处理。您现在可以使用 <code>getCameraIdList()</code> 通过编程方式访问可供系统使用的相机设备，以及使用 <code>openCamera()</code> 通过编程方式连接特定设备。要开始采集图像，请创建一个 <code>CameraCaptureSession</code> 并指定用于发送已采集图像的 <code>Surface</code> 对象。可将 <code>CameraCaptureSession</code> 配置为进行单张拍摄或多张连拍。</p><p>要在采集新图像时得到通知，请实现 <code>CameraCaptureSession.CaptureCallback</code> 侦听器，并在您的采集请求中进行设置。现在，当系统完成图像采集请求时，您的 <code>CameraCaptureSession.CaptureCallback</code> 侦听器会收到对 <code>onCaptureCompleted()</code> 的调用，并在 <code>CaptureResult</code> 中为您提供图像采集元数据。</p><p><code>CameraCharacteristics</code> 类可让您的应用检测到设备上可用的相机功能。该对象的 <code>INFO_SUPPORTED_HARDWARE_LEVEL</code> 属性代表相机的功能级别。</p><ul><li>所有设备都至少支持 <code>INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY</code> 硬件级别，该级别具有的能力大致与弃用的 <code>Camera API</code> 相当。</li><li>支持 <code>INFO_SUPPORTED_HARDWARE_LEVEL_FULL</code> 硬件级别的设备可手动控制采集和后期处理，以及以高帧速率采集高分辨率图像。</li></ul><p>要了解如何使用更新后的 Camera API，请参阅此版本中的 Camera2Basic 和 Camera2Video 实现示例。</p><h2 id="音频回放"><a href="#音频回放" class="headerlink" title="音频回放"></a>音频回放</h2><p>此版本加入了对 <code>AudioTrack</code> 的下列更改：</p><ul><li>您的应用现在可以提供浮点格式 (<code>ENCODING_PCM_FLOAT</code>) 的音频数据。这可以实现更大的动态范围、更一致的精度和更多的动态余量。浮点算法在进行中间计算时特别有用。回放端点为音频数据使用位深度更低的整型格式。（在Android 5.0中，部分内部管道尚未采用浮点格式。）</li><li>您的应用现在可以提供音频数据作为 <code>ByteBuffer</code>，数据使用的格式与 <code>MediaCodec</code> 提供的格式相同。</li><li><code>WRITE_NON_BLOCKING</code> 选项可简化某些应用的缓冲和多线程处理。</li></ul><h2 id="媒体回放控制"><a href="#媒体回放控制" class="headerlink" title="媒体回放控制"></a>媒体回放控制</h2><p>使用新增的通知和媒体 API 可确保系统 UI 了解您的媒体回放情况，并可提取和显示专辑封面。现在，可以利用新增的 <code>MediaSession</code> 类和 <code>MediaController</code> 类更轻松地在整个 UI 和服务范围内控制媒体回放。</p><p>新增的 <code>MediaSession</code> 类替代了弃用的 RemoteControlClient 类，仅提供一套回调方法来处理传输控制和媒体按钮。如果您的应用提供媒体回放，并运行在 Android TV 或 Wear 平台上，请使用 <code>MediaSession</code> 类，通过同样的回调方法来处理您的传输控制。</p><p>现在，您可以使用新增的 <code>MediaController</code> 类开发自己的媒体控制器应用。该类可通过您的应用的 UI 进程，以线程安全方式监控和控制媒体回放。请在创建控制器时指定一个 <code>MediaSession.Token</code> 对象，以便您的应用可与给定 <code>MediaSession</code> 交互。您可以利用 <code>MediaController.TransportControls</code> 方法，通过发送 <code>play()</code>、<code>stop()</code>、<code>skipToNext()</code> 和 <code>setRating()</code> 等命令来控制该会话上的媒体回放。对于控制器，您还可以注册一个 <code>MediaController.Callback</code> 对象来侦听该会话上的元数据和状态变化。</p><p>此外，您还可以利用新增的 <code>Notification.MediaStyle</code> 类创建允许将回放控制与媒体会话绑定的丰富通知。</p><h2 id="媒体浏览"><a href="#媒体浏览" class="headerlink" title="媒体浏览"></a>媒体浏览</h2><p>Android 5.0 引入了通过新增的 <code>android.media.browse</code> API 让应用能够浏览其他应用媒体内容库的功能。要公开您应用内的媒体内容，请扩展 <code>MediaBrowserService</code> 类。您实现的 <code>MediaBrowserService</code> 应提供对 <code>MediaSession.Token</code> 的访问权限，以便应用能播放通过您的服务提供的媒体内容。</p><p>要与媒体浏览器服务交互，请使用 <code>MediaBrowser</code> 类。在您创建 <code>MediaBrowser</code> 实例时为 <code>MediaSession</code> 指定组件名称。然后，您的应用便可利用该浏览器实例连接到关联的服务并获得 <code>MediaSession.Token</code> 对象，以播放通过该服务公开的内容。</p><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><hr><h2 id="目录选择"><a href="#目录选择" class="headerlink" title="目录选择"></a>目录选择</h2><p>Android 5.0 扩展了<a href="https://developer.android.com/guide/topics/providers/document-provider.html" target="_blank" rel="noopener">存储访问框架</a>，允许用户选择整个目录子树，从而授予应用对所含全部文档的读/写权限，无需用户逐项确认。</p><p>要选择目录子树，请生成并发送一个 <code>OPEN_DOCUMENT_TREE</code> intent。系统会显示所有支持子树选择的 <code>DocumentsProvider</code> 实例，并允许用户浏览和选择目录。返回的 URI 代表对所选子树的访问权限。然后，您就可以使用 <code>buildChildDocumentsUriUsingTree()</code> 和 <code>buildDocumentUriUsingTree()</code> 以及 <code>query()</code> 来探索子树。</p><p>新增的 <code>createDocument()</code> 方法允许您在该子树下的任何位置新建文档或目录。要管理现有文档，请使用 <code>renameDocument()</code> 和 <code>deleteDocument()</code>。检查 <code>COLUMN_FLAGS</code> 以验证提供程序是否支持这些调用，然后再发出调用。</p><p>如果您要实现 <code>DocumentsProvider</code> 并想支持子树选择，请实现 <code>isChildDocument()</code> 并在您的 <code>COLUMN_FLAGS</code> 中加入 <code>FLAG_SUPPORTS_IS_CHILD</code>。</p><p>Android 5.0 还在共享的存储空间上引入了新的软件包专属目录，您的应用可在其中放置供加入到 <code>MediaStore</code> 中的媒体文件。新增的 <code>getExternalMediaDirs()</code> 返回所有共享存储设备上这些目录的路径。您的应用无需额外权限便可访问返回的路径，这与 <code>getExternalFilesDir()</code> 类似。平台会定期扫描这些目录中的新媒体，但您也可利用 <code>MediaScannerConnection</code> 显式扫描新内容。</p><h1 id="无线和连接"><a href="#无线和连接" class="headerlink" title="无线和连接"></a>无线和连接</h1><hr><h2 id="多个网络连接"><a href="#多个网络连接" class="headerlink" title="多个网络连接"></a>多个网络连接</h2><p>Android 5.0 提供了新的多网络 API，允许您的应用动态扫描具有特定能力的可用网络，并与它们建立连接。当您的应用需要 SUPL、彩信或运营商计费网络等专业化网络时，或者您想使用特定类型的传输协议发送数据时，就可以使用此功能。</p><p>要从您的应用以动态方式选择并连接网络，请执行以下步骤：</p><ol><li>创建一个 <code>ConnectivityManager</code>。</li><li>使用 <code>NetworkRequest.Builder</code> 类创建一个 <code>NetworkRequest</code> 对象，并指定您的应用感兴趣的网络功能和传输类型。</li><li>要扫描合适的网络，请调用 <code>requestNetwork()</code> 或 <code>registerNetworkCallback()</code>，并传入 <code>NetworkRequest</code> 对象和 <code>ConnectivityManager.NetworkCallback</code> 的实现。如果您想在检测到合适的网络时主动切换到该网络，请使用 <code>requestNetwork()</code> 方法；如果只是接收已扫描网络的通知而不需要主动切换，请改用 <code>registerNetworkCallback()</code> 方法。</li></ol><p>当系统检测到合适的网络时，它会连接到该网络并调用 <code>onAvailable()</code> 回调。您可以使用回调中的 <code>Network</code> 对象来获取有关网络的更多信息，或者引导通信使用所选网络。</p><h2 id="蓝牙低功耗"><a href="#蓝牙低功耗" class="headerlink" title="蓝牙低功耗"></a>蓝牙低功耗</h2><p>Android 4.3 为发挥核心作用的蓝牙低功耗（蓝牙 LE）引入了平台支持。在 Android 5.0 中，Android 设备现在可以发挥蓝牙 LE 外围设备的作用。应用可以利用此功能让附近设备发现它。例如，您可以开发这样的应用：让设备发挥计步器或健康监测仪的作用，并与其他蓝牙 LE 设备进行数据通信。</p><p>新增的 <code>android.bluetooth.le</code> API 让您的应用可以发布广告、扫描响应以及与附近的蓝牙 LE 设备建立连接。要使用新增的广告和扫描功能，请在您的清单中添加 <code>BLUETOOTH_ADMIN</code> 权限。当用户更新您的应用或从 Play 商店下载您的应用时，会被要求向您的应用授予以下权限：“Bluetooth connection information:Allows the app to control Bluetooth, including broadcasting to or getting information about nearby Bluetooth devices.”</p><p>要启动蓝牙 LE 广播，以便其他设备能发现您的应用，请调用 <code>startAdvertising()</code>，并传入 <code>AdvertiseCallback</code> 类的实现。回调对象会收到广播操作成功或失败的报告。</p><p>Android 5.0 引入了 <code>ScanFilter</code> 类，让您的应用可以只扫描其感兴趣的特定类型设备。要开始扫描蓝牙 LE 设备，请调用 <code>startScan()</code>，并传入筛选器列表。在方法调用中，您还必须提供 <code>ScanCallback</code> 的实现，以便在发现蓝牙 LE 广播时进行报告。</p><h2 id="NFC-增强功能"><a href="#NFC-增强功能" class="headerlink" title="NFC 增强功能"></a>NFC 增强功能</h2><p>Android 5.0 添加这些增强功能是为了扩大 NFC 的使用范围和提高 NFC 的使用灵活性：</p><ul><li>Android Beam 现已出现在 share 菜单中。</li><li>您的应用可通过调用 <code>invokeBeam()</code> 来调用用户设备上的 Android Beam 进行数据分享。这样一来，用户不必手动用设备接触另一台具有 NFC 功能的设备，便可完成数据传送。</li><li>您可以使用新增的 <code>createTextRecord()</code> 方法来创建一条包含 UTF-8 文本数据的 NDEF 记录。</li><li>如果您要开发支付应用，现在可以通过调用 <code>registerAidsForService()</code> 动态注册 NFC 应用 ID (AID)。您还可以使用 <code>setPreferredService()</code> 来设置应在特定 Activity 位于前台时使用的首选卡模拟服务。</li></ul><h1 id="Volta-项目"><a href="#Volta-项目" class="headerlink" title="Volta 项目"></a>Volta 项目</h1><p>除了提供新功能外，Android 5.0 还重视电池寿命的改善。可以利用新增的 API 和工具来了解和优化您的应用的功耗。</p><h2 id="计划排定作业"><a href="#计划排定作业" class="headerlink" title="计划排定作业"></a>计划排定作业</h2><p>Android 5.0 新增了一个 <code>JobScheduler</code> API，允许您定义一些系统在稍后或指定条件下（如设备充电时）以异步方式运行的作业，从而优化电池寿命。下列情形下，作业计划排定功能很有用：</p><ul><li>应用具有不面向用户并且可以推迟的作业<br>-应用具有您更愿意在设备插入电源时再进行的作业</li><li>应用具有一项需要接入网络或连接 WLAN 的任务。</li><li>应用具有多项您希望定期以批处理方式运行的任务。</li></ul><p>一个作业单位由一个 <code>JobInfo</code> 对象封装。该对象指定计划排定标准。</p><p>使用 <code>JobInfo.Builder</code> 类可配置应如何运行已排计划的任务。您可以安排任务在特定条件下运行，例如：</p><ul><li>在设备充电时启动</li><li>在设备连入无限流量网络时启动</li><li>在设备空闲时启动</li><li>在特定期限前或以最低延迟完成</li></ul><p>例如，您可以添加一段如下代码，在无限流量网络上运行您的任务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JobInfo uploadTask = <span class="keyword">new</span> JobInfo.Builder(mJobId,</span><br><span class="line">                                         mServiceComponent <span class="comment">/* JobService component */</span>)</span><br><span class="line">        .setRequiredNetworkCapabilities(JobInfo.NetworkType.UNMETERED)</span><br><span class="line">        .build();</span><br><span class="line">JobScheduler jobScheduler =</span><br><span class="line">        (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line">jobScheduler.schedule(uploadTask);</span><br></pre></td></tr></table></figure></p><p>如果设备有稳定的电源（也就是说，设备已插入电源超过 2 分钟，并且电池处于<a href="https://developer.android.com/reference/android/content/Intent.html#ACTION_BATTERY_OKAY" target="_blank" rel="noopener">健康水平</a>），系统将运行任何已做好运行准备的计划作业，无论作业期限是否已过。</p><p>要查看如何使用 <code>JobScheduler</code> API 的示例，请参阅此版本中的 <code>JobSchedulerSample</code> 实现示例。</p><h2 id="电池使用开发者工具"><a href="#电池使用开发者工具" class="headerlink" title="电池使用开发者工具"></a>电池使用开发者工具</h2><p>新增的 <strong>dumpsys batterystats</strong> 命令可生成值得关注的设备电池使用情况统计数据，这些数据按唯一身份用户 ID (UID) 加以组织。统计数据包括：</p><ul><li>电池相关事件的历史记录</li><li>设备的全局统计数据</li><li>每个 UID 和系统组件的近似耗电情况</li><li>每个应用的每数据包移动 ms</li><li>系统 UID 汇总统计数据</li><li>应用 UID 汇总统计数据</li></ul><p>可使用 –help 选项来了解各种输出定制选项的相关信息。例如，要打印设备上次充电后某个给定应用软件包的电池使用情况统计信息，请运行以下命令：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell dumpsys batterystats --charged &lt;package-name&gt;</span><br></pre></td></tr></table></figure></p><p>您可以使用<a href="https://github.com/google/battery-historian" target="_blank" rel="noopener">电池耗电历史</a>工具对 dumpsys 命令输出的数据进行处理，根据日志生成用电相关事件的 HTML 可视化形式。这些信息可方便您了解和诊断任何电池相关问题。</p><h1 id="工作场所和教育领域中的-Android"><a href="#工作场所和教育领域中的-Android" class="headerlink" title="工作场所和教育领域中的 Android"></a>工作场所和教育领域中的 Android</h1><hr><h2 id="托管配置"><a href="#托管配置" class="headerlink" title="托管配置"></a>托管配置</h2><p>Android 5.0 提供了用于在企业环境内运行应用的新功能。如果用户已有个人帐户，则设备管理员可启动托管配置进程，向设备添加共存但独立的托管配置文件。与托管配置文件关联的应用与非托管应用一并出现在用户的启动器、最近使用的应用屏幕和通知中。</p><p>要启动托管配置进程，请通过 <code>Intent</code> 发送 <code>ACTION_PROVISION_MANAGED_PROFILE</code>。如果调用成功，系统会触发 <code>onProfileProvisioningComplete()</code> 回调。然后您就可以调用 <code>setProfileEnabled()</code> 来启用此托管配置文件。</p><p>默认情况下，托管配置文件中只启用了一小部分应用。您可以通过调用 <code>enableSystemApp()</code> 在托管配置文件中安装更多应用。</p><p>如果您要开发启动器应用，可以使用新增的 <code>LauncherApps</code> 类获取可为当前用户启动的 Activity 以及任何关联托管配置文件的列表。您的启动器可通过向可绘制图标追加工作徽章，以醒目方式显示托管应用。要检索带徽章的图标，请调用 <code>getUserBadgedIcon()</code>。</p><p>要查看如何使用新功能，请参阅此版本中的 <strong>BasicManagedProfile</strong> 实现示例。</p><h2 id="设备所有者"><a href="#设备所有者" class="headerlink" title="设备所有者"></a>设备所有者</h2><p>Android 5.0 引入了部署设备所有者应用的功能。设备所有者是一种专业化类型的设备管理员，额外拥有在设备上创建和移除二级用户以及配置全局设置的能力。您的设备所有者应用可以使用 <code>DevicePolicyManager</code> 类中的方法对托管设备上的配置、安全性和应用进行精细控制。一台设备在同一时间只能有一名活动的设备所有者。</p><p>要部署和激活设备所有者，您必须在设备处于未配置状态时执行从编程应用到设备的 NFC 数据传送。此数据传送发送的信息与托管配置中所述配置 intent 中发送的信息相同。</p><h2 id="固定屏幕"><a href="#固定屏幕" class="headerlink" title="固定屏幕"></a>固定屏幕</h2><p>Android 5.0 引入了一个全新的固定屏幕 API，可让您暂时限制用户离开您的任务或被通知打断。举例来说，如果您要开发一款教育应用来支持 Android 上的高风险评估要求，或者您要开发单一用途或信息亭模式下的应用，便可使用此 API。您的应用激活固定屏幕后，在其退出该模式前，用户将无法看到通知，无法访问其他应用，也无法返回主屏幕。</p><p>激活固定屏幕的方式有两种：</p><ul><li><strong>手动方式：</strong>用户可以在 <em>Settings &gt; Security &gt; Screen Pinning</em> 中启用固定屏幕，然后通过触摸最近使用的应用屏幕中的绿色大头针图标选择其想固定的任务。</li><li><strong>编程方式：</strong>要以编程方式激活固定屏幕，请在您的应用内调用 <code>startLockTask()</code>。如果请求应用不是设备所有者，系统会提示用户进行确认。设备所有者应用可以调用 <code>setLockTaskPackages()</code> 方法，无需执行用户确认步骤便可使应用变为可固定应用。</li></ul><p>激活任务锁定时，会发生以下行为：</p><ul><li>状态栏空白，并隐藏用户通知和状态信息。</li><li>“主屏幕”按钮和“最近用过的应用”按钮处于隐藏状态。</li><li>其他应用无法启动新 Activity</li><li>当前应用可以启动新 Activity，前提是这样做不会创建新任务。</li><li>当设备所有者调用固定屏幕时，用户将一直锁定于您的应用，直至应用调用 stopLockTask()。</li><li>如果固定屏幕是由并非设备所有者的其他应用启动的 Activity，或者是由用户直接启动，则用户可通过同时按住“Back”按钮和“Recent”按钮退出。<h1 id="打印框架"><a href="#打印框架" class="headerlink" title="打印框架"></a>打印框架</h1></li></ul><hr><p>##将 PDF 渲染成位图<br>您现在可以利用新增的 <code>PdfRenderer</code> 类，将 PDF 文档页面渲染成位图图像后进行打印。您必须指定一个可查找（即内容可随机访问的） <code>ParcelFileDescriptor</code>，系统会在其上写入可打印内容。您的应用可通过 <code>openPage()</code> 获得要渲染的页面，然后调用 <code>render()</code> 将打开的 <code>PdfRenderer.Page</code> 转换成位图。如果您只想将文档的一部分转换成位图图像（例如，为了实现平铺渲染以便放大文档），还可以设置其他参数。</p><p>要查看新 API 使用方法的示例，请参阅 <strong>PdfRendererBasic</strong> 示例。</p><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><hr><h2 id="应用使用情况统计信息"><a href="#应用使用情况统计信息" class="headerlink" title="应用使用情况统计信息"></a>应用使用情况统计信息</h2><p>现在可以利用新增的 <code>android.app.usage</code> API 访问 Android 设备上的应用使用历史记录。此 API 提供比已弃用的 <code>getRecentTasks()</code> 方法更为详细的使用信息。要使用此 API，您必须先在清单中声明 <strong>“android.permission.PACKAGE_USAGE_STATS”</strong> 权限。用户还必须通过 <em>Settings &gt; Security &gt; Apps</em> 为该应用启用访问使用情况的权限。</p><p>系统以应用为单位收集使用数据，按天、周、月和年汇总数据。系统保留这些数据的最长持续时间如下：</p><ul><li>每日数据：7 天</li><li>每周数据：4 周</li><li>每月数据：6 个月</li><li>每年数据：2 年</li></ul><p>系统会为每个应用记录以下数据：</p><ul><li>最后一次使用应用的时间</li><li>在该时间间隔（以天、周、月或年为单位）内应用位于前台的总时长</li><li>一天之中当组件（以软件包和 Activity 名称标识）转入前台或后台时记录的时间戳</li><li>设备配置发生变化（如设备屏幕方向因旋转而发生变化）时记录的时间戳</li></ul><h1 id="测试与辅助工具"><a href="#测试与辅助工具" class="headerlink" title="测试与辅助工具"></a>测试与辅助工具</h1><hr><h2 id="测试与辅助工具改进"><a href="#测试与辅助工具改进" class="headerlink" title="测试与辅助工具改进"></a>测试与辅助工具改进</h2><p>Android 5.0 添加了以下测试与无障碍功能支持：</p><ul><li>新增的 <code>getWindowAnimationFrameStats()</code>和 <code>getWindowContentFrameStats()</code>方法可采集窗口动画和内容的帧统计信息。这些方法让您可以编写仪器测试，以评估应用渲染帧时的刷新频率是否足以提供流畅的用户体验。</li><li>新增的 <code>executeShellCommand()</code> 方法让您可以在仪器测试中执行 shell 命令。命令的执行方式与从已连接到设备的主机运行 <strong>adb shell</strong> 类似，允许您使用 <strong>dumpsys</strong>、<strong>am</strong>、<strong>content</strong> 和 <strong>pm</strong> 等基于 shell 的工具。</li><li>使用无障碍功能 API 的无障碍服务和测试工具（如 UiAutomator）现在可以检索视力健全的用户可与之交互的屏幕上各窗口属性的相关详细信息。要检索 <code>AccessibilityWindowInfo</code> 对象列表，请调用新增的 <code>getWindows()</code> 方法。</li><li>新增的 <code>AccessibilityNodeInfo.AccessibilityAction</code> 类允许您定义要在 <code>AccessibilityNodeInfo</code> 上执行的标准或自定义操作。新增的 <code>AccessibilityNodeInfo.AccessibilityAction</code> 类取代了以前在 <code>AccessibilityNodeInfo</code> 中提供的与操作有关的 API。</li><li>Android 5.0 可对您应用内的文本语音转换合成进行更精细的控制。新增的 Voice 类允许您的应用使用关联了特定语言区域、质量和延时评级以及文本语音转换引擎专属参数的语音配置文件。</li></ul><h1 id="IME"><a href="#IME" class="headerlink" title="IME"></a>IME</h1><hr><h2 id="更方便的输入语言切换"><a href="#更方便的输入语言切换" class="headerlink" title="更方便的输入语言切换"></a>更方便的输入语言切换</h2><p>从 Android 5.0 开始，用户可以更方便地在平台支持的所有输入法编辑器 (IME) 之间切换。执行指定的切换操作（通常是触摸软键盘上的地球图标）可在所有此类 IME 中循环切换。此行为变更是由 shouldOfferSwitchingToNextInputMethod() 方法实现的。</p><p>此外，框架现在会检查下一个 IME 是否具有切换机制（并进而检查该 IME 是否支持切换到其后的 IME）。具有切换机制的 IME 将不会循环切换到不具有该机制的 IME。此行为变更是由 switchToNextInputMethod() 方法实现的。</p><p>要查看如何使用更新后的 IME 切换 API 的示例，请参阅此版本中更新后的软键盘实现示例。要详细了解如何实现 IME 切换，请参阅创建输入法。</p><h1 id="清单声明"><a href="#清单声明" class="headerlink" title="清单声明"></a>清单声明</h1><hr><h2 id="可声明的必备功能"><a href="#可声明的必备功能" class="headerlink" title="可声明的必备功能"></a>可声明的必备功能</h2><p>现在支持在 <code>&lt;uses-feature&gt;</code> 元素中使用以下值，以便您确保只在提供应用所需功能的设备上安装您的应用。</p><ul><li><code>FEATURE_AUDIO_OUTPUT</code></li><li><code>FEATURE_CAMERA_CAPABILITY_MANUAL_POST_PROCESSING</code></li><li><code>FEATURE_CAMERA_CAPABILITY_MANUAL_SENSOR</code></li><li><code>FEATURE_CAMERA_CAPABILITY_RAW</code></li><li><code>FEATURE_CAMERA_LEVEL_FULL</code></li><li><code>FEATURE_GAMEPAD</code></li><li><code>FEATURE_LIVE_TV</code></li><li><code>FEATURE_MANAGED_USERS</code></li><li><code>FEATURE_LEANBACK</code></li><li><code>FEATURE_OPENGLES_EXTENSION_PACK</code></li><li><code>FEATURE_SECURELY_REMOVES_USERS</code></li><li><code>FEATURE_SENSOR_AMBIENT_TEMPERATURE</code></li><li><code>FEATURE_SENSOR_HEART_RATE_ECG</code></li><li><code>FEATURE_SENSOR_RELATIVE_HUMIDITY</code></li><li><code>FEATURE_VERIFIED_BOOT</code></li><li><code>FEATURE_WEBVIEW</code><h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2>现在，<code>&lt;uses-permission&gt;</code> 元素中支持以下权限，以声明您的应用访问特定 API 所需的权限。</li></ul><p><code>BIND_DREAM_SERVICE</code>：如果针对的是 API 级别 21 及更高级别，则互动屏保服务必须获得该权限才能确保只有系统可与其绑定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用户界面&quot;&gt;&lt;a href=&quot;#用户界面&quot; class=&quot;headerlink&quot; title=&quot;用户界面&quot;&gt;&lt;/a&gt;用户界面&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Material-Design-支持&quot;&gt;&lt;a href=&quot;#Material-Design-支持&quot; cl
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Lollipop" scheme="http://yoursite.com/tags/Lollipop/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
      <category term="Android  5.0" scheme="http://yoursite.com/tags/Android-5-0/"/>
    
  </entry>
  
  <entry>
    <title>任务和返回栈</title>
    <link href="http://yoursite.com/2014/04/10/tasks-and-back-stack/"/>
    <id>http://yoursite.com/2014/04/10/tasks-and-back-stack/</id>
    <published>2014-04-10T01:27:34.000Z</published>
    <updated>2018-04-10T01:42:51.427Z</updated>
    
    <content type="html"><![CDATA[<p>应用通常包含多个 Activity。每个 Activity 均应围绕用户可以执行的特定操作设计，并且能够启动其他 Activity。 例如，电子邮件应用可能有一个 Activity 显示新邮件的列表。用户选择某邮件时，会打开一个新 Activity 以查看该邮件。</p><p>一个 Activity 甚至可以启动设备上其他应用中存在的 Activity。例如，如果应用想要发送电子邮件，则可将 Intent 定义为执行“发送”操作并加入一些数据，如电子邮件地址和电子邮件。 然后，系统将打开其他应用中声明自己处理此类 Intent 的 Activity。在这种情况下，Intent 是要发送电子邮件，因此将启动电子邮件应用的“撰写”Activity（如果多个 Activity 支持相同 Intent，则系统会让用户选择要使用的 Activity）。发送电子邮件时，Activity 将恢复，看起来好像电子邮件 Activity 是您的应用的一部分。 即使这两个 Activity 可能来自不同的应用，但是 Android 仍会将 Activity 保留在相同的任务中，以维护这种无缝的用户体验。</p><p>任务是指在执行特定作业时与用户交互的一系列 Activity。 这些 Activity 按照各自的打开顺序排列在堆栈（即返回栈）中。</p><p>设备主屏幕是大多数任务的起点。当用户触摸应用启动器中的图标（或主屏幕上的快捷方式）时，该应用的任务将出现在前台。 如果应用不存在任务（应用最近未曾使用），则会创建一个新任务，并且该应用的“主”Activity 将作为堆栈中的根 Activity 打开。</p><p>当前 Activity 启动另一个 Activity 时，该新 Activity 会被推送到堆栈顶部，成为焦点所在。 前一个 Activity 仍保留在堆栈中，但是处于停止状态。Activity 停止时，系统会保持其用户界面的当前状态。 用户按“返回”按钮时，当前 Activity 会从堆栈顶部弹出（Activity 被销毁），而前一个 Activity 恢复执行（恢复其 UI 的前一状态）。 堆栈中的 Activity 永远不会重新排列，仅推入和弹出堆栈：由当前 Activity 启动时推入堆栈；用户使用“返回”按钮退出时弹出堆栈。 因此，返回栈以“后进先出”对象结构运行。 图 1 通过时间线显示 Activity 之间的进度以及每个时间点的当前返回栈，直观呈现了这种行为。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2014/04/10/tasks-and-back-stack/diagram_backstack.png" alt="t1" title="">                </div>                <div class="image-caption">t1</div>            </figure></p><font style="font-size: 12px">图 1. 显示任务中的每个新 Activity 如何向返回栈添加项目。 用户按“返回”按钮时，当前 Activity 随即被销毁，而前一个 Activity 恢复执行。</font><p>如果用户继续按“返回”，堆栈中的相应 Activity 就会弹出，以显示前一个 Activity，直到用户返回主屏幕为止（或者，返回任务开始时正在运行的任意 Activity）。 当所有 Activity 均从堆栈中移除后，任务即不复存在。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2014/04/10/tasks-and-back-stack/diagram_multitasking.png" alt="t2" title="">                </div>                <div class="image-caption">t2</div>            </figure><font style="font-size:12px">图 2. 两个任务：任务 B 在前台接收用户交互，而任务 A 则在后台等待恢复。</font><p>任务是一个有机整体，当用户开始新任务或通过“主页”按钮转到主屏幕时，可以移动到“后台”。 尽管在后台时，该任务中的所有 Activity 全部停止，但是任务的返回栈仍旧不变，也就是说，当另一个任务发生时，该任务仅仅失去焦点而已，如图 2 中所示。然后，任务可以返回到“前台”，用户就能够回到离开时的状态。 例如，假设当前任务（任务 A）的堆栈中有三个 Activity，即当前 Activity 下方还有两个 Activity。 用户先按“主页”按钮，然后从应用启动器启动新应用。 显示主屏幕时，任务 A 进入后台。新应用启动时，系统会使用自己的 Activity 堆栈为该应用启动一个任务（任务 B）。与该应用交互之后，用户再次返回主屏幕并选择最初启动任务 A 的应用。现在，任务 A 出现在前台，其堆栈中的所有三个 Activity 保持不变，而位于堆栈顶部的 Activity 则会恢复执行。 此时，用户还可以通过转到主屏幕并选择启动该任务的应用图标（或者，通过从<a href="https://developer.android.com/guide/components/recents.html" target="_blank" rel="noopener">概览屏幕</a>选择该应用的任务）切换回任务 B。这是 Android 系统中的一个多任务示例。</p><blockquote><p><strong>注：</strong>后台可以同时运行多个任务。但是，如果用户同时运行多个后台任务，则系统可能会开始销毁后台 Activity，以回收内存资源，从而导致 Activity 状态丢失。请参阅下面有关 <a href="https://developer.android.com/guide/components/tasks-and-back-stack.html#ActivityState" target="_blank" rel="noopener">Activity 状态</a>的部分。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2014/04/10/tasks-and-back-stack/diagram_multiple_instances.png" alt="t3" title="">                </div>                <div class="image-caption">t3</div>            </figure><font style="font-size:12px">图 3. 一个 Activity 将多次实例化。</font><br>由于返回栈中的 Activity 永远不会重新排列，因此如果应用允许用户从多个 Activity 中启动特定 Activity，则会创建该 Activity 的新实例并推入堆栈中（而不是将 Activity 的任一先前实例置于顶部）。 因此，应用中的一个 Activity 可能会多次实例化（即使 Activity 来自不同的任务），如图 3 所示。因此，如果用户使用“返回”按钮向后导航，则会按 Activity 每个实例的打开顺序显示这些实例（每个实例的 UI 状态各不相同）。 但是，如果您不希望 Activity 多次实例化，则可修改此行为。 具体操作方法将在后面的管理任务部分中讨论。<br><br>Activity 和任务的默认行为总结如下：<br><br>- 当 Activity A 启动 Activity B 时，Activity A 将会停止，但系统会保留其状态（例如，滚动位置和已输入表单中的文本）。如果用户在处于 Activity B 时按“返回”按钮，则 Activity A 将恢复其状态，继续执行。<br>- 用户通过按“主页”按钮离开任务时，当前 Activity 将停止且其任务会进入后台。 系统将保留任务中每个 Activity 的状态。如果用户稍后通过选择开始任务的启动器图标来恢复任务，则任务将出现在前台并恢复执行堆栈顶部的 Activity。<br>- 如果用户按“返回”按钮，则当前 Activity 会从堆栈弹出并被销毁。 堆栈中的前一个 Activity 恢复执行。销毁 Activity 时，系统不会保留该 Activity 的状态。<br>- 即使来自其他任务，Activity 也可以多次实例化。<br>&gt;<strong>导航设计</strong><br>如需了解有关 Android 应用导航工作方式的详细信息，请阅读 Android 设计的导航指南。<br><br># 保存 Activity 状态<br>—<br>正如上文所述，当 Activity 停止时，系统的默认行为会保留其状态。 这样一来，当用户导航回到上一个 Activity 时，其用户界面与用户离开时一样。 但是，在 Activity 被销毁且必须重建时，您可以而且应当主动使用回调方法保留 Activity 的状态。<br><br>系统停止您的一个 Activity 时（例如，新 Activity 启动或任务转到前台），如果系统需要回收系统内存资源，则可能会完全销毁该 Activity。 发生这种情况时，有关该 Activity 状态的信息将会丢失。如果发生这种情况，系统仍会知道该 Activity 存在于返回栈中，但是当该 Activity 被置于堆栈顶部时，系统一定会重建 Activity（而不是恢复 Activity）。 为了避免用户的工作丢失，您应主动通过在 Activity 中实现 onSaveInstanceState() 回调方法来保留工作。<br><br>如需了解有关如何保存 Activity 状态的详细信息，请参阅 Activity 文档。<br><br># 管理任务<br>—<br>Android 管理任务和返回栈的方式（如上所述，即：将所有连续启动的 Activity 放入同一任务和“后进先出”堆栈中）非常适用于大多数应用，而您不必担心 Activity 如何与任务关联或者如何存在于返回栈中。 但是，您可能会决定要中断正常行为。 也许您希望应用中的 Activity 在启动时开始新任务（而不是放置在当前任务中）；或者，当启动 Activity 时，您希望将其现有实例上移一层（而不是在返回栈的顶部创建新实例）；或者，您希望在用户离开任务时，清除返回栈中除根 Activity 以外的所有其他 Activity。<br><br>通过使用 <code>&lt;activity&gt;</code> 清单文件元素中的属性和传递给 <code>startActivity()</code> 的 Intent 中的标志，您可以执行所有这些操作以及其他操作。<br><br>在这一方面，您可以使用的主要 <code>&lt;activity&gt;</code> 属性包括：<br><br><code>taskAffinity</code><br><code>launchMode</code><br><code>allowTaskReparenting</code><br><code>clearTaskOnLaunch</code><br><code>alwaysRetainTaskState</code><br><code>finishOnTaskLaunch</code><br>您可以使用的主要 Intent 标志包括：<br><br><code>FLAG_ACTIVITY_NEW_TASK</code><br><code>FLAG_ACTIVITY_CLEAR_TOP</code><br><code>FLAG_ACTIVITY_SINGLE_TOP</code><br>在下文中，您将了解如何使用这些清单文件属性和 Intent 标志定义 Activity 与任务的关联方式，以及 Activity 在返回栈中的行为方式。<br><br>此外，我们还单独介绍了有关如何在概览屏幕中显示和管理任务与 Activity 的注意事项。 如需了解详细信息，请参阅概览屏幕。 通常，您应该允许系统定义任务和 Activity 在概览屏幕中的显示方法，并且无需修改此行为。<br><br>&gt;<strong>注意：</strong>大多数应用都不得中断 Activity 和任务的默认行为： 如果确定您的 Activity 必须修改默认行为，当使用“返回”按钮从其他 Activity 和任务导航回到该 Activity 时，请务必要谨慎并确保在启动期间测试该 Activity 的可用性。请确保测试导航行为是否有可能与用户的预期行为冲突。<br><br>## 定义启动模式<br>启动模式允许您定义 Activity 的新实例如何与当前任务关联。 您可以通过两种方法定义不同的启动模式：<br><br><strong>使用清单文件</strong><br>在清单文件中声明 Activity 时，您可以指定 Activity 在启动时应该如何与任务关联。<br><br><strong>使用 Intent 标志</strong><br>调用 <code>startActivity()</code> 时，可以在 <code>Intent</code> 中加入一个标志，用于声明新 Activity 如何（或是否）与当前任务关联。<br><br>因此，如果 Activity A 启动 Activity B，则 Activity B 可以在其清单文件中定义它应该如何与当前任务关联（如果可能），并且 Activity A 还可以请求 Activity B 应该如何与当前任务关联。如果这两个 Activity 均定义 Activity B 应该如何与任务关联，则 Activity A 的请求（如 Intent 中所定义）优先级要高于 Activity B 的请求（如其清单文件中所定义）。<br><br>&gt;<strong>注：</strong>某些适用于清单文件的启动模式不可用作 Intent 标志，同样，某些可用作 Intent 标志的启动模式无法在清单文件中定义。<br><br>#### 使用清单文件<br>在清单文件中声明 Activity 时，您可以使用 <code>&lt;activity&gt;</code> 元素的 <code>launchMode</code> 属性指定 Activity 应该如何与任务关联。<br><br><code>launchMode</code> 属性指定有关应如何将 Activity 启动到任务中的指令。您可以分配给 <code>launchMode</code> 属性的启动模式共有四种：<br><br><strong>“standard”（默认模式）</strong><br>默认。系统在启动 Activity 的任务中创建 Activity 的新实例并向其传送 Intent。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例。<br><strong>“singleTop”</strong><br>如果当前任务的顶部已存在 Activity 的一个实例，则系统会通过调用该实例的 <code>onNewIntent()</code> 方法向其传送 Intent，而不是创建 Activity 的新实例。Activity 可以多次实例化，而每个实例均可属于不同的任务，并且一个任务可以拥有多个实例（但前提是位于返回栈顶部的 Activity 并不是 Activity 的现有实例）。<br>例如，假设任务的返回栈包含根 Activity A 以及 Activity B、C 和位于顶部的 D（堆栈是 A-B-C-D；D 位于顶部）。收到针对 D 类 Activity 的 Intent。如果 D 具有默认的 “standard” 启动模式，则会启动该类的新实例，且堆栈会变成 A-B-C-D-D。但是，如果 D 的启动模式是 “singleTop”，则 D 的现有实例会通过 <code>onNewIntent()</code> 接收 Intent，因为它位于堆栈的顶部；而堆栈仍为 A-B-C-D。但是，如果收到针对 B 类 Activity 的 Intent，则会向堆栈添加 B 的新实例，即便其启动模式为 “singleTop” 也是如此。<br><br>&gt;<strong>注：</strong>为某个 Activity 创建新实例时，用户可以按“返回”按钮返回到前一个 Activity。 但是，当 Activity 的现有实例处理新 Intent 时，则在新 Intent 到达 onNewIntent() 之前，用户无法按“返回”按钮返回到 Activity 的状态。<br><br><strong>“singleTask”</strong><br>系统创建新任务并实例化位于新任务底部的 Activity。但是，如果该 Activity 的一个实例已存在于一个单独的任务中，则系统会通过调用现有实例的 onNewIntent() 方法向其传送 Intent，而不是创建新实例。一次只能存在 Activity 的一个实例。<br>&gt;<strong>注：</strong>尽管 Activity 在新任务中启动，但是用户按“返回”按钮仍会返回到前一个 Activity。<br><br><strong>“singleInstance”.</strong><br>与 “singleTask” 相同，只是系统不会将任何其他 Activity 启动到包含实例的任务中。该 Activity 始终是其任务唯一仅有的成员；由此 Activity 启动的任何 Activity 均在单独的任务中打开。<br><br>我们再来看另一示例，Android 浏览器应用声明网络浏览器 Activity 应始终在其自己的任务中打开（通过在 <code>&lt;activity&gt;</code> 元素中指定 singleTask 启动模式）。这意味着，如果您的应用发出打开 Android 浏览器的 Intent，则其 Activity 与您的应用位于不同的任务中。相反，系统会为浏览器启动新任务，或者如果浏览器已有任务正在后台运行，则会将该任务上移一层以处理新 Intent。<br><br>无论 Activity 是在新任务中启动，还是在与启动 Activity 相同的任务中启动，用户按“返回”按钮始终会转到前一个 Activity。 但是，如果启动指定 <code>singleTask</code> 启动模式的 Activity，则当某后台任务中存在该 Activity 的实例时，整个任务都会转移到前台。此时，返回栈包括上移到堆栈顶部的任务中的所有 Activity。 图 4 显示了这种情况。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2014/04/10/tasks-and-back-stack/diagram_backstack_singletask_multiactivity.png" alt="t4" title="">                </div>                <div class="image-caption">t4</div>            </figure><br><br><font style="font-size:14px">图 4. 显示如何将启动模式为“singleTask”的 Activity 添加到返回栈。 如果 Activity 已经是某个拥有自己的返回栈的后台任务的一部分，则整个返回栈也会上移到当前任务的顶部。</font><p>如需了解有关在清单文件中使用启动模式的详细信息，请参阅 <activity> 元素文档，其中更详细地讨论了 launchMode 属性和可接受的值。</activity></p><blockquote><p><strong>注：</strong>使用 launchMode 属性为 Activity 指定的行为可由 Intent 附带的 Activity 启动标志替代，下文将对此进行讨论。</p></blockquote><h4 id="使用-Intent-标志"><a href="#使用-Intent-标志" class="headerlink" title="使用 Intent 标志"></a>使用 Intent 标志</h4><p>启动 Activity 时，您可以通过在传递给 startActivity() 的 Intent 中加入相应的标志，修改 Activity 与其任务的默认关联方式。可用于修改默认行为的标志包括：</p><p><code>FLAG_ACTIVITY_NEW_TASK</code><br>　　在新任务中启动 Activity。如果已为正在启动的 Activity 运行任务，则该任务会转到前台并恢复其最后状态，同时 Activity 会在 <code>onNewIntent()</code> 中收到新 Intent。<br>正如前文所述，这会产生与<code>&quot;singleTask&quot;</code>launchMode 值相同的行为。</p><p><code>FLAG_ACTIVITY_SINGLE_TOP</code><br>　　如果正在启动的 Activity 是当前 Activity（位于返回栈的顶部），则 现有实例会接收对 <code>onNewIntent()</code> 的调用，而不是创建 Activity 的新实例。<br>正如前文所述，这会产生与 <code>&quot;singleTop&quot;</code>launchMode 值相同的行为。</p><p><code>FLAG_ACTIVITY_CLEAR_TOP</code><br>　　如果正在启动的 Activity 已在当前任务中运行，则会销毁当前任务顶部的所有 Activity，并通过 <code>onNewIntent()</code> 将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例。<br>产生这种行为的 launchMode 属性没有值。</p><p><code>FLAG_ACTIVITY_CLEAR_TOP</code> 通常与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用。一起使用时，通过这些标志，可以找到其他任务中的现有 Activity，并将其放入可从中响应 Intent 的位置。</p><blockquote><p><strong>注：</strong>如果指定 Activity 的启动模式为 “standard”，则该 Activity 也会从堆栈中移除，并在其位置启动一个新实例，以便处理传入的 Intent。 这是因为当启动模式为 “standard” 时，将始终为新 Intent 创建新实例。</p></blockquote><h2 id="处理关联"><a href="#处理关联" class="headerlink" title="处理关联"></a>处理关联</h2><p>“关联”指示 Activity 优先属于哪个任务。默认情况下，同一应用中的所有 Activity 彼此关联。 因此，默认情况下，同一应用中的所有 Activity 优先位于相同任务中。 不过，您可以修改 Activity 的默认关联。 在不同应用中定义的 Activity 可以共享关联，或者可为在同一应用中定义的 Activity 分配不同的任务关联。</p><p>可以使用 <code>&lt;activity&gt;</code> 元素的 <code>taskAffinity</code> 属性修改任何给定 Activity 的关联。</p><p>taskAffinity 属性取字符串值，该值必须不同于在 <code>&lt;manifest&gt;</code> 元素中声明的默认软件包名称，因为系统使用该名称标识应用的默认任务关联。</p><p>在两种情况下，关联会起作用：</p><ul><li><p>启动 Activity 的 Intent 包含 FLAG_ACTIVITY_NEW_TASK 标志。<br>默认情况下，新 Activity 会启动到调用 startActivity() 的 Activity 任务中。它将推入与调用方相同的返回栈。 但是，如果传递给 startActivity() 的 Intent 包含 FLAG_ACTIVITY_NEW_TASK 标志，则系统会寻找其他任务来储存新 Activity。这通常是新任务，但未做强制要求。 如果现有任务与新 Activity 具有相同关联，则会将 Activity 启动到该任务中。 否则，将开始新任务。<br>如果此标志导致 Activity 开始新任务，且用户按“主页”按钮离开，则必须为用户提供导航回任务的方式。 有些实体（如通知管理器）始终在外部任务中启动 Activity，而从不作为其自身的一部分启动 Activity，因此它们始终将 FLAG_ACTIVITY_NEW_TASK 放入传递给 startActivity() 的 Intent 中。请注意，如果 Activity 能够由可以使用此标志的外部实体调用，则用户可以通过独立方式返回到启动的任务，例如，使用启动器图标（任务的根 Activity 具有 CATEGORY_LAUNCHER Intent 过滤器；请参阅下面的启动任务部分）。</p></li><li><p>Activity 将其 <code>allowTaskReparenting</code> 属性设置为 “true”。<br>在这种情况下，Activity 可以从其启动的任务移动到与其具有关联的任务（如果该任务出现在前台）。</p></li></ul><p>例如，假设将报告所选城市天气状况的 Activity 定义为旅行应用的一部分。 它与同一应用中的其他 Activity 具有相同的关联（默认应用关联），并允许利用此属性重定父级。当您的一个 Activity 启动天气预报 Activity 时，它最初所属的任务与您的 Activity 相同。 但是，当旅行应用的任务出现在前台时，系统会将天气预报 Activity 重新分配给该任务并显示在其中。</p><blockquote><p><strong>提示：</strong>如果从用户的角度来看，一个 .apk 文件包含多个“应用”，则您可能需要使用 <code>taskAffinity</code> 属性将不同关联分配给与每个“应用”相关的 Activity。</p></blockquote><h2 id="清理返回栈"><a href="#清理返回栈" class="headerlink" title="清理返回栈"></a>清理返回栈</h2><p>如果用户长时间离开任务，则系统会清除所有 Activity 的任务，根 Activity 除外。 当用户再次返回到任务时，仅恢复根 Activity。系统这样做的原因是，经过很长一段时间后，用户可能已经放弃之前执行的操作，返回到任务是要开始执行新的操作。</p><p>您可以使用下列几个 Activity 属性修改此行为：</p><p><code>alwaysRetainTaskState</code><br>　　如果在任务的根 Activity 中将此属性设置为 “true”，则不会发生刚才所述的默认行为。即使在很长一段时间后，任务仍将所有 Activity 保留在其堆栈中。<br><code>clearTaskOnLaunch</code><br>　　如果在任务的根 Activity 中将此属性设置为 “true”，则每当用户离开任务然后返回时，系统都会将堆栈清除到只剩下根 Activity。 换而言之，它与 alwaysRetainTaskState 正好相反。 即使只离开任务片刻时间，用户也始终会返回到任务的初始状态。<br><code>finishOnTaskLaunch</code><br>　　此属性类似于 clearTaskOnLaunch，但它对单个 Activity 起作用，而非整个任务。 此外，它还有可能会导致任何 Activity 停止，包括根 Activity。 设置为 “true” 时，Activity 仍是任务的一部分，但是仅限于当前会话。如果用户离开然后返回任务，则任务将不复存在。</p><h2 id="启动任务"><a href="#启动任务" class="headerlink" title="启动任务"></a>启动任务</h2><p>通过为 Activity 提供一个以 “android.intent.action.MAIN” 为指定操作、以 “android.intent.category.LAUNCHER” 为指定类别的 Intent 过滤器，您可以将 Activity 设置为任务的入口点。 例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>此类 Intent 过滤器会使 Activity 的图标和标签显示在应用启动器中，让用户能够启动 Activity 并在启动之后随时返回到创建的任务中。</p><p>第二个功能非常重要：用户必须能够在离开任务后，再使用此 Activity 启动器返回该任务。 因此，只有在 Activity 具有 <code>ACTION_MAIN</code> 和 <code>CATEGORY_LAUNCHER</code> 过滤器时，才应该使用将 Activity 标记为“始终启动任务”的两种启动模式，即 <strong>“singleTask”</strong> 和 <strong>“singleInstance”</strong>。例如，我们可以想像一下如果缺少过滤器会发生什么情况： Intent 启动一个 “singleTask” Activity，从而启动一个新任务，并且用户花了些时间处理该任务。然后，用户按“主页”按钮。 任务现已发送到后台，而且不可见。现在，用户无法返回到任务，因为该任务未显示在应用启动器中。</p><p>如果您并不想用户能够返回到 Activity，对于这些情况，请将 <code>&lt;activity&gt;</code> 元素的 finishOnTaskLaunch 设置为 “true”（请参阅清理堆栈）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应用通常包含多个 Activity。每个 Activity 均应围绕用户可以执行的特定操作设计，并且能够启动其他 Activity。 例如，电子邮件应用可能有一个 Activity 显示新邮件的列表。用户选择某邮件时，会打开一个新 Activity 以查看该邮件。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="LaunchMode" scheme="http://yoursite.com/tags/LaunchMode/"/>
    
  </entry>
  
</feed>
