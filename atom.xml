<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随手记</title>
  
  <subtitle>不积跬步无以至千里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-29T03:12:26.453Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>马建</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Native 自签名Https处理</title>
    <link href="http://yoursite.com/2018/03/28/react-native-https/"/>
    <id>http://yoursite.com/2018/03/28/react-native-https/</id>
    <published>2018-03-28T07:43:22.000Z</published>
    <updated>2018-03-29T03:12:26.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>现在绝大多数网站已转为https方式浏览，但很多情况下https的证书并不是CA颁发的合法证书，而是通过公司或个人自签名产生的证书。当我们在开发移动应用时，对于这种自签名证书，通常是需要额外的通过证书来校验访问的合法性。<br>当我们再开发React Native应用时，由于框架封装了网络请求库，造成我们无法自定义相关逻辑。本文的主要目的就是记录一下再开发过程中遇到此类问题是怎么解决的。</p><h2 id="IOS处理"><a href="#IOS处理" class="headerlink" title="IOS处理"></a>IOS处理</h2><ol><li>使用Xcode打开ios代码</li><li>在<code>Libraries</code>下展开 <code>RCTNetwork.xcodeproj</code> 找到 <code>RCTHTTPRequestHandler.m</code> 文件<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/03/28/react-native-https/26fa978f-a83b-4e49-b6b3-dab541da890c.png" alt="logo" title="">                </div>                <div class="image-caption">logo</div>            </figure></li><li><p>在文件中找到下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSURLSession delegate</span></span><br></pre></td></tr></table></figure></li><li><p>在此代码下方添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(<span class="keyword">void</span> (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">  completionHandler(NSURLSessionAuthChallengeUseCredential, [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编辑info.plist文件，修改如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/03/28/react-native-https/794c1115-612a-4e30-ac96-f1c2c8e8648f.png" alt="info.plist" title="">                </div>                <div class="image-caption">info.plist</div>            </figure><ol start="6"><li>完成配置，重新打包即可<h2 id="Android处理"><a href="#Android处理" class="headerlink" title="Android处理"></a>Android处理</h2>Android下React Native使用OKHTTP作为网络请求库，由于npm在安装react-native时已经编译过相关第三方依赖库，所以要改动依赖库中的代码，我们需要下载ReactAndroid的源代码，修改OKHTTP源码后重新编译。所以过程相对IOS会复杂很多，下面我们开始一步步来完成相关工作。</li><li>下载NDK，解压<br> NDK官方<a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip" target="_blank" rel="noopener">下载地址</a></li><li>local.properties 中设置ndk.dir.</li><li><p>修改<code>settings.gradle</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">':ReactAndroid'</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">':ReactAndroid'</span>).projectDir = <span class="keyword">new</span> <span class="keyword">File</span>(rootProject.projectDir, <span class="string">'../node_modules/react-native/ReactAndroid'</span>)</span><br></pre></td></tr></table></figure></li><li><p>修改<code>app/build.gradle</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compile "com.facebook.react:react-native:+"  // From node_modules</span></span><br><span class="line"><span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':ReactAndroid'</span>)</span><br><span class="line"><span class="comment">//可能在需要添加一下代码</span></span><br><span class="line"><span class="keyword">configurations</span>.all &#123;</span><br><span class="line"> <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.facebook.react'</span>, module: <span class="string">'react-native'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改ReactAndroid中OKHTTP相关源代码，打开<code>node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/network/OkHttpClientProvider.java</code>文件，修改文件内容为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClientProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Centralized OkHttpClient for all networking requests.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> OkHttpClient sClient;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient <span class="title">getOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">  sClient = createClient();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// okhttp3 OkHttpClient is immutable</span></span><br><span class="line">  <span class="comment">// This allows app to init an OkHttpClient with custom settings.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replaceOkHttpClient</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">  sClient = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient <span class="title">createClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// No timeouts by default</span></span><br><span class="line">  OkHttpClient.Builder client = getUnsafeOkHttpClient()</span><br><span class="line">  .connectTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">  .readTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">  .writeTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">  .cookieJar(<span class="keyword">new</span> ReactCookieJarContainer());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> enableTls12OnPreLollipop(client).build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  On Android 4.1-4.4 (API level 16 to 19) TLS 1.1 and 1.2 are</span></span><br><span class="line"><span class="comment">  available but not enabled by default. The following method</span></span><br><span class="line"><span class="comment">  enables it.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient.<span class="function">Builder <span class="title">enableTls12OnPreLollipop</span><span class="params">(OkHttpClient.Builder client)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN &amp;&amp; Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  client.sslSocketFactory(<span class="keyword">new</span> TLSSocketFactory());</span><br><span class="line"></span><br><span class="line">  ConnectionSpec cs = <span class="keyword">new</span> ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)</span><br><span class="line">  .tlsVersions(TlsVersion.TLS_1_2)</span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line">  List&lt;ConnectionSpec&gt; specs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  specs.add(cs);</span><br><span class="line">  specs.add(ConnectionSpec.COMPATIBLE_TLS);</span><br><span class="line">  specs.add(ConnectionSpec.CLEARTEXT);</span><br><span class="line"></span><br><span class="line">  client.connectionSpecs(specs);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception exc) &#123;</span><br><span class="line">  FLog.e(<span class="string">"OkHttpClientProvider"</span>, <span class="string">"Error while enabling TLS 1.2"</span>, exc);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient.<span class="function">Builder <span class="title">getUnsafeOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// Create a trust manager that does not validate certificate chains</span></span><br><span class="line">  <span class="keyword">final</span> TrustManager[] trustAllCerts = <span class="keyword">new</span> TrustManager[]&#123;</span><br><span class="line">  <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> java.security.cert.X509Certificate[]&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install the all-trusting trust manager</span></span><br><span class="line">  <span class="keyword">final</span> SSLContext sslContext = SSLContext.getInstance(<span class="string">"SSL"</span>);</span><br><span class="line">  sslContext.init(<span class="keyword">null</span>, trustAllCerts, <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line">  <span class="comment">// Create an ssl socket factory with our all-trusting manager</span></span><br><span class="line">  <span class="keyword">final</span> SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();</span><br><span class="line"></span><br><span class="line">  OkHttpClient.Builder builder = <span class="keyword">new</span> OkHttpClient.Builder();</span><br><span class="line">  builder.sslSocketFactory(sslSocketFactory);</span><br><span class="line">  builder.hostnameVerifier(<span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> builder;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行<code>react-native run-android</code>开始编译，过程中可能会报错，Google解决一下即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;现在绝大多数网站已转为https方式浏览，但很多情况下https的证书并不是CA颁发的合法证书，而是通过公司或个人自签名产生
      
    
    </summary>
    
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Android 8.0 行为变更</title>
    <link href="http://yoursite.com/2017/09/15/android-8-0-changes/"/>
    <id>http://yoursite.com/2017/09/15/android-8-0-changes/</id>
    <published>2017-09-15T03:02:23.000Z</published>
    <updated>2018-03-30T03:08:27.824Z</updated>
    
    <content type="html"><![CDATA[<p>Android 8.0 除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。</p><p>其中大部分变更会影响所有应用，而不论应用针对的是何种版本的 Android。不过，有几项变更仅影响针对 Android 8.0 的应用。为清楚起见，本页面分为两个部分：<strong>针对所有 API 级别的应用</strong>和<strong>针对 Android 8.0 的应用</strong>。</p><h1 id="针对所有-API-级别的应用"><a href="#针对所有-API-级别的应用" class="headerlink" title="针对所有 API 级别的应用"></a>针对所有 API 级别的应用</h1><hr><p>这些行为变更适用于 在 Android 8.0 平台上运行的 所有应用，无论这些应用是针对哪个 API 级别构建。所有开发者都应查看这些变更，并修改其应用以正确支持这些变更（如果适用）。</p><h2 id="后台执行限制"><a href="#后台执行限制" class="headerlink" title="后台执行限制"></a>后台执行限制</h2><p>Android 8.0 为提高电池续航时间而引入的变更之一是，当您的应用进入<strong>已缓存</strong>状态时，如果没有活动的<strong>组件</strong>，系统将解除应用具有的所有唤醒锁。</p><p>此外，为提高设备性能，系统会限制未在前台运行的应用的某些行为。具体而言：</p><ul><li>现在，在后台运行的应用对后台服务的访问受到限制。</li><li>应用无法使用其清单注册大部分隐式广播（即，并非专门针对此应用的广播）。</li></ul><p>默认情况下，这些限制仅适用于针对 O 的应用。不过，用户可以从 Settings 屏幕为任意应用启用这些限制，即使应用并不是以 O 为目标平台。<br>Android 8.0 还对特定函数做出了以下变更：</p><ul><li>如果针对 Android 8.0 的应用尝试在不允许其创建后台服务的情况下使用 <code>startService()</code> 函数，则该函数将引发一个 <code>IllegalStateException</code>。</li><li>新的 <code>Context.startForegroundService()</code> 函数将启动一个前台服务。现在，即使应用在后台运行，系统也允许其调用 <code>Context.startForegroundService()</code>。不过，应用必须在创建服务后的五秒内调用该服务的 <code>startForeground()</code> 函数。<br>如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/background.html" target="_blank" rel="noopener">后台执行限制</a>。</li></ul><h2 id="Android-后台位置限制"><a href="#Android-后台位置限制" class="headerlink" title="Android 后台位置限制"></a>Android 后台位置限制</h2><p>为节约电池电量、保持良好的用户体验和确保系统健康运行，在运行 Android 8.0 的设备上使用后台应用时，降低了后台应用接收位置更新的频率。此行为变更会影响包括 Google Play 服务在内的所有接收位置更新的应用。</p><p>此类变更会影响以下 API：</p><ul><li>Fused Location Provider (FLP)</li><li>Geofencing</li><li>GNSS Measurements</li><li>Location Manager</li><li>Wi-Fi Manager</li></ul><p>为确保您的应用按预期方式运行，请完成以下步骤：</p><ul><li>查看您的应用的逻辑，并确保您使用的是最新的位置 API。</li><li>测试您的应用是否在每个用例中都表现出预期行为。</li><li>考虑使用 Fused Location Provider (FLP) 或地理围栏来处理依赖于用户当前位置的用例。</li></ul><p>如需了解此类变更的详细信息，请参阅后台位置限制。</p><h2 id="应用快捷键"><a href="#应用快捷键" class="headerlink" title="应用快捷键"></a>应用快捷键</h2><p>Android 8.0 对应用快捷方式做出了以下变更：</p><ul><li><code>com.android.launcher.action.INSTALL_SHORTCUT</code> 广播不再会对您的应用有任何影响，因为它现在是私有的隐式广播。相反，您应使用 <code>ShortcutManager</code> 类中的 <code>requestPinShortcut()</code> 函数创建应用快捷方式。</li><li>现在，<code>ACTION_CREATE_SHORTCUT</code> Intent 可以创建可使用 <code>ShortcutManager</code> 类进行管理的应用快捷方式。此 Intent 还可以创建不与 <code>ShortcutManager</code> 交互的旧版启动器快捷方式。在以前，此 Intent 只能创建旧版启动器快捷方式。</li><li>现在，使用 <code>requestPinShortcut()</code> 创建的快捷方式和在处理 <code>ACTION_CREATE_SHORTCUT Intent</code> 的操作组件中创建的快捷方式均已转换为功能齐全的应用快捷方式。因此，应用现在可以使用 ShortcutManager 中的函数来更新这些快捷方式。</li><li>旧版快捷方式仍然保留了它们在旧版 Android 中的功能，但您必须在应用中手动将它们转换成应用快捷方式。</li></ul><p>如需了解有关应用快捷方式变更的更多信息，请参阅<a href="https://developer.android.com/preview/features/pinning-shortcuts-widgets.html" target="_blank" rel="noopener">固定快捷方式和微件预览功能指南</a>。</p><h2 id="语言区域和国际化"><a href="#语言区域和国际化" class="headerlink" title="语言区域和国际化"></a>语言区域和国际化</h2><p>Android 7.0（API 级别 24）引入能指定默认类别语言区域的概念，但是某些 API 在本应使用默认 <code>DISPLAY</code> 类别语言区域时，仍然使用不带参数的通用 <code>Locale.getDefault()</code> 函数。现在，在 Android 8.0 中，以下函数使用 <code>Locale.getDefault(Category.DISPLAY)</code> 来代替 <code>Locale.getDefault()</code>：</p><ul><li><code>Currency.getDisplayName()</code></li><li><code>Currency.getSymbol()</code></li><li><code>Locale.getDisplayScript()</code></li></ul><p>当为 <code>Locale</code> 参数指定的 <code>displayScript</code> 值不可用时，<code>Locale.getDisplayScript(Locale)</code> 同样回退到 <code>Locale.getDefault()</code>。</p><p>与语言区域和国际化有关的其他变更如下：</p><ul><li>调用 <code>Currency.getDisplayName(null)</code> 会引发 <code>NullPointerException</code>，以与文档规定的行为保持一致。</li><li><p>时区名称的分析方法发生变化。之前，Android 设备使用在启动时取样的系统时钟值，缓存用于分析日期时间的时区名称。因此，如果在启动时或其他较为罕见的情况下系统时钟出错，可能对分析产生负面影响。<br>现在，一般情况下，在分析时区名称时分析逻辑将使用 ICU 和当前系统时钟值。此项变更可提供更加准确的结果，如果您的应用使用 <code>SimpleDateFormat</code> 等类，此结果可能与之前的 Android 版本不同。</p></li><li><p>Android 8.0 将 ICU 的版本更新至版本 58。</p></li></ul><h2 id="提醒窗口"><a href="#提醒窗口" class="headerlink" title="提醒窗口"></a>提醒窗口</h2><p>如果应用使用 <code>SYSTEM_ALERT_WINDOW</code> 权限并且尝试使用以下窗口类型之一来在其他应用和系统窗口上方显示提醒窗口：</p><ul><li><code>TYPE_PHONE</code></li><li><code>TYPE_PRIORITY_PHONE</code></li><li><code>TYPE_SYSTEM_ALERT</code></li><li><code>TYPE_SYSTEM_OVERLAY</code></li><li><code>TYPE_SYSTEM_ERROR</code></li></ul><p>…那么，这些窗口将始终显示在使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型的窗口下方。如果应用针对的是 Android 8.0，则应用会使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型来显示提醒窗口。</p><p>如需了解详细信息，请参阅针对 Android 8.0 的应用的行为变更内的<a href="https://developer.android.com/about/versions/oreo/android-8.0-changes.html#cwt" target="_blank" rel="noopener">提醒窗口的常用窗口类型</a>部分。</p><h2 id="输入和导航"><a href="#输入和导航" class="headerlink" title="输入和导航"></a>输入和导航</h2><p>随着 Android 应用出现在 Chrome 操作系统和平板电脑等其他大尺寸设备上，我们看到，用户在 Android 应用中又重新开始使用键盘导航。在 Android 8.0 中，我们又再次使用键盘作为导航输入设备，从而为基于箭头键和 Tab 键的导航构建了一种更可靠并且可预测的模型。</p><p>尤其要指出的是，我们对元素焦点行为做出以下变更：</p><ul><li><p>现在，如果您没有为 View 对象（前景或背景图片）定义任何焦点状态颜色，框架会为 View 设置默认的焦点突出显示颜色。此焦点突出显示标志是基于操作组件主题背景的涟漪图片。<br>如果您不希望 View 对象在接收焦点时使用此默认突出显示标志，请在包含 View 的布局 XML 文件中将 android:defaultFocusHighlightEnabled 属性设置为 false，或者将 false 传递至应用界面逻辑中的 setDefaultFocusHighlightEnabled()。</p></li><li><p>要测试键盘输入对界面元素焦点有何影响，您可以启用 <strong>Drawing &gt; Show layout bounds</strong> 开发者选项。在 Android 8.0 中，此选项在当前具有焦点的元素上显示一个“X”图标。</p></li></ul><p>另外，Android 8.0 中的所有工具栏元素自动组成<a href="https://developer.android.com/preview/api-overview.html#kbnc" target="_blank" rel="noopener">键盘导航键区</a>用户可以更加轻松地导航进入和离开每个作为一个整体的工具栏。</p><p>如需详细了解如何在您的应用中改善对键盘导航的支持，请阅读<a href="https://developer.android.com/training/keyboard-input/navigation.html" target="_blank" rel="noopener">支持键盘导航</a>南。</p><h2 id="网页表单自动填充"><a href="#网页表单自动填充" class="headerlink" title="网页表单自动填充"></a>网页表单自动填充</h2><p>现在，Android 自动填充框架提供对自动填充功能的内置支持，对于安装到运行 Android 8.0 的设备上的应用，与 WebView 对象相关的下列函数已经发生变化：</p><p><strong>WebSettings</strong></p><ul><li><code>getSaveFormData()</code> 函数现在返回 false。之前，此函数返回 true。</li><li>调用 <code>setSaveFormData()</code> 不再有任何效果。<br><strong>WebViewDatabase</strong></li><li>调用 <code>clearFormData()</code> 不再有任何效果。</li><li><code>hasFormData()</code> 函数现在返回 false。之前，当表单包含数据时，此函数返回 true。</li></ul><h2 id="无障碍功能"><a href="#无障碍功能" class="headerlink" title="无障碍功能"></a>无障碍功能</h2><p>现在，无障碍服务可识别应用的 <code>TextView</code> 对象内部的所有 <code>ClickableSpan</code> 实例。</p><p>如需了解有关如何让您的应用更便于访问的更多信息，请参阅<a href="https://developer.android.com/guide/topics/ui/accessibility/index.html" target="_blank" rel="noopener">无障碍功能</a>。</p><h2 id="网络连接和-HTTP-S-连接"><a href="#网络连接和-HTTP-S-连接" class="headerlink" title="网络连接和 HTTP(S) 连接"></a>网络连接和 HTTP(S) 连接</h2><p>Android 8.0 对网络连接和 HTTP(S) 连接行为做出了以下变更：</p><ul><li>无正文的 OPTIONS 请求具有 Content-Length: 0 标头。之前，这些请求没有 Content-Length 标头。</li><li>HttpURLConnection 在包含斜线的主机或颁发机构名称后面附加一条斜线，使包含空路径的网址规范化。例如，它将 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 转化为 <a href="http://example.com/。" target="_blank" rel="noopener">http://example.com/。</a></li><li>通过 ProxySelector.setDefault() 设置的自定义代理选择器仅针对所请求的网址（架构、主机和端口）。因此，仅可根据这些值选择代理。传递至自定义代理选择器的网址不包含所请求的网址的路径、查询参数或片段。</li><li><p>URI 不能包含空白标签。<br>之前，平台支持一种权宜方法，即允许主机名称中包含空白标签，但这是对 URI 的非法使用。此权宜方法只是为了确保与旧版 libcore 兼容。开发者如果对 API 使用不当，将会看到一条 ADB 消息：“URI example..com 的主机名包含空白标签。此格式不正确，将不被未来的 Android 版本所接受。”Android 8.0 废除了此权宜方法；系统对格式错误的 URI 会返回 null。</p></li><li><p>Android 8.0 在实现 HttpsURLConnection 时不会执行不安全的 TLS/SSL 协议版本回退。</p></li><li><p>对隧道 HTTP(S) 连接处理进行了如下变更：</p><ul><li>在通过连接建立隧道 HTTP(S) 连接时，系统会在 Host 行中正确放置端口号 (:443) 并将此信息发送至中间服务器。之前，端口号仅出现在 CONNECT 行中。</li><li>系统不再将隧道连接请求中的 user-agent 和 proxy-authorization 标头发送至代理服务器。<br>在建立隧道时，系统不再将隧道 Http(s)URLConnection 中的 proxy-authorization 标头发送至代理。相反，由系统生成 proxy-authorization 标头，在代理响应初始请求发送 HTTP 407 后将其发送至此代理。<br>同样地，系统不再将 user-agent 标头由隧道连接请求复制到建立隧道的代理请求。相反，库为此请求生成 user-agent 标头。</li></ul></li><li><p>如果之前执行的 connect() 函数失败，·send(java.net.DatagramPacket)· 函数将会引发 SocketException。</p><ul><li>如果存在内部错误，·DatagramSocket.connect()· 会引发 pendingSocketException。对于 Android 8.0 之前的版本，即使 send() 调用成功，后续的 recv() 调用也会引发 SocketException。为确保一致性，现在这两个调用均会引发 SocketException。</li></ul></li><li>在回退到 TCP Echo 协议之前，InetAddress.isReachable() 会尝试执行 ICMP。<ul><li>对于某些屏蔽端口 7 (TCP Echo) 的主机（例如 google.com），如果它们接受 ICMP Echo 协议，现在也许能够访问它们。</li><li>对于确实无法访问的主机，此项变更意味着调用需要两倍的时间才能返回结果。</li></ul></li></ul><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>Android 8.0 对 <code>ScanRecord.getBytes()</code> 函数检索的数据长度做出以下变更：</p><ul><li><code>getBytes()</code> 函数对于所接收的字节数不作任何假定。因此，应用不应受所返回的任何最小或最大字节数的影响。相反，应用应当计算所返回数组的长度。</li><li>兼容蓝牙 5 的设备返回的数据长度可能会超出之前最大约 60 个字节的限制。</li><li>如果远程设备未提供扫描响应，则也可能返回少于 60 个字节的数据。</li></ul><h2 id="无缝连接"><a href="#无缝连接" class="headerlink" title="无缝连接"></a>无缝连接</h2><p>Android 8.0 对 WLAN 设置进行了多项改进，这样可以更轻松地选择能够提供最佳用户体验的 WLAN 网络。具体变更包括：</p><ul><li>稳定性和可靠性改进。</li><li>更加直观的界面。</li><li>一个合并的 WLAN 首选项菜单。</li><li>当附近存在优质的已保存网络时在兼容设备上自动激活 WLAN。</li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>Android 8.0 包含以下与安全性有关的变更：</p><ul><li>此平台不再支持 SSLv3。</li><li>在与未正确实现 TLS 协议版本协商的服务器建立 HTTPS 连接时，<code>HttpsURLConnection</code> 不再尝试回退到之前的 TLS 协议版本并重试的权宜方法。</li><li>Android 8.0 将使用安全计算 (SECCOMP) 过滤器来过滤所有应用。允许的系统调用列表仅限于通过 bionic 公开的系统调用。此外，还提供了其他几个后向兼容的系统调用，但我们不建议使用这些系统调用。</li><li>现在，您的应用的 <code>WebView</code> 对象将在多进程模式下运行。网页内容在独立的进程中处理，此进程与包含应用的进程相隔离，以提高安全性。</li><li>您无法再假定 APK 驻留在名称以 -1 或 -2 结尾的目录中。应用应使用 <code>sourceDir</code> 获取此目录，而不能直接使用目录格式。</li><li>如需了解与使用原生库有关的安全性增强的信息，请参阅<a href="https://developer.android.com/about/versions/oreo/android-8.0-changes.html#nl" target="_blank" rel="noopener">原生库</a>。</li></ul><p>有关提升应用安全性的其他准则，请参阅<a href="https://developer.android.com/topic/security/index.html" target="_blank" rel="noopener">面向 Android 开发者的安全性</a>。</p><h2 id="隐私性"><a href="#隐私性" class="headerlink" title="隐私性"></a>隐私性</h2><p>Android 8.0 对平台做出了以下与隐私性有关的变更。</p><ul><li><p>现在，平台改变了标识符的处理方式。</p><ul><li>对于在 OTA 之前安装到某个版本 Android 8.0（API 级别 26）的应用，除非在 OTA 后卸载并重新安装，否则 <code>ANDROID_ID</code> 的值将保持不变。要在 OTA 后在卸载期间保留值，开发者可以使用<code>密钥/值备份</code>关联旧值和新值。</li><li>对于安装在运行 Android 8.0 的设备上的应用，<code>ANDROID_ID</code> 的值现在将根据应用签署密钥和用户确定作用域。应用签署密钥、用户和设备的每个组合都具有唯一的 <code>ANDROID_ID</code> 值。因此，在相同设备上运行但具有不同签署密钥的应用将不会再看到相同的 Android ID（即使对于同一用户来说，也是如此）。</li><li>只要签署密钥相同（并且应用未在 OTA 之前安装到某个版本的 O），<code>ANDROID_ID</code> 的值在软件包卸载或重新安装时就不会发生变化。</li><li>即使系统更新导致软件包签署密钥发生变化，<code>ANDROID_ID</code> 的值也不会变化。<br>要借助一个简单的标准系统实现应用获利，请使用广告 ID。广告 ID 是 Google Play 服务针对广告服务提供的唯一 ID，此 ID 可由用户重置。</li></ul></li><li><p>查询 net.hostname 系统属性返回的结果为空。</p></li></ul><h2 id="记录未捕获的异常"><a href="#记录未捕获的异常" class="headerlink" title="记录未捕获的异常"></a>记录未捕获的异常</h2><p>如果某个应用安装的 <code>Thread.UncaughtExceptionHandler</code> 未移交给默认的 <code>Thread.UncaughtExceptionHandler</code>，则当出现未捕获的异常时，系统不会终止应用。从 Android 8.0 开始，在此情况下系统将记录异常堆栈跟踪情况；在之前的平台版本中，系统不会记录异常堆栈跟踪情况。</p><p>我们建议，自定义 <code>Thread.UncaughtExceptionHandler</code> 实现始终移交给默认处理程序处理；遵循此建议的应用不受 Android 8.0 此项变更的影响。</p><h2 id="联系人提供程序使用情况统计方法的变更"><a href="#联系人提供程序使用情况统计方法的变更" class="headerlink" title="联系人提供程序使用情况统计方法的变更"></a>联系人提供程序使用情况统计方法的变更</h2><p>在之前版本的 Android 中，联系人提供程序组件允许开发者获取每个联系人的使用情况数据。此使用情况数据揭示了与某个联系人相关联的每个电子邮件地址和每个电话号码的信息，包括与该联系人联系的次数以及上次联系该联系人的时间。请求 <code>READ_CONTACTS</code> 权限的应用可以读取此数据。</p><p>如果应用请求 <code>READ_CONTACTS</code> 权限，它们仍可以读取此数据。从 Android 8.0 开始，使用情况数据查询会返回近似值，而不是精确值。不过，Android 系统内部仍然会保留精确值，因此，此变更不会影响 auto-complete API。</p><p>此行为变更会影响以下查询参数：</p><ul><li><code>TIMES_CONTACTED</code></li><li><code>TIMES_USED</code></li><li><code>LAST_TIME_CONTACTED</code></li><li><code>LAST_TIME_USED</code></li></ul><h2 id="集合的处理"><a href="#集合的处理" class="headerlink" title="集合的处理"></a>集合的处理</h2><p>现在，<code>AbstractCollection.removeAll()</code> 和 <code>AbstractCollection.retainAll()</code> 始终引发 <code>NullPointerException</code>；之前，当集合为空时不会引发 <code>NullPointerException</code>。此项变更使行为符合文档要求。</p><h2 id="Android-企业版"><a href="#Android-企业版" class="headerlink" title="Android 企业版"></a>Android 企业版</h2><p>Android 8.0 更改了企业应用（包括设备规范控制器 (DPC)）的某些 API 和功能的行为。这些变更包括：</p><ul><li>新增多种行为，帮助应用支持完全托管设备中的工作资料。</li><li>变更系统更新处理、应用验证和身份验证方式，以提高设备和系统的完整性。</li><li>改进用户在配置、通知、“最近使用的应用”屏幕和 Always on VPN 方面的体验。</li></ul><p>如需查看 Android 8.0 中的所有企业版变更和了解它们可能给您的应用带来的影响，请阅读企业中的 Android。</p><h1 id="针对-Android-8-0-的应用"><a href="#针对-Android-8-0-的应用" class="headerlink" title="针对 Android 8.0 的应用"></a>针对 Android 8.0 的应用</h1><hr><p>这些行为变更专门应用于针对 O 平台或更高平台版本的应用。针对 Android 8.0 或更高平台版本进行编译，或将 targetSdkVersion 设为 Android 8.0 或更高版本的应用开发者必须修改其应用以正确支持这些行为（如果适用）。</p><h2 id="提醒窗口-1"><a href="#提醒窗口-1" class="headerlink" title="提醒窗口"></a>提醒窗口</h2><p>使用 <code>SYSTEM_ALERT_WINDOW</code> 权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口：</p><ul><li><code>TYPE_PHONE</code></li><li><code>TYPE_PRIORITY_PHONE</code></li><li><code>TYPE_SYSTEM_ALERT</code></li><li><code>TYPE_SYSTEM_OVERLAY</code></li><li><code>TYPE_SYSTEM_ERROR</code></li></ul><p>相反，应用必须使用名为 <code>TYPE_APPLICATION_OVERLAY</code> 的新窗口类型。</p><p>使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型显示应用的提醒窗口时，请记住新窗口类型的以下特性：</p><ul><li>应用的提醒窗口始终显示在状态栏和输入法等关键系统窗口的下面。</li><li>系统可以移动使用 TYPE_APPLICATION_OVERLAY 窗口类型的窗口或调整其大小，以改善屏幕显示效果。</li><li>通过打开通知栏，用户可以访问设置来阻止应用显示使用 TYPE_APPLICATION_OVERLAY 窗口类型显示的提醒窗口。</li></ul><h2 id="内容变更通知"><a href="#内容变更通知" class="headerlink" title="内容变更通知"></a>内容变更通知</h2><p>Android 8.0 更改了 <code>ContentResolver.notifyChange()</code> 和 <code>registerContentObserver(Uri, boolean, ContentObserver)</code> 在针对 Android 8.0 的应用中的行为方式。</p><p>现在，这些 API 需要在所有 URI 中为颁发机构定义一个有效的 <code>ContentProvider</code>。使用相关权限定义一个有效的 <code>ContentProvider</code> 可帮助您的应用防范来自恶意应用的内容变更，并防止将可能的私密数据泄露给恶意应用。</p><h2 id="视图焦点"><a href="#视图焦点" class="headerlink" title="视图焦点"></a>视图焦点</h2><p>可点击的 View 对象现在默认也可以成为焦点。如果您希望 View 对象可点击但不可成为焦点，请在包含 View 的布局 XML 文件中将 <code>android:focusable</code> 属性设置为 false，或者将 false 传递至应用界面逻辑中的 <code>setFocusable()</code>。</p><h2 id="安全性-1"><a href="#安全性-1" class="headerlink" title="安全性"></a>安全性</h2><p>如果您的应用的网络安全性配置选择退出对明文流量的支持，那么您的应用的 <code>WebView</code> 对象无法通过 HTTP 访问网站。每个 <code>WebView</code> 对象必须转而使用 HTTPS。</p><p>有关提升应用安全性的其他准则，请参阅<a href="https://developer.android.com/topic/security/index.html" target="_blank" rel="noopener">面向 Android 开发者的安全性</a>。</p><h2 id="帐号访问和可检测性"><a href="#帐号访问和可检测性" class="headerlink" title="帐号访问和可检测性"></a>帐号访问和可检测性</h2><p>除非身份验证器拥有用户帐号或用户授予访问权限，否则，应用将无法再访问用户帐号。仅拥有 <code>GET_ACCOUNTS</code> 权限尚不足以访问用户帐号。要获得帐号访问权限，应用应使用 <code>AccountManager.newChooseAccountIntent()</code> 或特定于身份验证器的函数。获得帐号访问权限后，应用可以调用 <code>AccountManager.getAccounts()</code> 来访问帐号。</p><p>Android 8.0 已弃用 <code>LOGIN_ACCOUNTS_CHANGED_ACTION</code>。相反，应用在运行时应使用 <code>addOnAccountsUpdatedListener()</code> 获取帐号更新信息。</p><p>有关新增 API 和增加的帐号访问和可检测性函数的信息，请参阅此文档的“新增 API”部分中的帐号访问和可检测性。</p><h2 id="隐私性-1"><a href="#隐私性-1" class="headerlink" title="隐私性"></a>隐私性</h2><p>以下变更影响 Android 8.0 的隐私性。</p><ul><li>系统属性 net.dns1、net.dns2、net.dns3 和 net.dns4 不再可用，此项变更可加强平台的隐私性。</li><li>要获取 DNS 服务器之类的网络连接信息，具有 <code>ACCESS_NETWORK_STATE</code> 权限的应用可以注册 <code>NetworkRequest</code> 或 <code>NetworkCallback</code> 对象。这些类在 Android 5.0（API 级别 21）及更高版本中提供。</li><li>Build.SERIAL 已弃用。需要知道硬件序列号的应用应改为使用新的 <code>Build.getSerial()</code> 函数，该函数要求具有 <code>READ_PHONE_STATE</code> 权限。</li><li><code>LauncherApps</code> API 不再允许工作资料应用获取有关主个人资料的信息。当某个用户在托管配置文件中时，<code>LauncherApps</code> API 的行为就像同一配置文件组的其他配置文件中未安装任何应用一样。和之前一样，尝试访问无关联的个人资料会引发 SecurityExceptions。</li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。</p><p>对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p><p>例如，假设某个应用在其清单中列出 <code>READ_EXTERNAL_STORAGE</code> 和 <code>WRITE_EXTERNAL_STORAGE</code>。应用请求 <code>READ_EXTERNAL_STORAGE</code>，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予 <code>WRITE_EXTERNAL_STORAGE</code>，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 <code>READ_EXTERNAL_STORAGE</code>；不过，如果该应用后来又请求 <code>WRITE_EXTERNAL_STORAGE</code>，则系统会立即授予该权限，而不会提示用户。</p><h2 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h2><ul><li>框架会执行音频闪避。进行 <code>AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</code> 时，应用不会失去焦点。新的 API 适用于需要暂停而不是闪避的应用。请注意，此行为无法在 Android 8.0 1 版本中实现。</li><li>当用户打电话时，活动的媒体流将在通话期间静音。</li><li>所有与音频相关的 API 都应使用 <code>AudioAttributes</code> 而不是音频流类型来说明音频播放用例。仅为音量控制继续使用音频流类型。流类型（例如，已弃用的 <code>AudioTrack constructor</code>）的其他用途仍然有效，但是系统会将其记录为错误。</li><li>使用 <code>AudioTrack</code> 时，如果应用请求了足够大的音频缓冲区，则框架将尝试使用深度缓冲区输出（如果可用）。</li><li>在 Android 8.0 中，媒体按钮事件的处理有所不同：<ol><li>在界面操作组件中处理媒体按钮未发生变化：前台操作组件在处理媒体按钮时仍然优先。</li><li>如果前台操作组件不处理媒体按钮，系统会将媒体按钮路由到最近在本地播放音频的应用。在确定哪些应用接收媒体按钮事件时，不再考虑活动状态、标志和媒体会话的播放状态。即使在应用调用 <code>setActive(false)</code> 后，媒体会话仍然可以接收媒体按钮事件。</li><li>如果应用的媒体会话已经释放，系统会将媒体按钮事件发送到应用的 <code>MediaButtonReceiver</code>（如果有）。</li><li>对于任何其他情况，系统都会舍弃媒体按钮事件。与其开始播放错误的应用，不如不播放任何东西。</li></ol></li></ul><p>下图汇总了新的媒体按钮路由逻辑。</p><p>媒体按钮路由</p><h2 id="原生库"><a href="#原生库" class="headerlink" title="原生库"></a>原生库</h2><p>在针对 Android 8.0 的应用中，如果原生库包含任何可写且可执行的加载代码段，则不会再加载原生库。倘若某些应用的原生库包含不正确的加载代码段，则此变更可能会导致这些应用停止工作。这是一种安全加强措施。</p><p>如需了解详细信息，请参阅<a href="https://android.googlesource.com/platform/bionic/+/master/android-changes-for-ndk-developers.md#Writable-and-Executable-Segments-Enforced-for-API-level-26" target="_blank" rel="noopener">可写且可执行的代码段</a>。</p><p>与早期的开发者预览版相同，Android 8.0 还有助于更轻松地发现所有与链接器有关的问题。链接器的变更绑定到应用的目标 API 级别。如果应用的目标 API 级别发生链接器变更，则该应用无法加载该库。如果您的目标 API 级别低于发生链接器变更的 API 级别，则 logcat 会显示一条警告消息。在预览版期间，与链接器有关的问题不仅会显示在 logcat 中，也会以 toast 的形式显示。对于特定的 API 级别，警告可能会变成错误，此变更有助于提前发现此类问题。</p><h2 id="集合的处理-1"><a href="#集合的处理-1" class="headerlink" title="集合的处理"></a>集合的处理</h2><p>在 Android 8.0 中，<code>Collections.sort()</code> 是在 <code>List.sort()</code> 的基础上实现的。在 Android 7.x（API 级别 24 和 25）中，则恰恰相反。在过去，<code>List.sort()</code> 的默认实现会调用 <code>Collections.sort()</code>。</p><p>此项变更使 <code>Collections.sort()</code> 可以利用优化的 <code>List.sort()</code> 实现，但具有以下限制：</p><ul><li><code>List.sort()</code> 的实现不能调用 <code>Collections.sort()</code>，因为这会导致堆栈因无限递归而溢出。相反，如果您需要 List 实现的默认行为，应避免重写 sort()。<br>如果父类以不适当的方法实现 sort() ，通常最好使用在 <code>List.toArray()</code>、<code>Arrays.sort()</code> 和 <code>ListIterator.set()</code> 的基础上构建的实现重写 <code>List.sort()</code>。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">  Object[] elements = toArray();</span><br><span class="line">  Arrays.sort(elements, c);</span><br><span class="line">  ListIterator&lt;E&gt; iterator = (ListIterator&lt;Object&gt;) listIterator();</span><br><span class="line">  <span class="keyword">for</span> (Object element : elements) &#123;</span><br><span class="line">    iterator.next();</span><br><span class="line">    iterator.set((E) element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在大多数情况下，您也可以使用根据 API 级别委托给其他默认实现的实现重写 <code>List.sort()</code>。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">    Collections.sort(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.sort(comparator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果您选择后者只是因为您希望开发一种适用于所有 API 级别的 sort() 函数，可以考虑赋予其一个唯一的名称，例如 sortCompat()，而不是重写 sort()。</p><ul><li><code>现在，Collections.sort()</code> 只是对调用 sort() 的 List 实现进行的一项结构性修改。例如，在 Android 8.0 之前的平台版本中，如果通过调用 <code>List.sort()</code> 进行排序，则当迭代处理 ArrayList 以及在迭代过程中调用 <code>sort()</code> 时，会引发 <code>ConcurrentModificationException</code>。而 <code>Collections.sort()</code> 则不会引发异常。</li></ul><p>此项变更使平台行为更加一致：现在，两种方法都会引发 <code>ConcurrentModificationException</code>。</p><h2 id="类加载行为"><a href="#类加载行为" class="headerlink" title="类加载行为"></a>类加载行为</h2><p>Android 8.0 检查确保类加载器在加载新类时不会违反运行时假设条件。不论类引用自 Java（来自 <code>forName()</code>）、Dalvik 字节码还是 JNI，都会执行这些检查。平台不会拦截 Java 对 <code>loadClass()</code> 函数的直接调用，也不会检查此类调用的结果。此行为不应影响运行良好的类加载器的正常运行。</p><p>平台将检查类加载器返回的类描述符是否与预期的描述符一致。如果返回的描述符与预期不符，平台会引发 <code>NoClassDefFoundError</code> 错误，并在异常日志中存储一条注明不一致之处的详细错误消息。</p><p>平台还检查请求的类描述符是否有效。此检查捕获间接加载诸如 <code>GetFieldID()</code> 等类的 JNI 调用，向这些类传递无效的描述符。例如，找不到包含 java/lang/String 签名的字段，是因为此签名无效；它应为 Ljava/lang/String;。</p><p>这与 JNI 对 <code>FindClass()</code> 的调用不同，其中 java/lang/String 是一个有效的完全限定名称。</p><p>Android 8.0 不支持多个类加载器同时尝试使用相同的 DexFile 对象来定义类。尝试进行此操作，会导致 Android 运行时引发 InternalError 错误，同时显示消息“Attempt to register dex file <filename> with multiple class loaders”。</filename></p><p>DexFile API 现已弃用，强烈建议您改为使用此平台的类加载器之一，包括 PathClassLoader 或 BaseDexClassLoader。</p><blockquote><p><strong>注：</strong> 您可以创建多个引用文件系统中同一个 APK 或 JAR 文件容器的类加载器。这样做通常不会占用大量内存：如果存储而不压缩容器中的 DEX 文件，平台可以对此类文件执行 mmap 操作，而不直接提取它们。但是，如果平台必须从容器中提取 DEX 文件，以这种方式引用 DEX 文件可能占用大量内存。</p></blockquote><p>在 Android 中，所有类加载器都被视为支持并行运行。当多个线程争用同一个类加载器加载相同的类时，第一个完成此操作的线程胜出，而操作结果将用于其他线程。无论类加载器是返回同一个类、返回不同的类还是引发异常，都将发生此行为。该平台静默忽略此类异常。</p><blockquote><p><strong>注意：</strong> 在低于 Android 8.0 的平台版本中，违反这些假设条件可能导致多次定义同一个类、由于类混淆造成堆损坏和其他不良影响。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 8.0 除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。&lt;/p&gt;
&lt;p&gt;其中大部分变更会影响所有应用，而不论应用针对的是何种版本的 Android。不过，有几项变更仅影响针对 A
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Oreo" scheme="http://yoursite.com/tags/Oreo/"/>
    
      <category term="Android8.0" scheme="http://yoursite.com/tags/Android8-0/"/>
    
  </entry>
  
  <entry>
    <title>Android 8.0 功能和 API</title>
    <link href="http://yoursite.com/2017/08/29/android-8-0/"/>
    <id>http://yoursite.com/2017/08/29/android-8-0/</id>
    <published>2017-08-29T11:47:18.000Z</published>
    <updated>2018-03-30T03:04:15.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h1><hr><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p><img src="/2017/08/29/android-8-0/notification-long-press.png" alt="Drawing" style="width: 200px;float:right"><br>在 Android 8.0 中，我们已重新设计通知，以便为管理通知行为和设置提供更轻松和更统一的方式。这些变更包括：<br>-<strong>通知渠道</strong>：Android 8.0 引入了通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。用户界面将通知渠道称之为通知类别。要了解如何实现通知渠道的信息，请参阅<a href="https://developer.android.com/preview/features/notification-channels.html" target="_blank" rel="noopener">通知渠道</a>指南。<br>-<strong>通知标志</strong>：Android 8.0 引入了对在应用启动器图标上显示通知标志的支持。通知标志可反映某个应用是否存在与其关联、并且用户尚未予以清除也未对其采取行动的通知。通知标志也称为通知点。要了解如何调整通知标志，请参阅<a href="https://developer.android.com/preview/features/notification-badges.html" target="_blank" rel="noopener">通知标志</a>指南。<br>-<strong>休眠</strong>：用户可以将通知置于休眠状态，以便稍后重新显示它。重新显示时通知的重要程度与首次显示时相同。应用可以移除或更新已休眠的通知，但更新休眠的通知并不会使其重新显示。<br>-<strong>通知超时</strong>：现在，使用 <code>setTimeoutAfter()</code>创建通知时您可以设置超时。您可以使用此函数指定一个持续时间，超过该持续时间后，通知应取消。如果需要，您可以在指定的超时持续时间之前取消通知。<br>-<strong>通知设置</strong>：当您使用 <code>Notification.INTENT_CATEGORY_NOTIFICATION_PREFERENCESIntent</code> 从通知创建指向应用通知设置的链接时，您可以调用 <code>setSettingsText()</code> 来设置要显示的文本。此系统可以提供以下 <code>Extra</code> 数据和 <code>Intent</code>，用于过滤应用必须向用户显示的设置：<code>EXTRA_CHANNEL_ID</code>、<code>NOTIFICATION_TAG 和 NOTIFICATION_ID</code>。<br>-<strong>通知清除</strong>：系统现在可区分通知是由用户清除，还是由应用移除。要查看清除通知的方式，您应实现 <code>NotificationListenerService</code> 类的新 <code>onNotificationRemoved()</code> 函数。<br>-<strong>背景颜色</strong>：您现在可以设置和启用通知的背景颜色。只能在用户必须一眼就能看到的持续任务的通知中使用此功能。例如，您可以为与驾车路线或正在进行的通话有关的通知设置背景颜色。您还可以使用 <code>Notification.Builder.setColor()</code> 设置所需的背景颜色。这样做将允许您使用 <code>Notification.Builder.setColorized()</code> 启用通知的背景颜色设置。<br>-<strong>消息样式</strong>：现在，使用 <code>MessagingStyle</code> 类的通知可在其折叠形式中显示更多内容。对于与消息有关的通知，您应使用 <code>MessagingStyle</code> 类。您还可以使用新的 <code>addHistoricMessage()</code> 函数，通过向与消息相关的通知添加历史消息为会话提供上下文。</p><h2 id="自动填充框架"><a href="#自动填充框架" class="headerlink" title="自动填充框架"></a>自动填充框架</h2><p>帐号创建、登录和信用卡交易需要时间并且容易出错。在使用要求执行此类重复性任务的应用时，用户很容易遭受挫折。<br>Android 8.0 通过引入自动填充框架，简化了登录和信用卡表单之类表单的填写工作。在用户选择接受自动填充之后，新老应用都可使用自动填充框架。<br>您可以采取某些措施，优化您的应用使用此框架的方式。如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/autofill.html" target="_blank" rel="noopener">自动填充框架概览</a>。</p><h2 id="画中画模式"><a href="#画中画模式" class="headerlink" title="画中画模式"></a>画中画模式</h2><p>Android 8.0 允许以画中画 (PIP) 模式启动操作组件。PIP 是一种特殊的多窗口模式，最常用于视频播放。目前，PIP 模式可用于 Android TV，而 Android 8.0 则让该功能可进一步用于其他 Android 设备。<br>当某个 Activity 处于 PIP 模式时，它会处于暂停状态，但仍应继续显示内容。因此，您应确保您的应用在 <code>onPause()</code> 处理程序中进行处理时不会暂停播放。相反，您应在 onStop() 中暂停播放视频，并在 <code>onStart()</code> 中继续播放。如需了解详细信息，请参阅<a href="https://developer.android.com/guide/topics/ui/multi-window.html#lifecycle" target="_blank" rel="noopener">多窗口生命周期</a>。<br>要指定您的 Activity 可以使用 PIP 模式，请在清单中将 android:supportsPictureInPicture 设置为 true。（从 Android 8.0 开始，如果您打算在 Android TV 或其他 Android 设备上支持 PIP 模式，则无需将 android:resizeableActivity 设置为 true；只有在您的 Activity 支持其他多窗口模式时，才需要设置 android:resizeableActivity。）</p><h2 id="API-变更"><a href="#API-变更" class="headerlink" title="API 变更"></a>API 变更</h2><p>Android 8.0 引入一种新的对象 PictureInPictureParams，您可以将该对象传递给 PIP 函数来指定某个 Activity 在其处于 PIP 模式时的行为。此对象还指定了各种属性，例如操作组件的首选纵横比。</p><p>现在，在添加画中画中介绍的现有 PIP 函数可用于所有 Android 设备，而不仅限于 Android TV。此外，Android 8.0 还提供以下函数来支持 PIP 模式：</p><ul><li><p><strong>Activity.enterPictureInPictureMode(PictureInPictureParams args)</strong>：将操作组件置于画中画模式。操作组件的纵横比和其他配置设置均由 <code>args</code> 指定。如果 <code>args</code> 中的任何字段为空，系统将使用您上次调用 <code>Activity.setPictureInPictureParams()</code> 时所设置的值。<br>指定的操作组件被置于屏幕的一角，屏幕剩余部分则被屏幕显示的上一个操作组件填满。进入 PIP 模式的 Activity 将进入暂停状态，但仍保持已启动状态。如果用户点按此 PIP 操作组件，系统将显示一个菜单供用户操作，而在操作组件处于 PIP 状态期间，不会理会任何触摸事件。</p></li><li><p><strong>Activity.setPictureInPictureParams()</strong>：更新操作组件的 PIP 配置设置。如果操作组件目前处于 PIP 模式，则会更新此设置；如果操作组件的纵横比发生变化，这非常有用。如果操作组件不处于 PIP 模式，则会使用这些配置设置，而不会考虑您调用的 <code>enterPictureInPictureMode()</code> 函数。</p></li></ul><h2 id="可下载字体"><a href="#可下载字体" class="headerlink" title="可下载字体"></a>可下载字体</h2><p>Android 8.0 和 Android 支持库 26 允许您从提供程序应用请求字体，而无需将字体绑定到 APK 中或让 APK 下载字体。此功能可减小 APK 大小，提高应用安装成功率，使多个应用可以共享同一种字体。</p><p>如需了解有关下载字体的详细信息，请参阅 <a href="https://developer.android.com/preview/features/downloadable-fonts.html" target="_blank" rel="noopener">可下载字体</a>。</p><h2 id="XML-中的字体"><a href="#XML-中的字体" class="headerlink" title="XML 中的字体"></a>XML 中的字体</h2><p>Android 8.0 推出一项新功能，即 XML 中的字体，允许您使用字体作为资源。这意味着，不再需要以资产的形式捆绑字体。字体在 R 文件中编译，并且作为一种资源，可自动用于系统。然后，您可以利用一种新的资源类型 font 来访问这些字体。</p><p>在运行 API 版本 14 及更高版本的设备中，支持库 26 对此功能提供完全支持。</p><p>如需了解有关以资源形式使用字体以及检索系统字体有关的详细信息，请参阅 <a href="https://developer.android.com/preview/features/fonts-in-xml.html" target="_blank" rel="noopener">XML 中的字体</a>。</p><h2 id="自动调整-TextView-的大小"><a href="#自动调整-TextView-的大小" class="headerlink" title="自动调整 TextView 的大小"></a>自动调整 TextView 的大小</h2><p>Android 8.0 允许您根据 TextView 的大小自动设置文本展开或收缩的大小。这意味着，在不同屏幕上优化文本大小或者优化包含动态内容的文本大小比以往简单多了。如需了解有关如何在 Android 8.0 中自动调整 TextView 的大小的详细信息，请参阅<a href="https://developer.android.com/preview/features/autosizing-textview.html" target="_blank" rel="noopener">自动调整 TextView 的大小</a>。</p><h2 id="自适应图标"><a href="#自适应图标" class="headerlink" title="自适应图标"></a>自适应图标</h2><p>Android 8.0 引入自适应启动器图标。自适应图标支持视觉效果，可在不同设备型号上显示为各种不同的形状。要了解如何创建自适应图标，请参阅<a href="https://developer.android.com/preview/features/adaptive-icons.html" target="_blank" rel="noopener">自适应图标预览功能指南</a>。</p><h2 id="颜色管理"><a href="#颜色管理" class="headerlink" title="颜色管理"></a>颜色管理</h2><p>图像应用的 Android 开发者现在可以利用支持广色域彩色显示的新设备。要显示广色域图像，应用需要在其清单（每个操作组件）中启用一个标志，并加载具有嵌入的广域彩色配置文件（AdobeRGB、Pro Photo RGB、DCI-P3 等）的位图。</p><h2 id="WebView-API"><a href="#WebView-API" class="headerlink" title="WebView API"></a>WebView API</h2><p>Android 8.0 提供多种 API，帮助您管理在应用中显示网页内容的 <code>WebView</code> 对象。这些 API 可增强应用的稳定性和安全性，它们包括：</p><ul><li>Version API</li><li>Google SafeBrowsing API</li><li>Termination Handle API</li><li>Renderer Importance API<br>要详细了解如何这些 API，请参阅<a href="https://developer.android.com/preview/features/managing-webview.html" target="_blank" rel="noopener">管理 WebView</a>。</li></ul><h2 id="固定快捷方式和小部件"><a href="#固定快捷方式和小部件" class="headerlink" title="固定快捷方式和小部件"></a>固定快捷方式和小部件</h2><p>Android 8.0 引入了快捷方式和微件的应用内固定功能。在您的应用中，您可以根据用户权限为支持的启动器创建固定的快捷方式和小部件。</p><p>如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/pinning-shortcuts-widgets.html" target="_blank" rel="noopener">固定快捷方式和微件</a>预览功能指南。</p><p>##最大屏幕纵横比<br>以 Android 7.1（API 级别 25）或更低版本为目标平台的应用默认的最大屏幕纵横比为 1.86。针对 Android 8.0 或更高版本的应用没有默认的最大纵横比。如果您的应用需要设置最大纵横比，请使用定义您的操作组件的清单文件中的 <code>maxAspectRatio</code> 属性。</p><h2 id="多显示器支持"><a href="#多显示器支持" class="headerlink" title="多显示器支持"></a>多显示器支持</h2><p>从 Android 8.0 开始，此平台为多显示器提供增强的支持。如果 Activity 支持多窗口模式，并且在具有多显示器的设备上运行，则用户可以将 Activity 从一个显示器移动到另一个显示器。当应用启动 Activity 时，此应用可指定 Activity 应在哪个显示器上运行。</p><blockquote><p><strong>注</strong>：如果 Activity 支持多窗口模式，则 Android 8.0 将为该 Activity 自动启用多显示器支持。您应测试您的应用，确保它在多显示器环境下可正常运行。<br>每次只有一个 Activity 可以处于继续状态，即使此应用具有多个显示器。具有焦点的 Activity 将处于继续状态，所有其他可见的 Activity 均暂停，但不会停止。如需了解有关当多个 Activity 可见时活动生命周期的详细信息，请参阅<a href="https://developer.android.com/guide/topics/ui/multi-window.html#lifecycle" target="_blank" rel="noopener">多窗口生命周期</a>。</p></blockquote><p>当用户将 Activity 从一个显示器移动到另一个显示器时，系统将调整 Activity 大小，并根据需要发起运行时变更。您的 Activity 可以自行处理配置变更，或允许系统销毁包含该 Activity 的进程，并以新的尺寸重新创建它。如需了解详细信息，请参阅<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理配置变更</a>。<br><strong>setLaunchDisplayId()</strong><br>&emsp;&emsp;指定 Activity 在启动后应显示在哪个显示器上。<br><strong>getLaunchDisplayId()</strong><br>&emsp;&emsp;返回操作组件的当前启动显示器。<br>对 adb shell 进行了扩展，以支持多个显示器。shell start 命令现在可用于启动操作组件，并指定操作组件的目标显示器：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell start &lt;activity_name&gt; --display &lt;display_id&gt;</span><br></pre></td></tr></table></figure></p><h2 id="统一的布局外边距和内边距"><a href="#统一的布局外边距和内边距" class="headerlink" title="统一的布局外边距和内边距"></a>统一的布局外边距和内边距</h2><p>Android 8.0 让您可以更轻松地指定 View 元素的对边使用相同外边距和内边距的情形。具体来说，您现在可以在布局 XML 文件中使用以下属性：<br>-<strong>layout_marginVertical</strong>，同时定义 <code>layout_marginTop</code> 和 <code>layout_marginBottom</code>。<br>-<strong>layout_marginHorizontal</strong>，同时定义 <code>layout_marginLeft</code> 和 <code>layout_marginRight</code>。<br>-<strong>paddingVertical</strong>，同时定义 <code>paddingTop</code> 和 <code>paddingBottom</code>。<br>-<strong>paddingHorizontal</strong>，同时定义 <code>paddingLeft</code> 和 <code>paddingRight</code>。</p><blockquote><p><strong>注</strong>：如果您自定义应用逻辑以支持不同语言和文化（包括文本方向），请记住，这些属性不会影响 <code>layout_marginStart</code>、<code>layout_marginEnd</code>、<code>paddingStart</code> 或 <code>paddingEnd</code> 的值。您可以自行设置这些值和新的垂直与水平布局属性来创建取决于文本方向的布局行为。</p></blockquote><h2 id="指针捕获"><a href="#指针捕获" class="headerlink" title="指针捕获"></a>指针捕获</h2><p>某些应用（例如游戏、远程桌面和虚拟化客户端）将大大受益于鼠标指针控制。指针捕获是 Android 8.0 中的一项新功能，可以通过将所有鼠标事件传递到您的应用中焦点视图的方式提供此类控制。</p><p>从 Android 8.0 开始，您的应用中的 View 可以请求指针捕获并定义一个侦听器来处理捕获的指针事件。鼠标指针在此模式下将隐藏。如果不再需要鼠标信息，该视图可以释放指针捕获。系统也可以在视图丢失焦点时（例如，当用户打开另一个应用时）释放指针捕获。</p><p>如需了解有关如何在您的应用中使用此功能的信息，请参<a href="https://developer.android.com/preview/features/pointer-capture.html" target="_blank" rel="noopener">阅指针捕获</a>。</p><h2 id="应用类别"><a href="#应用类别" class="headerlink" title="应用类别"></a>应用类别</h2><p>在适当的情况下，Android 8.0 允许每个应用声明其所属的类别。这些类别用于将应用呈现给用户的用途或功能类似的应用归类在一起，例如按流量消耗、电池消耗和存储消耗将应用归类。您可以在 <application> 清单标记中设置 android:appCategory 属性，定义应用的类别。</application></p><h2 id="Android-TV-启动器"><a href="#Android-TV-启动器" class="headerlink" title="Android TV 启动器"></a>Android TV 启动器</h2><p>Android 8.0 添加了一种以内容为中心的全新 Android TV 主屏幕体验，支持 Android TV 模拟器和 Nexus Player Android 8.0 设备映像。新的主屏幕在对应于频道的行中组织视频内容，这些频道在系统上通过应用填充各个节目。应用可以发布多个频道，用户可以配置他们希望在主屏幕上看到哪些频道。Android TV 也包含一个 Watch Next 行，此行根据用户的观看习惯从应用填充节目。应用也可以提供视频预览，这些预览会在用户聚焦到节目时自动播放。用于填充频道和节目的 API 属于 TvProvider API，这些 API 以 Android 支持库模块的形式随 Android 8.0 分发。</p><h2 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h2><p>从 Android 8.0 开始，AnimatorSet API 现在支持寻道和倒播功能。寻道功能允许您将动画的位置设置为指定的时间点处。如果您的应用包含可撤消的操作的动画，倒播功能会很有用。现在，您不必定义两组独立的动画，而只需反向播放同一组动画。</p><h2 id="输入和导航"><a href="#输入和导航" class="headerlink" title="输入和导航"></a>输入和导航</h2><h3 id="键盘导航键区"><a href="#键盘导航键区" class="headerlink" title="键盘导航键区"></a>键盘导航键区</h3><p>如果您的应用中，某个操作组件使用一种复杂的视图层次结构，可考虑将多组界面元素组成一个键区，简化键盘导航这些元素的操作。用户可以在 Chromebook 设备上按 Meta+Tab 或 Search+Tab，在不同键区之间导航。键区的一些范例包括：侧面板、导航栏、主内容区域和可能包含多个子元素的元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/08/29/android-8-0/keyboard-navigation-clusters.png" alt="包含 5 个键区的操作组件" title="">                </div>                <div class="image-caption">包含 5 个键区的操作组件</div>            </figure><br>要将一个 <code>View</code> 或 <code>ViewGroup</code> 元素设置为一个键区，请在元素的布局 XML 文件中将 <code>android:keyboardNavigationCluster</code> 属性设置为 true，或者将 true 传递至应用界面逻辑中的 <code>setKeyboardNavigationCluster()</code>。</p><blockquote><p><strong>注</strong>：键区不能嵌套，不过，非嵌套键区可以显示在层次结构的不同层级。如果您尝试嵌套键区，框架仅会将最顶层的 ViewGroup 元素视为键区。</p></blockquote><p>在具有触摸屏的设备中，您可以将某个键区指定的 ViewGroup 对象的 <code>android:touchscreenBlocksFocus</code> 元素设置为 true，仅允许从键区导航进入和离开此键区。如果您将此配置应用于某个键区，用户将无法使用 Tab 键或箭头键导航进入或离开此键区，而是必须按键区导航键盘组合键</p><h3 id="视图默认焦点"><a href="#视图默认焦点" class="headerlink" title="视图默认焦点"></a>视图默认焦点</h3><p>在 Android 8.0 中，您可以指定在（重新）创建的操作组件继续运行并且用户按下键盘导航键（例如 Tab 键）之后应接收焦点的 View。要应用“设为默认焦点”设置，请在包含界面元素的布局 XML 文件中将 View 元素的 <code>android:focusedByDefault</code> 属性设置为 true，或者将 true 传递至应用界面逻辑中的 <code>setFocusedByDefault()</code>。</p><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><hr><h2 id="新的-StrictMode-检测程序"><a href="#新的-StrictMode-检测程序" class="headerlink" title="新的 StrictMode 检测程序"></a>新的 StrictMode 检测程序</h2><p>Android 8.0 添加了三个新的 StrictMode 检测程序，帮助识别应用可能出现的错误：</p><ul><li><code>detectUnbufferedIo()</code> 将检测您的应用何时读取或写入未缓冲的数据，这可能极大影响性能。</li><li><code>detectContentUriWithoutPermission()</code> 将检测您的应用在其外部启动 Activity 时何时意外忘记向其他应用授予权限。</li><li><code>detectUntaggedSockets()</code> 将检测您的应用何时使用网络流量，而不使用 setThreadStatsTag(int) 将流量标记用于调试目的。</li></ul><h2 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h2><p>Android 8.0 优化了缓存数据的导航和行为。现在，每个应用均获得一定的磁盘空间配额，用于存储 <code>getCacheQuotaBytes(UUID)</code> 返回的缓存数据。</p><p>当系统需要释放磁盘空间时，将开始从超过配额最多的应用中删除缓存文件。因此，如果将您的缓存数据量始终保持低于配额的水平，则在必须清除系统中的某些文件时，您的缓存文件将能坚持到最后。系统在决定删除您的应用中的哪些缓存文件时，将首先考虑删除最旧的文件（由修改时间确定）。</p><p>您还可以针对每个目录启用两种新行为，以控制系统如何释放缓存数据：</p><ul><li><strong>StorageManager.setCacheBehaviorAtomic()</strong> 可用于指示某个目录及其所有内容应作为一个不可分割的整体进行删除。</li><li><strong>setCacheBehaviorTombstone(File, boolean)</strong> 可用于指示不应删除某个目录内的文件，而应将它们截断到 0 字节长度，使空文件保持完好。</li></ul><p>最后，在需要为大文件分配磁盘空间时，可考虑使用新的 <code>allocateBytes(FileDescriptor, long)</code> API，它将自动清除属于其他应用的缓存文件（根据需要），以满足您的请求。在确定设备是否有足够的磁盘空间保存您的新数据时，请调用 <code>getAllocatableBytes(UUID)</code> 而不要使用 <code>getUsableSpace()</code>，因为前者会考虑系统要为您清除的任何缓存数据。</p><h2 id="内容提供程序分页"><a href="#内容提供程序分页" class="headerlink" title="内容提供程序分页"></a>内容提供程序分页</h2><p>我们已更新内容提供程序以支持加载大型数据集，每次加载一页。例如，一个具有大量图像的照片应用可查询要在页面中显示的数据的子集。内容提供程序返回的每个结果页面由一个 Cursor 对象表示。客户端和提供程序必须实现分页才能利用此功能。</p><p>如需了解有关内容提供程序变更的详细信息，请参阅<a href="https://developer.android.com/reference/android/content/ContentProvider.html" target="_blank" rel="noopener">ContentProvider</a>和<a href="https://developer.android.com/reference/android/content/ContentProviderClient.html" target="_blank" rel="noopener">ContentProviderClient</a>。</p><h2 id="内容刷新请求"><a href="#内容刷新请求" class="headerlink" title="内容刷新请求"></a>内容刷新请求</h2><p>现在，<strong>ContentProvider</strong> 和 <strong>ContentResolver</strong> 类均包含 <code>refresh()</code> 函数，这样，客户端可以更轻松地知道所请求的信息是否为最新信息。</p><p>您可以扩展 <strong>ContentProvider</strong> 以添加自定义的内容刷新逻辑。请务必重写 <code>refresh()</code>函数，以返回 true，告知提供程序的客户端您已尝试自行刷新数据。</p><p>您的客户端应用可通过调用另一个函数（又称 refresh()），显式请求已刷新的内容。在调用此函数时，传入待刷新数据的 URI。</p><blockquote><p><strong>注：</strong>由于您可能通过网络不断请求数据，您应仅在有明显迹象表明内容确已过时时才从客户端调用 refresh()。执行此类内容刷新最常见的原因是响应滑动刷新手势，该手势显式请求当前界面显示最新内容。</p></blockquote><h2 id="JobScheduler-改进"><a href="#JobScheduler-改进" class="headerlink" title="JobScheduler 改进"></a>JobScheduler 改进</h2><p>Android 8.0 引入了对 <strong>JobScheduler</strong> 的多项改进。由于您通常可以使用计划作业替代现在受限的后台服务或隐式广播接收器，这些改进可以让您的应用更轻松地符合新的后台执行限制。</p><p><strong>JobScheduler</strong> 的更新包括：</p><ul><li>您现在可以将工作队列与计划作业关联。要将一个工作项添加到作业的队列中，请调用 JobScheduler.enqueue()。当作业运行时，它可以将待定工作从队列中剥离并进行处理。这种功能可以处理之前需要启动后台服务（尤其是实现 IntentService 的服务）的许多用例。</li><li>您现在可以通过调用 JobInfo.Builder.setClipData() 的方式将 ClipData 与作业关联。利用此选项，您可以将 URI 权限授予与作业关联，类似于这些权限传递到 Context.startService() 的方式。您也可以将 URI 权限授予用于工作队列上的 intent。</li><li>计划作业现在支持多个新的约束条件：<br><code>JobInfo.isRequireStorageNotLow()</code><br>&emsp;&emsp;如果设备的可用存储空间非常低，作业将不会运行。<br><code>JobInfo.isRequireBatteryNotLow()</code><br>&emsp;&emsp;如果电池电量等于或低于临界阈值，作业将不会运行；临界阈值是指设备显示 Low battery warning 系统对话框的电量。<br><code>NETWORK_TYPE_METERED</code><br>&emsp;&emsp;作业需要一个按流量计费的网络连接，比如大多数移动数据网络数据套餐。</li></ul><h2 id="自定义数据存储"><a href="#自定义数据存储" class="headerlink" title="自定义数据存储"></a>自定义数据存储</h2><p>Android 8.0 允许您为首选项提供自定义数据存储，如果您的应用将首选项存储在云或本地数据库中，或者如果首选项特定于某个设备，此功能会非常有用。如需了解有关实现数据存储的详细信息，请参阅<a href="https://developer.android.com/preview/features/custom-data-store.html" target="_blank" rel="noopener">自定义数据存储</a>。</p><h2 id="findViewById-签名变更"><a href="#findViewById-签名变更" class="headerlink" title="findViewById() 签名变更"></a>findViewById() 签名变更</h2><p>现在，findViewById() 函数的全部实例均返回 <code>&lt;T extends View&gt;</code> T，而不是 View。此变更会带来以下影响：</p><ul><li>例如，如果 <code>someMethod(View)</code> 和 <code>someMethod(TextView)</code> 均接受调用 <code>findViewById()</code> 的结果，这可能导致现有代码的返回类型不确定。</li><li>在使用 Java 8 源语言时，这需要在返回类型不受限制时（例如，<code>assertNotNull(findViewById(...)).someViewMethod())</code>）显式转换为 View。</li><li>重写非最终的 <code>findViewById()</code> 函数（例如，Activity.findViewById()）将需要更新其返回类型。</li></ul><h1 id="媒体增强功能"><a href="#媒体增强功能" class="headerlink" title="媒体增强功能"></a>媒体增强功能</h1><hr><p><a href="https://developer.android.com/guide/topics/providers/document-provider.html" target="_blank" rel="noopener">存储访问框架 (SAF)</a> 允许应用显示自定义 <strong>DocumentsProvider</strong>，后者可以为其他应用提供访问数据源中的文件的权限。事实上，文档提供程序甚至可以提供驻留在网络存储区或使用<a href="https://en.wikipedia.org/wiki/Media_Transfer_Protocol" target="_blank" rel="noopener">媒体传输协议 (MTP) </a>等协议的文件的访问权限。</p><p>但是，访问远程数据源中的大媒体文件面临一些挑战：</p><ul><li>媒体播放器需要以寻址方式访问来自文档提供程序的文件。当大媒体文件驻留在远程数据源上时，文档提供程序必须事先提取所有数据，并创建快照文件描述符。媒体播放器无法播放没有文件描述符的文件，因此在文档提供程序完成文件下载前，无法开始播放。</li><li>照片应用等媒体集合管理器必须通过作用域文件夹遍历一系列访问 URI 才能访问存储在外部 SD 卡上的媒体。这种访问模式会让媒体上的批量操作（例如移动、复制和删除）变得非常缓慢。</li><li>媒体集合管理器无法根据文档的 URI 确定其位置。这就让这些类型的应用难以允许用户选择媒体文件的保存位置。<br>Android 8.0 通过改进存储访问框架解决了各个挑战。</li></ul><h3 id="自定义文档提供程序"><a href="#自定义文档提供程序" class="headerlink" title="自定义文档提供程序"></a>自定义文档提供程序</h3><p>从 Android 8.0 开始，存储访问框架允许自定义<a href="https://developer.android.com/guide/topics/providers/create-document-provider.html" target="_blank" rel="noopener">文档提供程序</a>为驻留在远程数据源中的文件创建可寻址的文件描述符。SAF 可打开文件，获取原生可寻址的文件描述符。然后 SAF 向文档提供程序提交离散字节请求。此功能使文档提供程序可以返回媒体播放器应用请求的准确字节范围，而不必事先缓存整个文件。</p><p>要使用此功能，您需要调用新的 <code>StorageManager.openProxyFileDescriptor()</code> 函数。<code>openProxyFileDescriptor()</code> 函数可接受 <strong>ProxyFileDescriptorCallback</strong> 对象作为回调。任何时候，当客户端应用对文档提供程序返回的文件描述符执行文件操作时，SAF 都会调用回调。</p><h3 id="直接文档访问"><a href="#直接文档访问" class="headerlink" title="直接文档访问"></a>直接文档访问</h3><p>从 Android 8.0 开始，您可以使用 <code>getDocumentUri()</code> 函数获得与给定 mediaUri 引用相同文档的 URI。不过，由于返回的 URI 由 <strong>DocumentsProvider</strong> 提供支持，媒体集合管理器可以直接访问文档，不用遍历作用域目录树。因此，媒体管理器能够以明显加快的速度对文档执行文件操作。</p><blockquote><p><strong>注意：</strong><code>getDocumentUri()</code> 函数仅可以定位媒体文件；无法授予应用访问这些文件的权限。要详细了解如何获取媒体文件的访问权限，请参阅参考文档。</p></blockquote><h3 id="文档路径"><a href="#文档路径" class="headerlink" title="文档路径"></a>文档路径</h3><p>在 Android 8.0 中使用存储访问框架时，您可以根据文档的 ID，使用 <code>findDocumentPath()</code> 函数（存在于 <strong>DocumentsContract</strong> 和 <strong>DocumentsProvider</strong> 类中）从文件系统的根目录中确定路径。该函数将在 DocumentsContract.Path 对象中返回此路径。如果文件系统对相同文档有多个定义的路径，该函数将返回访问具有给定 ID 的文档时最常使用的路径。</p><p>此功能在下列情况下特别有用：</p><ul><li>您的应用使用可以显示特定文档位置的“另存为”对话框。</li><li>您的应用在搜索结果视图中显示文件夹并且如果用户选择某个文件夹，应用必须加载此特定文件夹内的子文档。<blockquote><p><strong>注：</strong>如果您的应用仅具有路径中某些文档的访问权限，那么 <code>findDocumentPath()</code> 的返回值将仅包含您的应用可以访问的文件夹和文档。</p></blockquote></li></ul><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><hr><h2 id="WLAN-感知"><a href="#WLAN-感知" class="headerlink" title="WLAN 感知"></a>WLAN 感知</h2><p>Android 8.0 新增了对 WLAN 感知的支持，此技术基于周边感知联网 (NAN) 规范。在具有相应 WLAN 感知硬件的设备上，应用和附近设备可以通过 WLAN 进行搜索和通信，无需依赖互联网接入点。我们正在与硬件合作伙伴合作，以尽快将 WLAN 感知技术应用于设备。要了解有关如何将 WLAN 感知集成到您的应用中的信息，请参阅 <a href="https://developer.android.com/preview/features/wifi-aware.html" target="_blank" rel="noopener">WLAN 感知</a>。</p><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>Android 8.0 通过增加以下功能，增强了平台对蓝牙的支持：</p><ul><li>支持 AVRCP 1.4 标准，该标准支持音乐库浏览。</li><li>支持蓝牙低功耗 (BLE) 5.0 标准。</li><li>将 Sony LDAC 编解码器集成到蓝牙堆叠中。</li></ul><h2 id="配套设备配对"><a href="#配套设备配对" class="headerlink" title="配套设备配对"></a>配套设备配对</h2><p>在尝试通过蓝牙、BLE 和 WLAN 与配套设备配对时，Android 8.0 提供的 API 允许您自定义配对请求对话框。如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/companion-device-pairing.html" target="_blank" rel="noopener">配套设备配对</a>。</p><p>如需了解有关在 Android 上使用<a href="https://developer.android.com/guide/topics/connectivity/bluetooth.html" target="_blank" rel="noopener">蓝牙</a>的详细信息，请参阅蓝牙指南。有关对蓝牙所作的特定于 Android 8.0 的变更，请参阅 <a href="https://developer.android.com/preview/behavior-changes.html" target="_blank" rel="noopener">Android 8.0 行为变更</a>页面的<a href="https://developer.android.com/preview/behavior-changes.html#bt" target="_blank" rel="noopener">蓝牙</a>部分。</p><h1 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h1><hr><h2 id="智能共享"><a href="#智能共享" class="headerlink" title="智能共享"></a>智能共享</h2><p>Android 8.0 了解用户的个性化分享首选项，在通过哪些应用分享各个类型的内容方面，也有着更好的把握。例如，如果用户为一张收据拍照，Android 8.0 可以建议费用跟踪应用；如果用户自拍，一款社交媒体应用可以更好地处理图像。Android 8.0 可以根据用户的个性化首选项自动学习所有这些模式。</p><p>智能分享适用于 image 之外的内容类型，例如 <strong>audio</strong>、<strong>video</strong>、<strong>text</strong> 和 <strong>URL</strong> 等。</p><p>要启用智能分享，请将具有最多三个字符串注释的 <strong>ArrayList</strong> 添加到分享内容的 intent。这些注释应说明内容中的主要部分或主题。下面的代码示例显示了如何向 intent 添加注释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; annotations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">annotations.add(<span class="string">"topic1"</span>);</span><br><span class="line">annotations.add(<span class="string">"topic2"</span>);</span><br><span class="line">annotations.add(<span class="string">"topic3"</span>);</span><br><span class="line"></span><br><span class="line">intent.putStringArrayListExtra(</span><br><span class="line">    Intent.EXTRA_CONTENT_ANNOTATIONS,</span><br><span class="line">    annotations</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>如需了解有关智能分享注释的详细信息，请参阅 <code>EXTRA_CONTENT_ANNOTATIONS</code>。</p><h2 id="智能文本选择"><a href="#智能文本选择" class="headerlink" title="智能文本选择"></a>智能文本选择</h2><p>在兼容设备上，Android 8.0 让应用可以帮助用户以更有意义的方式与文本交互。当用户长按某个实体中可识别格式的单词（例如某个地址或餐馆名称）时，系统会选中整个实体。用户会看到一个浮动工具栏，该工具栏包含可以处理所选文本实体的应用。例如，如果系统识别出某个地址，它可以将用户导向地图应用。</p><p>系统识别的实体包括地址、网址、电话号码和电子邮件地址。如需了解详细信息，请参阅 <strong>TextClassifier</strong>。</p><h1 id="无障碍功能"><a href="#无障碍功能" class="headerlink" title="无障碍功能"></a>无障碍功能</h1><hr><p>Android 8.0 支持开发者使用以下无障碍功能创建自己的无障碍服务。如需了解有关如何让您的应用更便于访问的更多信息，请参阅<a href="https://developer.android.com/guide/topics/ui/accessibility/index.html" target="_blank" rel="noopener">无障碍功能</a>。</p><h2 id="无障碍功能按钮"><a href="#无障碍功能按钮" class="headerlink" title="无障碍功能按钮"></a>无障碍功能按钮</h2><p>您的无障碍服务现在可以请求在系统的导航区域显示无障碍功能按钮，该按钮让用户可从其设备上的任意位置快速激活您的服务功能。要执行此操作，请在某个 <strong>AccessibilityServiceInfo</strong> 对象的 <strong>android:accessibilityFlags</strong> 属性中添加 <strong>FLAG_REQUEST_ACCESSIBILITY_BUTTON</strong> 标志。稍后，您可以使用 <code>registerAccessibilityButtonCallback()</code> 注册回调。</p><blockquote><p><strong>注：</strong>此功能仅适用于提供软件渲染导航区域的设备。请始终使用 <code>isAccessibilityButtonAvailable()</code>，并通过实现 <code>onAvailabilityChanged()</code> 根据无障碍功能按钮的可用性来响应变更。通过该方式，用户可以始终访问您的服务功能，即使该无障碍功能按钮不受支持或变得不可用。</p></blockquote><h2 id="独立的音量调整"><a href="#独立的音量调整" class="headerlink" title="独立的音量调整"></a>独立的音量调整</h2><p>Android 8.0 引入了 <strong>STREAM_ACCESSIBILITY</strong> 音量类别，允许您单独控制无障碍服务音频输出的音量，而不会影响设备上的其他声音。</p><p>要使用这个新的流类型来控制无障碍服务音量，请在无障碍服务中设置 <strong>FLAG_ENABLE_ACCESSIBILITY_VOLUME</strong> 选项。然后，您可以使用 <code>adjustStreamVolume()</code> 更改设备的无障碍服务音频音量。</p><h2 id="指纹手势"><a href="#指纹手势" class="headerlink" title="指纹手势"></a>指纹手势</h2><p>您的无障碍服务也可以响应替代的输入机制，即沿设备的指纹传感器按特定方向滑动（上、下、左和右）。要接收有关这些交互的回调，请完成以下一系列步骤：</p><ol><li>声明 <strong>USE_FINGERPRINT </strong>权限和 <strong>CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES</strong> 功能。</li><li>在 <strong>android:accessibilityFlags</strong> 属性中设置 <strong>FLAG_REQUEST_FINGERPRINT_GESTURES</strong> 标志。</li><li>使用 <code>registerFingerprintGestureCallback()</code> 注册回调。</li></ol><p>请记住，并非所有设备都包含指纹传感器。您可以使用 <code>isHardwareDetected()</code> 函数识别设备是否支持此传感器。即使对于包含指纹传感器的设备，您的服务也只有在指纹传感器不用于身份验证目的时才可使用它。要识别此传感器何时可用，请调用 <code>isGestureDetectionAvailable()</code> 函数并实现 <code>onGestureDetectionAvailabilityChanged()</code> 回调。</p><h2 id="字词级突出显示"><a href="#字词级突出显示" class="headerlink" title="字词级突出显示"></a>字词级突出显示</h2><p>要确定 <strong>TextView</strong> 对象中可见字符的位置，您可以在 <strong>EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY</strong> 中将其作为第一个参数传递到 <code>refreshWithExtraData()</code> 中。随后会更新您为 <code>refreshWithExtraData()</code> 提供的作为第二个参数的 <strong>Bundle</strong> 对象，使之包含一个可打包的 <strong>Rect</strong> 对象数组。每个 <strong>Rect</strong> 对象代表某个特定字符的边界框。</p><p>如果您的服务使用 <strong>TextToSpeech</strong> 对象朗读屏幕上出现的内容，您可以获取有关文本到语音转换引擎何时开始朗读单个合成字词时的准确时间信息，前提是文本到语音转换引擎提供此信息。当引擎即将开始播放特定范围文本的音频时，Text-to-Speech API 会通知您的服务，将使用 <code>onRangeStart()</code> 函数开始朗读此范围的文本。</p><p>如果您创建自己的 <strong>TextToSpeechService</strong> 实现，您可以使用 <code>rangeStart()</code> 函数支持这一新功能。</p><h2 id="标准化单端范围值"><a href="#标准化单端范围值" class="headerlink" title="标准化单端范围值"></a>标准化单端范围值</h2><p><strong>AccessibilityNodeInfo</strong> 的一些实例使用 <code>AccessibilityNodeInfo.RangeInfo</code> 的某个实例来表明界面元素可接受一定范围的值。使用 <code>RangeInfo.obtain()</code> 创建范围或使用 <code>getMin()</code> 和 <code>getMax()</code> 检索此范围的极值时，请注意，Android 8.0 规定了标准化单端范围：</p><ul><li>对于没有最小值的范围，<strong>Float.NEGATIVE_INFINITY</strong> 表示最小值。</li><li>对于没有最大值的范围，<strong>Float.POSITIVE_INFINITY</strong> 表示最大值。</li></ul><h2 id="提示文本"><a href="#提示文本" class="headerlink" title="提示文本"></a>提示文本</h2><p>Android 8.0 包含可用于与文本可编辑对象的提示文本进行交互的多个函数：</p><ul><li><code>isShowingHintText()</code> 和 <code>setShowingHintText()</code> 函数分别显示和设置节点的当前文本内容是否表示节点的提示文本。如果节点不包含可编辑文本，则它不应包含提示文本。</li><li>要访问提示文本本身，请使用 <code>getHintText()</code>。即使某个对象当前未显示提示文本，系统也能成功调用 <code>getHintText()</code>。</li></ul><h2 id="连续的手势分派"><a href="#连续的手势分派" class="headerlink" title="连续的手势分派"></a>连续的手势分派</h2><p>您的服务现在可以使用 <code>GestureDescription.StrokeDescription</code> 构造函数中的最后一个参数 <strong>willContinue</strong>，指定属于同一设定手势的笔划的顺序。</p><h1 id="安全性与隐私"><a href="#安全性与隐私" class="headerlink" title="安全性与隐私"></a>安全性与隐私</h1><hr><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>Android 8.0 引入了多个与电话有关的新权限：</p><ul><li><strong>ANSWER_PHONE_CALLS</strong> 允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用 <code>acceptRingingCall()</code> 函数。</li><li><strong>READ_PHONE_NUMBERS</strong> 权限允许您的应用读取设备中存储的电话号码。<br>这些权限均被划分为<strong>危险</strong>类别，属于 <strong>PHONE</strong> 权限组。</li></ul><p>##新的帐号访问和 Discovery API<br>Android 8.0 对应用访问用户帐号的方式引入多项改进。对于由身份验证器管理的帐号，身份验证器在决定对应用隐藏帐号还是显示帐号时可以使用自己的策略。Android 系统跟踪可以访问特定帐号的应用。</p><p>在以前的 Android 版本中，想要跟踪用户帐号列表的应用必须获取有关所有帐号的更新，包括具有不相关类型的帐号。Android 8.0 添加了 addOnAccountsUpdatedListener(android.accounts.OnAccountsUpdateListener, android.os.Handler, boolean, java.lang.String[]) 函数，其允许应用指定应接收帐号变更的帐号类型列表。</p><h3 id="API-变更-1"><a href="#API-变更-1" class="headerlink" title="API 变更"></a>API 变更</h3><p>AccountManager 提供六个新函数以帮助身份验证器管理哪些应用可以查看某个帐号：</p><ul><li><code>setAccountVisibility(android.accounts.Account, java.lang.String, int)</code>：针对特定用户帐号和软件包组合设置可见性级别。</li><li><code>getAccountVisibility(android.accounts.Account, java.lang.String)</code>：获取特定用户帐号和软件包组合的可见性级别。</li><li><code>getAccountsAndVisibilityForPackage(java.lang.String, java.lang.String)</code>：允许身份验证器获取帐号和给定软件包的可见性级别。</li><li><code>getPackagesAndVisibilityForAccount(android.accounts.Account)</code>：允许身份验证器获取存储的给定帐号的可见性值。</li><li><code>addAccountExplicitly(android.accounts.Account, java.lang.String, android.os.Bundle, java.util.Map&lt;java.lang.String, java.lang.Integer&gt;)</code>：允许身份验证器初始化帐号的可见性值。</li><li><code>addOnAccountsUpdatedListener(android.accounts.OnAccountsUpdateListener, android.os.Handler, boolean, java.lang.String[])</code>：将 <strong>OnAccountsUpdateListener</strong> 侦听器添加到 <strong>AccountManager</strong> 对象。无论设备上的帐号列表何时发生变化，系统都将调用此侦听器。</li></ul><p>Android 8.0 引入两个特殊的软件包名称值，以使用 <code>setAccountVisibility(android.accounts.Account, java.lang.String, int)</code> 函数指定未设置的应用的可见性级别。<strong>PACKAGE_NAME_KEY_LEGACY_VISIBLE</strong> 可见性值应用于具有 <strong>GET_ACCOUNTS</strong> 权限的应用，并且其目标 Android 版本低于 Android 8.0，或其签名与针对任意 Android 版本的身份验证器匹配。<strong>PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE</strong> 为之前未设置的应用提供默认的可见性值，对于此类应用，<strong>PACKAGE_NAME_KEY_LEGACY_VISIBLE</strong> 不适用。</p><p>如需了解有关新的帐号访问和发现 API 的详细信息，请参阅 <strong>AccountManager</strong> 和 <strong>OnAccountsUpdateListener</strong> 参考。</p><p>##Google Safe Browsing API<br>WebView 类现在添加了一个 Safe Browsing API 来增强网络浏览的安全性。如需了解详细信息，请参阅 <a href="https://developer.android.com/preview/features/managing-webview.html#safe-browsing" target="_blank" rel="noopener">Google Safe Browsing API</a>。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="仪器测试"><a href="#仪器测试" class="headerlink" title="仪器测试"></a>仪器测试</h2><p>Android 8.0 为应用的仪器测试提供以下几项额外支持。</p><h3 id="针对非默认应用进程运行"><a href="#针对非默认应用进程运行" class="headerlink" title="针对非默认应用进程运行"></a>针对非默认应用进程运行</h3><p>现在，您可以指定针对您的应用的默认进程以外的进程运行特定仪器测试。如果您的应用包含多个在不同进程中运行的操作组件，此配置非常有用。</p><p>要定义非默认进程仪器测试，请导航至您的清单文件，然后导航至所需的 <code>&lt;instrumentation&gt;</code> 元素。添加 <code>android:targetProcess</code> 属性，并将它的值设置为以下值之一：</p><ul><li>特定进程的名称。</li><li>以逗号分隔的进程名称列表。</li><li>通配符（”*”），允许针对任何执行 <strong>android:targetPackage</strong> 属性中指定的软件包中的代码的已启动进程运行仪器测试。<br>在执行仪器测试时，您可以通过调用 <code>getProcessName()</code> 检查正在测试哪个进程。</li></ul><h3 id="在测试过程中报告结果"><a href="#在测试过程中报告结果" class="headerlink" title="在测试过程中报告结果"></a>在测试过程中报告结果</h3><p>现在，通过调用 <code>addResults()</code>，您可以在执行仪器测试时（而不用等到测试后）报告结果。</p><h2 id="用于测试的模拟-Intent"><a href="#用于测试的模拟-Intent" class="headerlink" title="用于测试的模拟 Intent"></a>用于测试的模拟 Intent</h2><p>为了更轻松地为您应用的操作组件创建隔离、独立的界面测试，Android 8.0 引入了 <code>onStartActivity()</code> 函数。要处理您的测试类调用的特定 intent，您可以在 <code>nstrumentation.ActivityMonitor</code> 类的自定义子类中替换此函数。</p><p>当您的测试类调用 intent 时，该函数将返回一个存根 <code>Instrumentation.ActivityResult</code> 对象，而不是执行 intent 本身。通过在您的测试中使用这种模拟 intent 逻辑，您可以侧重于自己的操作组件如何准备和处理您传递到不同操作组件或完全不同的应用中的 intent。</p><h1 id="运行时和工具"><a href="#运行时和工具" class="headerlink" title="运行时和工具"></a>运行时和工具</h1><hr><h2 id="平台优化"><a href="#平台优化" class="headerlink" title="平台优化"></a>平台优化</h2><p>Android 8.0 为平台引入了运行时优化和其他优化，这些优化将带来多项性能改进。这些优化包括并发压缩垃圾回收、更有效的内存利用和代码区域。</p><p>它们可以加快启动时间，并为 OS 和应用带来更好的性能。</p><h2 id="更新的-Java-支持"><a href="#更新的-Java-支持" class="headerlink" title="更新的 Java 支持"></a>更新的 Java 支持</h2><p>Android 8.0 添加了对更多 OpenJDK Java API 的支持：</p><ul><li>OpenJDK 8 中的 java.time。</li><li>OpenJDK 7 中的 java.nio.file 和 java.lang.invoke。<br>要详细了解这些新添加的软件包中的类和函数，请参阅 API 参考文档。</li></ul><p>如果您想要在 Android Studio 中使用 <a href="https://developer.android.com/studio/preview/features/java8-support.html" target="_blank" rel="noopener">Java 8 语言功能</a>，您应下载最新的预览版本。</p><h2 id="更新的-ICU4J-Android-Framework-API"><a href="#更新的-ICU4J-Android-Framework-API" class="headerlink" title="更新的 ICU4J Android Framework API"></a>更新的 ICU4J Android Framework API</h2><p>Android 8.0 扩展了 ICU4J Android 框架 API—，它是 ICU4J API 的子集—，供应用开发者在 android.icu 软件包中使用。这些 API 使用设备上具有的本地化数据。因此，您无需在 APK 中编译 ICU4J 库，从而减少 APK 占用空间。</p><h1 id="Android-企业版"><a href="#Android-企业版" class="headerlink" title="Android 企业版"></a>Android 企业版</h1><hr><p>已为运行 Android 8.0 的设备引入新的企业功能和 API。重要功能包括如下：</p><ul><li>完全托管的设备中的工作资料使企业可以在管理工作数据与个人数据的同时，将它们分离开来。</li><li>API 委派允许设备所有者和个人资料所有者将应用管理分配给其他应用。</li><li>配置流程中的用户体验改进措施（包含新的自定义选项）缩短了设置时间。</li><li>蓝牙、WLAN、备份和安全性方面的新增控制选项使企业可以更精细地管理设备。网络操作组件日志记录可帮助企业追查问题。</li></ul><p>如需详细了解上述及其他新增 Android 企业版 API 和功能，请参阅<a href="https://developer.android.com/preview/features/work.html" target="_blank" rel="noopener">企业中的 Android</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用户体验&quot;&gt;&lt;a href=&quot;#用户体验&quot; class=&quot;headerlink&quot; title=&quot;用户体验&quot;&gt;&lt;/a&gt;用户体验&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;通知&quot;&gt;&lt;a href=&quot;#通知&quot; class=&quot;headerlink&quot; title=&quot;通知&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Oreo" scheme="http://yoursite.com/tags/Oreo/"/>
    
      <category term="Android8.0" scheme="http://yoursite.com/tags/Android8-0/"/>
    
  </entry>
  
</feed>
