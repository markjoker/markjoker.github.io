<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>随手记</title>
  
  <subtitle>不积跬步无以至千里</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-30T08:57:46.611Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>马建</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>android-6.0-changes</title>
    <link href="http://yoursite.com/2018/05/12/android-6-0-changes/"/>
    <id>http://yoursite.com/2018/05/12/android-6-0-changes/</id>
    <published>2018-05-12T11:56:45.000Z</published>
    <updated>2018-03-30T08:57:46.611Z</updated>
    
    <content type="html"><![CDATA[<p>Android 6.0（API 级别 23）除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。</p><p>如果您之前发布过 Android 应用，请注意您的应用可能受到这些平台变更的影响。</p><h1 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h1><hr><p>此版本引入了一种新的权限模式，如今，用户可直接在运行时管理应用权限。这种模式让用户能够更好地了解和控制权限，同时为应用开发者精简了安装和自动更新过程。用户可为所安装的各个应用分别授予或撤销权限。</p><p>对于以 Android 6.0（API 级别 23）或更高版本为目标平台的应用，请务必在运行时检查和请求权限。要确定您的应用是否已被授予权限，请调用新增的 <code>checkSelfPermission()</code> 方法。要请求权限，请调用新增的 <code>requestPermissions()</code> 方法。即使您的应用并不以 Android 6.0（API 级别 23）为目标平台，您也应该在新权限模式下测试您的应用。</p><p>如需了解有关在您的应用中支持新权限模式的详情，请参阅<a href="https://developer.android.com/training/permissions/index.html" target="_blank" rel="noopener">使用系统权限</a>。如需了解有关如何评估新模式对应用的影响的提示，请参阅<a href="https://developer.android.com/training/permissions/best-practices.html#testing" target="_blank" rel="noopener">权限最佳做法</a>。</p><h1 id="低电耗模式和应用待机模式"><a href="#低电耗模式和应用待机模式" class="headerlink" title="低电耗模式和应用待机模式"></a>低电耗模式和应用待机模式</h1><hr><p>此版本引入了针对空闲设备和应用的最新节能优化技术。这些功能会影响所有应用，因此请务必在这些新模式下测试您的应用。</p><ul><li><strong>低电耗模式：</strong>如果用户拔下设备的电源插头，并在屏幕关闭后的一段时间内使其保持不活动状态，设备会进入低电耗模式，在该模式下设备会尝试让系统保持休眠状态。在该模式下，设备会定期短时间恢复正常工作，以便进行应用同步，还可让系统执行任何挂起的操作。</li><li><strong>应用待机模式：</strong>应用待机模式允许系统判定应用在用户未主动使用它时处于空闲状态。当用户有一段时间未触摸应用时，系统便会作出此判定。如果拔下了设备电源插头，系统会为其视为空闲的应用停用网络访问以及暂停同步和作业。<br>要详细了解这些节能变更，请参阅<a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="noopener">对低电耗模式和应用待机模式进行针对性优化</a>。</li></ul><h1 id="取消支持-Apache-HTTP-客户端"><a href="#取消支持-Apache-HTTP-客户端" class="headerlink" title="取消支持 Apache HTTP 客户端"></a>取消支持 Apache HTTP 客户端</h1><hr><p>Android 6.0 版移除了对 Apache HTTP 客户端的支持。如果您的应用使用该客户端，并以 Android 2.3（API 级别 9）或更高版本为目标平台，请改用 <code>HttpURLConnection</code> 类。此 API 效率更高，因为它可以通过透明压缩和响应缓存减少网络使用，并可最大限度降低耗电量。要继续使用 Apache HTTP API，您必须先在 <code>build.gradle</code> 文件中声明以下编译时依赖项：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    useLibrary <span class="string">'org.apache.http.legacy'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="BoringSSL"><a href="#BoringSSL" class="headerlink" title="BoringSSL"></a>BoringSSL</h1><hr><p>Android 正在从使用 OpenSSL 库转向使用 BoringSSL 库。如果您要在应用中使用 Android NDK，请勿链接到并非 NDK API 组成部分的加密库，如 libcrypto.so 和 libssl.so。这些库并非公共 API，可能会在不同版本和设备上毫无征兆地发生变化或出现故障。此外，您还可能让自己暴露在安全漏洞的风险之下。请改为修改原生代码，以通过 JNI 调用 Java 加密 API，或静态链接到您选择的加密库。</p><h1 id="硬件标识符访问权"><a href="#硬件标识符访问权" class="headerlink" title="硬件标识符访问权"></a>硬件标识符访问权</h1><hr><p>为给用户提供更严格的数据保护，从此版本开始，对于使用 WLAN API 和 Bluetooth API 的应用，Android 移除了对设备本地硬件标识符的编程访问权。<code>WifiInfo.getMacAddress()</code> 方法和 <code>BluetoothAdapter.getAddress()</code> 方法现在会返回常量值 02:00:00:00:00:00。</p><p>现在，要通过蓝牙和 WLAN 扫描访问附近外部设备的硬件标识符，您的应用必须拥有 <code>ACCESS_FINE_LOCATION</code> 或 <code>ACCESS_COARSE_LOCATION</code> 权限。</p><ul><li>WifiManager.getScanResults()</li><li>BluetoothDevice.ACTION_FOUND</li><li>BluetoothLeScanner.startScan()<blockquote><p><strong>注：</strong>当运行 Android 6.0（API 级别 23）的设备发起后台 WLAN 或蓝牙扫描时，在外部设备看来，该操作的发起来源是一个随机化 MAC 地址。</p></blockquote></li></ul><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><hr><p>此版本移除了 <code>Notification.setLatestEventInfo()</code> 方法。请改用 <code>Notification.Builder</code> 类来构建通知。要重复更新通知，请重复使用 <code>Notification.Builder</code> 实例。调用 <code>build()</code> 方法可获取更新后的 <code>Notification</code> 实例。</p><p><code>adb shell dumpsys notification</code> 命令不再打印输出您的通知文本。请改用 <code>adb shell dumpsys notification --noredact</code> 命令打印输出 notification 对象中的文本。</p><h1 id="音频管理器变更"><a href="#音频管理器变更" class="headerlink" title="音频管理器变更"></a>音频管理器变更</h1><hr><p>不再支持通过 <code>AudioManager</code> 类直接设置音量或将特定音频流静音。<code>setStreamSolo()</code> 方法已弃用，您应该改为调用 <code>requestAudioFocus()</code> 方法。类似地，<code>setStreamMute()</code> 方法也已弃用，请改为调用 <code>adjustStreamVolume()</code> 方法并传入方向值 <code>ADJUST_MUTE</code> 或 <code>ADJUST_UNMUTE</code>。</p><h1 id="文本选择"><a href="#文本选择" class="headerlink" title="文本选择"></a>文本选择</h1><hr><p><img src="/2018/05/12/android-6-0-changes/text-selection.gif" style="width:300px; float: right; margin-left:20px"><br>现在，当用户在您的应用中选择文本时，您可以在一个浮动工具栏中显示“剪切”、“复制”和“粘贴”等文本选择操作。其在用户交互实现上与为单个视图启用上下文操作模式中所述的上下文操作栏类似。</p><p>要实现可用于文本选择的浮动工具栏，请在您的现有应用中做出以下更改：</p><ol><li>在 <code>View</code> 对象或 <code>Activity</code> 对象中，将 <code>ActionMode</code> 调用从 <code>startActionMode(Callback)</code> 更改为 <code>startActionMode(Callback, ActionMode.TYPE_FLOATING)</code>。</li><li>改为使用 <code>ActionMode.Callback</code> 的现有实现扩展 <code>ActionMode.Callback2</code>。</li><li>替代 <code>onGetContentRect()</code> 方法，用于提供 Rect 内容对象（如文本选择矩形）在视图中的坐标。</li><li>如果矩形的定位不再有效，并且这是唯一需要声明为无效的元素，请调用 <code>invalidateContentRect()</code> 方法。</li></ol><p>请注意，如果您使用 Android 支持库 22.2 修订版，浮动工具栏不向后兼容，默认情况下 appcompat 会获得对 <code>ActionMode</code> 对象的控制权。这会禁止显示浮动工具栏。要在 ActionMode 中启用 <code>AppCompatActivity</code> 支持，请调用 <code>getDelegate()</code>，然后对返回的 <code>setHandleNativeActionModesEnabled()</code> 对象调用 <code>AppCompatDelegate</code>，并将输入参数设置为 false。此调用会将 <code>ActionMode</code> 对象的控制权交还给框架。在运行 Android 6.0（API 级别 23）的设备上，框架可以支持 <code>ActionBar</code> 模式或浮动工具栏模式；而在运行 Android 5.1（API 级别 22）或之前版本的设备上，框架仅支持 <code>ActionBar</code> 模式。</p><h1 id="浏览器书签变更"><a href="#浏览器书签变更" class="headerlink" title="浏览器书签变更"></a>浏览器书签变更</h1><hr><p>此版本移除了对全局书签的支持。<code>android.provider.Browser.getAllBookmarks()</code> 和 <code>android.provider.Browser.saveBookmark()</code> 方法现已移除。同样，<code>READ_HISTORY_BOOKMARKS</code> 权限和 <code>WRITE_HISTORY_BOOKMARKS</code> 权限也已移除。如果您的应用以 Android 6.0（API 级别 23）或更高版本为目标平台，请勿从全局提供程序访问书签或使用书签权限。您的应用应改为在内部存储书签数据。</p><h1 id="Android-密钥库变更"><a href="#Android-密钥库变更" class="headerlink" title="Android 密钥库变更"></a>Android 密钥库变更</h1><hr><p>从此版本开始，Android 密钥库提供程序不再支持 DSA。但仍支持 ECDSA。</p><p>停用或重置安全锁定屏幕时（例如，由用户或设备管理员执行此类操作时），系统将不再删除需要闲时加密的密钥，但在上述事件期间会删除需要闲时加密的密钥。</p><h1 id="WLAN-和网络连接变更"><a href="#WLAN-和网络连接变更" class="headerlink" title="WLAN 和网络连接变更"></a>WLAN 和网络连接变更</h1><hr><p>此版本对 WLAN API 和 Networking API 引入了以下行为变更。</p><ul><li>现在，您的应用只能更改由您创建的 <code>WifiConfiguration</code> 对象的状态。系统不允许您修改或删除由用户或其他应用创建的 <code>WifiConfiguration</code> 对象。</li><li>在之前的版本中，如果应用利用带有 disableAllOthers=true 设置的 <code>enableNetwork()</code> 强制设备连接特定 WLAN 网络，设备将会断开与移动数据网络等其他网络的连接。在此版本中，设备不再断开与上述其他网络的连接。如果您的应用的 targetSdkVersion 为 “20” 或更低，则会固定连接所选 WLAN 网络。如果您的应用的 targetSdkVersion 为 “21” 或更高，请使用多网络 API（如 <code>openConnection()</code>、<code>bindSocket()</code> 和新增的 <code>bindProcessToNetwork()</code> 方法）来确保通过所选网络传送网络流量。</li></ul><h1 id="相机服务变更"><a href="#相机服务变更" class="headerlink" title="相机服务变更"></a>相机服务变更</h1><hr><p>在此版本中，相机服务中共享资源的访问模式已从之前的“先到先得”访问模式更改为高优先级进程优先的访问模式。对服务行为的变更包括：</p><ul><li>根据客户端应用进程的“优先级”授予对相机子系统资源的访问权，包括打开和配置相机设备。带有对用户可见 Activity 或前台 Activity 的应用进程一般会被授予较高的优先级，从而使相机资源的获取和使用更加可靠；</li><li>当高优先级的应用尝试使用相机时，系统可能会“驱逐”正在使用相机客户端的低优先级应用。在已弃用的 Camera API 中，这会导致系统为被驱逐的客户端调用 onError()。在 Camera2 API 中，这会导致系统为被驱逐的客户端调用 onDisconnected()；</li><li>在配备相应相机硬件的设备上，不同的应用进程可同时独立打开和使用不同的相机设备。但现在，如果在多进程用例中同时访问相机会造成任何打开的相机设备的性能或能力严重下降，相机服务会检测到这种情况并禁止同时访问。即使并没有其他应用直接尝试访问同一相机设备，此变更也可能导致低优先级客户端被“驱逐”。</li><li>更改当前用户会导致之前用户帐户拥有的应用内活动相机客户端被驱逐。对相机的访问仅限于访问当前设备用户拥有的用户个人资料。举例来说，这意味着，当用户切换到其他帐户后，“来宾”帐户实际上无法让使用相机子系统的进程保持运行状态。</li></ul><h1 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h1><hr><p>ART 运行时环境现在可正确实现 <code>newInstance()</code> 方法的访问规则。此变更修正了之前版本中 Dalvik 无法正确检查访问规则的问题。如果您的应用使用 newInstance() 方法，并且您想重写访问检查，请调用 <code>setAccessible()</code> 方法（将输入参数设置为 true）。如果您的应用使用 v7 appcompat 库或 v7 recyclerview 库，则您必须更新应用以使用这些库的最新版本。否则，请务必更新从 XML 引用的任何自定义类，以便能够访问它们的类构造函数。</p><p>此版本更新了动态链接程序的行为。动态链接程序现在可以识别库的 soname 与其路径之间的差异（公开错误 6670），并且现在已实现了按 soname 搜索。之前包含错误的 DT_NEEDED 条目（通常是开发计算机文件系统上的绝对路径）却仍工作正常的应用，如今可能会出现加载失败。</p><p>现已正确实现 dlopen(3) RTLD_LOCAL 标记。请注意，RTLD_LOCAL 是默认值，因此不显式使用 RTLD_LOCAL 的 dlopen(3) 调用将受到影响（除非您的应用显式使用 RTLD_GLOBAL）。使用 RTLD_LOCAL 时，在随后通过调用 dlopen(3) 加载的库中并不能使用这些符号（这与由 DT_NEEDED 条目引用的情况截然不同）。</p><p>在之前版本的 Android 上，如果您的应用请求系统加载包含文本重定位信息的共享库，系统会显示警告，但仍允许加载共享库。从此版本开始，如果您的应用的目标 SDK 版本为 23 或更高，则系统会拒绝加载该库。为帮助您检测库是否加载失败，您的应用应该记录 dlopen(3) 失败日志，并在日志中加入 dlerror(3) 调用返回的问题描述文本。要详细了解如何处理文本重定位，请参阅此指南。</p><h1 id="APK-验证"><a href="#APK-验证" class="headerlink" title="APK 验证"></a>APK 验证</h1><hr><p>该平台现在执行的 APK 验证更为严格。如果在清单中声明的文件在 APK 中并不存在，该 APK 将被视为已损坏。移除任何内容后必须重新签署 APK。</p><h1 id="USB-连接"><a href="#USB-连接" class="headerlink" title="USB 连接"></a>USB 连接</h1><hr><p>默认情况下，现在通过 USB 端口进行的设备连接设置为仅充电模式。要通过 USB 连接访问设备及其内容，用户必须明确地为此类交互授予权限。如果您的应用支持用户通过 USB 端口与设备进行交互，请将必须显式启用交互考虑在内。</p><h1 id="Android-for-Work-变更"><a href="#Android-for-Work-变更" class="headerlink" title="Android for Work 变更"></a>Android for Work 变更</h1><hr><p>此版本包含下列针对 Android for Work 的行为变更：</p><ul><li><strong>个人上下文中的工作联系人：</strong>Google 拨号器通话记录现在会在用户查看通话记录时显示工作联系人。将 setCrossProfileCallerIdDisabled() 设置为 true 可在 Google 拨号器通话记录中隐藏托管配置文件联系人。仅当您将 setBluetoothContactSharingDisabled() 设置为 false 时，才可以通过蓝牙将工作联系人随个人联系人一起显示给设备。默认情况下，它设置为 true。</li><li><strong>WLAN 配置删除：</strong>现在，当删除某个托管配置文件时，将会移除由配置文件所有者添加的 WLAN 配置（例如，通过调用 addNetwork() 方法添加的配置）。</li><li><strong>WLAN 配置锁定：</strong>如果 WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN 不为零，则用户无法再修改或删除任何由活动设备所有者创建的 WLAN 配置。用户仍可创建和修改其自己的 WLAN 配置。活动设备所有者拥有编辑或删除任何 WLAN 配置（包括并非由其创建的配置）的权限。</li><li><strong>通过添加 Google 帐户下载设备规范控制器：</strong>向托管环境以外的设备添加需要通过设备规范控制器 (DPC) 应用管理的 Google 帐户时，帐户添加流程现在会提示用户安装相应的 WPC。在设备初始设置向导中通过 Settings &gt; Accounts 添加帐户时，也会出现此行为。</li><li><strong>对特定 DevicePolicyManager API 行为的变更：</strong><ul><li>调用 setCameraDisabled() 方法只会影响调用该方法的用户的相机；从托管配置文件调用它不会影响主用户运行的相机应用。</li><li>此外，setKeyguardDisabledFeatures() 方法现在除了可供设备所有者使用外，还可供配置文件所有 者使用。</li><li>配置文件所有者可设置以下键盘锁限制：<pre><code>- KEYGUARD_DISABLE_TRUST_AGENTS 和 KEYGUARD_DISABLE_FINGERPRINT，它们影响配置文件上级用户的键盘锁设置。- KEYGUARD_DISABLE_UNREDACTED_NOTIFICATIONS，它只影响应用在托管配置文件中生成的通知。</code></pre></li><li>DevicePolicyManager.createAndInitializeUser() 方法和 DevicePolicyManager.createUser() 方法已弃用。</li><li>当给定用户的应用在前台运行时，setScreenCaptureDisabled() 方法现在也会屏蔽辅助结构。</li><li>EXTRA_PROVISIONING_DEVICE_ADMIN_PACKAGE_CHECKSUM 现在默认为 SHA-256。出于向后兼容性考虑，仍然支持 SHA-1，但未来将会取消该支持。  EXTRA_PROVISIONING_DEVICE_ADMIN_SIGNATURE_CHECKSUM 现在只接受 SHA-256。<ul><li>Android 6.0（API 级别 23）中曾经存在的 Device initializer API 现已删除</li><li>EXTRA_PROVISIONING_RESET_PROTECTION_PARAMETERS 已删除，因此 NFC 占位配置无法通过编程解锁受恢复出厂设置保护的设备</li><li>您现在可以使用 EXTRA_PROVISIONING_ADMIN_EXTRAS_BUNDLE extra 在对托管设备进行 NFC 配置期间向设备所有者应用传递数据。</li><li>Android for Work API 针对 M 运行时权限（包括 Work 配置文件、辅助层及其他内容）进行了优化。新增的 DevicePolicyManager 权限 API 不会影响 M 之前版本的应用。</li><li>当用户退出通过 ACTION_PROVISION_MANAGED_PROFILE 或 ACTION_PROVISION_MANAGED_DEVICE intent 发起的设置流程的同步部分时，系统现在会返回 RESULT_CANCELED 结果代码。</li></ul></li></ul></li><li>对其他 API 的变更：<ul><li>流量消耗：android.app.usage.NetworkUsageStats 类已重命名为 NetworkStats。</li></ul></li><li>对全局设置的变更：<ul><li>这些设置不再通过 setGlobalSettings() 进行设置：<ul><li>BLUETOOTH_ON</li><li>DEVELOPMENT_SETTINGS_ENABLED</li><li>MODE_RINGER</li><li>NETWORK_PREFERENCE</li><li>WIFI_ON</li></ul></li><li>这些全局设置现在可通过 setGlobalSettings() 进行设置：<br>  -WIFI_DEVICE_OWNER_CONFIGS_LOCKDOWN</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 6.0（API 级别 23）除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。&lt;/p&gt;
&lt;p&gt;如果您之前发布过 Android 应用，请注意您的应用可能受到这些平台变更的影响。&lt;/
      
    
    </summary>
    
    
      <category term="Anroid" scheme="http://yoursite.com/tags/Anroid/"/>
    
      <category term="Marshmallow" scheme="http://yoursite.com/tags/Marshmallow/"/>
    
      <category term="Anroid6.0" scheme="http://yoursite.com/tags/Anroid6-0/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
  </entry>
  
  <entry>
    <title>React Native 自签名Https处理</title>
    <link href="http://yoursite.com/2018/03/28/react-native-https/"/>
    <id>http://yoursite.com/2018/03/28/react-native-https/</id>
    <published>2018-03-28T07:43:22.000Z</published>
    <updated>2018-03-29T03:12:26.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>现在绝大多数网站已转为https方式浏览，但很多情况下https的证书并不是CA颁发的合法证书，而是通过公司或个人自签名产生的证书。当我们在开发移动应用时，对于这种自签名证书，通常是需要额外的通过证书来校验访问的合法性。<br>当我们再开发React Native应用时，由于框架封装了网络请求库，造成我们无法自定义相关逻辑。本文的主要目的就是记录一下再开发过程中遇到此类问题是怎么解决的。</p><h2 id="IOS处理"><a href="#IOS处理" class="headerlink" title="IOS处理"></a>IOS处理</h2><ol><li>使用Xcode打开ios代码</li><li>在<code>Libraries</code>下展开 <code>RCTNetwork.xcodeproj</code> 找到 <code>RCTHTTPRequestHandler.m</code> 文件<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/03/28/react-native-https/26fa978f-a83b-4e49-b6b3-dab541da890c.png" alt="logo" title="">                </div>                <div class="image-caption">logo</div>            </figure></li><li><p>在文件中找到下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSURLSession delegate</span></span><br></pre></td></tr></table></figure></li><li><p>在此代码下方添加如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(<span class="keyword">void</span> (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">  completionHandler(NSURLSessionAuthChallengeUseCredential, [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编辑info.plist文件，修改如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAllowsArbitraryLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2018/03/28/react-native-https/794c1115-612a-4e30-ac96-f1c2c8e8648f.png" alt="info.plist" title="">                </div>                <div class="image-caption">info.plist</div>            </figure><ol start="6"><li>完成配置，重新打包即可<h2 id="Android处理"><a href="#Android处理" class="headerlink" title="Android处理"></a>Android处理</h2>Android下React Native使用OKHTTP作为网络请求库，由于npm在安装react-native时已经编译过相关第三方依赖库，所以要改动依赖库中的代码，我们需要下载ReactAndroid的源代码，修改OKHTTP源码后重新编译。所以过程相对IOS会复杂很多，下面我们开始一步步来完成相关工作。</li><li>下载NDK，解压<br> NDK官方<a href="https://dl.google.com/android/repository/android-ndk-r10e-windows-x86_64.zip" target="_blank" rel="noopener">下载地址</a></li><li>local.properties 中设置ndk.dir.</li><li><p>修改<code>settings.gradle</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">':ReactAndroid'</span></span><br><span class="line"><span class="keyword">project</span>(<span class="string">':ReactAndroid'</span>).projectDir = <span class="keyword">new</span> <span class="keyword">File</span>(rootProject.projectDir, <span class="string">'../node_modules/react-native/ReactAndroid'</span>)</span><br></pre></td></tr></table></figure></li><li><p>修改<code>app/build.gradle</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compile "com.facebook.react:react-native:+"  // From node_modules</span></span><br><span class="line"><span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':ReactAndroid'</span>)</span><br><span class="line"><span class="comment">//可能在需要添加一下代码</span></span><br><span class="line"><span class="keyword">configurations</span>.all &#123;</span><br><span class="line"> <span class="keyword">exclude</span> <span class="keyword">group</span>: <span class="string">'com.facebook.react'</span>, module: <span class="string">'react-native'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改ReactAndroid中OKHTTP相关源代码，打开<code>node_modules/react-native/ReactAndroid/src/main/java/com/facebook/react/modules/network/OkHttpClientProvider.java</code>文件，修改文件内容为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClientProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Centralized OkHttpClient for all networking requests.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> OkHttpClient sClient;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient <span class="title">getOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">  sClient = createClient();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sClient;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// okhttp3 OkHttpClient is immutable</span></span><br><span class="line">  <span class="comment">// This allows app to init an OkHttpClient with custom settings.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replaceOkHttpClient</span><span class="params">(OkHttpClient client)</span> </span>&#123;</span><br><span class="line">  sClient = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient <span class="title">createClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// No timeouts by default</span></span><br><span class="line">  OkHttpClient.Builder client = getUnsafeOkHttpClient()</span><br><span class="line">  .connectTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">  .readTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">  .writeTimeout(<span class="number">0</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">  .cookieJar(<span class="keyword">new</span> ReactCookieJarContainer());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> enableTls12OnPreLollipop(client).build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  On Android 4.1-4.4 (API level 16 to 19) TLS 1.1 and 1.2 are</span></span><br><span class="line"><span class="comment">  available but not enabled by default. The following method</span></span><br><span class="line"><span class="comment">  enables it.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient.<span class="function">Builder <span class="title">enableTls12OnPreLollipop</span><span class="params">(OkHttpClient.Builder client)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN &amp;&amp; Build.VERSION.SDK_INT &lt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  client.sslSocketFactory(<span class="keyword">new</span> TLSSocketFactory());</span><br><span class="line"></span><br><span class="line">  ConnectionSpec cs = <span class="keyword">new</span> ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)</span><br><span class="line">  .tlsVersions(TlsVersion.TLS_1_2)</span><br><span class="line">  .build();</span><br><span class="line"></span><br><span class="line">  List&lt;ConnectionSpec&gt; specs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  specs.add(cs);</span><br><span class="line">  specs.add(ConnectionSpec.COMPATIBLE_TLS);</span><br><span class="line">  specs.add(ConnectionSpec.CLEARTEXT);</span><br><span class="line"></span><br><span class="line">  client.connectionSpecs(specs);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception exc) &#123;</span><br><span class="line">  FLog.e(<span class="string">"OkHttpClientProvider"</span>, <span class="string">"Error while enabling TLS 1.2"</span>, exc);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> OkHttpClient.<span class="function">Builder <span class="title">getUnsafeOkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// Create a trust manager that does not validate certificate chains</span></span><br><span class="line">  <span class="keyword">final</span> TrustManager[] trustAllCerts = <span class="keyword">new</span> TrustManager[]&#123;</span><br><span class="line">  <span class="keyword">new</span> X509TrustManager() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(java.security.cert.X509Certificate[] chain, String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> java.security.cert.X509Certificate[]&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install the all-trusting trust manager</span></span><br><span class="line">  <span class="keyword">final</span> SSLContext sslContext = SSLContext.getInstance(<span class="string">"SSL"</span>);</span><br><span class="line">  sslContext.init(<span class="keyword">null</span>, trustAllCerts, <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line">  <span class="comment">// Create an ssl socket factory with our all-trusting manager</span></span><br><span class="line">  <span class="keyword">final</span> SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();</span><br><span class="line"></span><br><span class="line">  OkHttpClient.Builder builder = <span class="keyword">new</span> OkHttpClient.Builder();</span><br><span class="line">  builder.sslSocketFactory(sslSocketFactory);</span><br><span class="line">  builder.hostnameVerifier(<span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String hostname, SSLSession session)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> builder;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行<code>react-native run-android</code>开始编译，过程中可能会报错，Google解决一下即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;现在绝大多数网站已转为https方式浏览，但很多情况下https的证书并不是CA颁发的合法证书，而是通过公司或个人自签名产生
      
    
    </summary>
    
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>Android 8.0 行为变更</title>
    <link href="http://yoursite.com/2017/09/15/android-8-0-changes/"/>
    <id>http://yoursite.com/2017/09/15/android-8-0-changes/</id>
    <published>2017-09-15T03:02:23.000Z</published>
    <updated>2018-03-30T06:23:54.575Z</updated>
    
    <content type="html"><![CDATA[<p>Android 8.0 除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。</p><p>其中大部分变更会影响所有应用，而不论应用针对的是何种版本的 Android。不过，有几项变更仅影响针对 Android 8.0 的应用。为清楚起见，本页面分为两个部分：<strong>针对所有 API 级别的应用</strong>和<strong>针对 Android 8.0 的应用</strong>。</p><h1 id="针对所有-API-级别的应用"><a href="#针对所有-API-级别的应用" class="headerlink" title="针对所有 API 级别的应用"></a>针对所有 API 级别的应用</h1><hr><p>这些行为变更适用于 在 Android 8.0 平台上运行的 所有应用，无论这些应用是针对哪个 API 级别构建。所有开发者都应查看这些变更，并修改其应用以正确支持这些变更（如果适用）。</p><h2 id="后台执行限制"><a href="#后台执行限制" class="headerlink" title="后台执行限制"></a>后台执行限制</h2><p>Android 8.0 为提高电池续航时间而引入的变更之一是，当您的应用进入<strong>已缓存</strong>状态时，如果没有活动的<strong>组件</strong>，系统将解除应用具有的所有唤醒锁。</p><p>此外，为提高设备性能，系统会限制未在前台运行的应用的某些行为。具体而言：</p><ul><li>现在，在后台运行的应用对后台服务的访问受到限制。</li><li>应用无法使用其清单注册大部分隐式广播（即，并非专门针对此应用的广播）。</li></ul><p>默认情况下，这些限制仅适用于针对 O 的应用。不过，用户可以从 Settings 屏幕为任意应用启用这些限制，即使应用并不是以 O 为目标平台。<br>Android 8.0 还对特定函数做出了以下变更：</p><ul><li>如果针对 Android 8.0 的应用尝试在不允许其创建后台服务的情况下使用 <code>startService()</code> 函数，则该函数将引发一个 <code>IllegalStateException</code>。</li><li>新的 <code>Context.startForegroundService()</code> 函数将启动一个前台服务。现在，即使应用在后台运行，系统也允许其调用 <code>Context.startForegroundService()</code>。不过，应用必须在创建服务后的五秒内调用该服务的 <code>startForeground()</code> 函数。<br>如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/background.html" target="_blank" rel="noopener">后台执行限制</a>。</li></ul><h2 id="Android-后台位置限制"><a href="#Android-后台位置限制" class="headerlink" title="Android 后台位置限制"></a>Android 后台位置限制</h2><p>为节约电池电量、保持良好的用户体验和确保系统健康运行，在运行 Android 8.0 的设备上使用后台应用时，降低了后台应用接收位置更新的频率。此行为变更会影响包括 Google Play 服务在内的所有接收位置更新的应用。</p><p>此类变更会影响以下 API：</p><ul><li>Fused Location Provider (FLP)</li><li>Geofencing</li><li>GNSS Measurements</li><li>Location Manager</li><li>Wi-Fi Manager</li></ul><p>为确保您的应用按预期方式运行，请完成以下步骤：</p><ul><li>查看您的应用的逻辑，并确保您使用的是最新的位置 API。</li><li>测试您的应用是否在每个用例中都表现出预期行为。</li><li>考虑使用 Fused Location Provider (FLP) 或地理围栏来处理依赖于用户当前位置的用例。</li></ul><p>如需了解此类变更的详细信息，请参阅后台位置限制。</p><h2 id="应用快捷键"><a href="#应用快捷键" class="headerlink" title="应用快捷键"></a>应用快捷键</h2><p>Android 8.0 对应用快捷方式做出了以下变更：</p><ul><li><code>com.android.launcher.action.INSTALL_SHORTCUT</code> 广播不再会对您的应用有任何影响，因为它现在是私有的隐式广播。相反，您应使用 <code>ShortcutManager</code> 类中的 <code>requestPinShortcut()</code> 函数创建应用快捷方式。</li><li>现在，<code>ACTION_CREATE_SHORTCUT</code> Intent 可以创建可使用 <code>ShortcutManager</code> 类进行管理的应用快捷方式。此 Intent 还可以创建不与 <code>ShortcutManager</code> 交互的旧版启动器快捷方式。在以前，此 Intent 只能创建旧版启动器快捷方式。</li><li>现在，使用 <code>requestPinShortcut()</code> 创建的快捷方式和在处理 <code>ACTION_CREATE_SHORTCUT Intent</code> 的操作组件中创建的快捷方式均已转换为功能齐全的应用快捷方式。因此，应用现在可以使用 ShortcutManager 中的函数来更新这些快捷方式。</li><li>旧版快捷方式仍然保留了它们在旧版 Android 中的功能，但您必须在应用中手动将它们转换成应用快捷方式。</li></ul><p>如需了解有关应用快捷方式变更的更多信息，请参阅<a href="https://developer.android.com/preview/features/pinning-shortcuts-widgets.html" target="_blank" rel="noopener">固定快捷方式和微件预览功能指南</a>。</p><h2 id="语言区域和国际化"><a href="#语言区域和国际化" class="headerlink" title="语言区域和国际化"></a>语言区域和国际化</h2><p>Android 7.0（API 级别 24）引入能指定默认类别语言区域的概念，但是某些 API 在本应使用默认 <code>DISPLAY</code> 类别语言区域时，仍然使用不带参数的通用 <code>Locale.getDefault()</code> 函数。现在，在 Android 8.0 中，以下函数使用 <code>Locale.getDefault(Category.DISPLAY)</code> 来代替 <code>Locale.getDefault()</code>：</p><ul><li><code>Currency.getDisplayName()</code></li><li><code>Currency.getSymbol()</code></li><li><code>Locale.getDisplayScript()</code></li></ul><p>当为 <code>Locale</code> 参数指定的 <code>displayScript</code> 值不可用时，<code>Locale.getDisplayScript(Locale)</code> 同样回退到 <code>Locale.getDefault()</code>。</p><p>与语言区域和国际化有关的其他变更如下：</p><ul><li>调用 <code>Currency.getDisplayName(null)</code> 会引发 <code>NullPointerException</code>，以与文档规定的行为保持一致。</li><li><p>时区名称的分析方法发生变化。之前，Android 设备使用在启动时取样的系统时钟值，缓存用于分析日期时间的时区名称。因此，如果在启动时或其他较为罕见的情况下系统时钟出错，可能对分析产生负面影响。<br>现在，一般情况下，在分析时区名称时分析逻辑将使用 ICU 和当前系统时钟值。此项变更可提供更加准确的结果，如果您的应用使用 <code>SimpleDateFormat</code> 等类，此结果可能与之前的 Android 版本不同。</p></li><li><p>Android 8.0 将 ICU 的版本更新至版本 58。</p></li></ul><h2 id="提醒窗口"><a href="#提醒窗口" class="headerlink" title="提醒窗口"></a>提醒窗口</h2><p>如果应用使用 <code>SYSTEM_ALERT_WINDOW</code> 权限并且尝试使用以下窗口类型之一来在其他应用和系统窗口上方显示提醒窗口：</p><ul><li><code>TYPE_PHONE</code></li><li><code>TYPE_PRIORITY_PHONE</code></li><li><code>TYPE_SYSTEM_ALERT</code></li><li><code>TYPE_SYSTEM_OVERLAY</code></li><li><code>TYPE_SYSTEM_ERROR</code></li></ul><p>…那么，这些窗口将始终显示在使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型的窗口下方。如果应用针对的是 Android 8.0，则应用会使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型来显示提醒窗口。</p><p>如需了解详细信息，请参阅针对 Android 8.0 的应用的行为变更内的<a href="https://developer.android.com/about/versions/oreo/android-8.0-changes.html#cwt" target="_blank" rel="noopener">提醒窗口的常用窗口类型</a>部分。</p><h2 id="输入和导航"><a href="#输入和导航" class="headerlink" title="输入和导航"></a>输入和导航</h2><p>随着 Android 应用出现在 Chrome 操作系统和平板电脑等其他大尺寸设备上，我们看到，用户在 Android 应用中又重新开始使用键盘导航。在 Android 8.0 中，我们又再次使用键盘作为导航输入设备，从而为基于箭头键和 Tab 键的导航构建了一种更可靠并且可预测的模型。</p><p>尤其要指出的是，我们对元素焦点行为做出以下变更：</p><ul><li><p>现在，如果您没有为 View 对象（前景或背景图片）定义任何焦点状态颜色，框架会为 View 设置默认的焦点突出显示颜色。此焦点突出显示标志是基于操作组件主题背景的涟漪图片。<br>如果您不希望 View 对象在接收焦点时使用此默认突出显示标志，请在包含 View 的布局 XML 文件中将 android:defaultFocusHighlightEnabled 属性设置为 false，或者将 false 传递至应用界面逻辑中的 setDefaultFocusHighlightEnabled()。</p></li><li><p>要测试键盘输入对界面元素焦点有何影响，您可以启用 <strong>Drawing &gt; Show layout bounds</strong> 开发者选项。在 Android 8.0 中，此选项在当前具有焦点的元素上显示一个“X”图标。</p></li></ul><p>另外，Android 8.0 中的所有工具栏元素自动组成<a href="https://developer.android.com/preview/api-overview.html#kbnc" target="_blank" rel="noopener">键盘导航键区</a>用户可以更加轻松地导航进入和离开每个作为一个整体的工具栏。</p><p>如需详细了解如何在您的应用中改善对键盘导航的支持，请阅读<a href="https://developer.android.com/training/keyboard-input/navigation.html" target="_blank" rel="noopener">支持键盘导航</a>南。</p><h2 id="网页表单自动填充"><a href="#网页表单自动填充" class="headerlink" title="网页表单自动填充"></a>网页表单自动填充</h2><p>现在，Android 自动填充框架提供对自动填充功能的内置支持，对于安装到运行 Android 8.0 的设备上的应用，与 WebView 对象相关的下列函数已经发生变化：</p><p><strong>WebSettings</strong></p><ul><li><code>getSaveFormData()</code> 函数现在返回 false。之前，此函数返回 true。</li><li>调用 <code>setSaveFormData()</code> 不再有任何效果。<br><strong>WebViewDatabase</strong></li><li>调用 <code>clearFormData()</code> 不再有任何效果。</li><li><code>hasFormData()</code> 函数现在返回 false。之前，当表单包含数据时，此函数返回 true。</li></ul><h2 id="无障碍功能"><a href="#无障碍功能" class="headerlink" title="无障碍功能"></a>无障碍功能</h2><p>现在，无障碍服务可识别应用的 <code>TextView</code> 对象内部的所有 <code>ClickableSpan</code> 实例。</p><p>如需了解有关如何让您的应用更便于访问的更多信息，请参阅<a href="https://developer.android.com/guide/topics/ui/accessibility/index.html" target="_blank" rel="noopener">无障碍功能</a>。</p><h2 id="网络连接和-HTTP-S-连接"><a href="#网络连接和-HTTP-S-连接" class="headerlink" title="网络连接和 HTTP(S) 连接"></a>网络连接和 HTTP(S) 连接</h2><p>Android 8.0 对网络连接和 HTTP(S) 连接行为做出了以下变更：</p><ul><li>无正文的 OPTIONS 请求具有 Content-Length: 0 标头。之前，这些请求没有 Content-Length 标头。</li><li>HttpURLConnection 在包含斜线的主机或颁发机构名称后面附加一条斜线，使包含空路径的网址规范化。例如，它将 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 转化为 <a href="http://example.com/。" target="_blank" rel="noopener">http://example.com/。</a></li><li>通过 ProxySelector.setDefault() 设置的自定义代理选择器仅针对所请求的网址（架构、主机和端口）。因此，仅可根据这些值选择代理。传递至自定义代理选择器的网址不包含所请求的网址的路径、查询参数或片段。</li><li><p>URI 不能包含空白标签。<br>之前，平台支持一种权宜方法，即允许主机名称中包含空白标签，但这是对 URI 的非法使用。此权宜方法只是为了确保与旧版 libcore 兼容。开发者如果对 API 使用不当，将会看到一条 ADB 消息：“URI example..com 的主机名包含空白标签。此格式不正确，将不被未来的 Android 版本所接受。”Android 8.0 废除了此权宜方法；系统对格式错误的 URI 会返回 null。</p></li><li><p>Android 8.0 在实现 HttpsURLConnection 时不会执行不安全的 TLS/SSL 协议版本回退。</p></li><li><p>对隧道 HTTP(S) 连接处理进行了如下变更：</p><ul><li>在通过连接建立隧道 HTTP(S) 连接时，系统会在 Host 行中正确放置端口号 (:443) 并将此信息发送至中间服务器。之前，端口号仅出现在 CONNECT 行中。</li><li>系统不再将隧道连接请求中的 user-agent 和 proxy-authorization 标头发送至代理服务器。<br>在建立隧道时，系统不再将隧道 Http(s)URLConnection 中的 proxy-authorization 标头发送至代理。相反，由系统生成 proxy-authorization 标头，在代理响应初始请求发送 HTTP 407 后将其发送至此代理。<br>同样地，系统不再将 user-agent 标头由隧道连接请求复制到建立隧道的代理请求。相反，库为此请求生成 user-agent 标头。</li></ul></li><li><p>如果之前执行的 connect() 函数失败，·send(java.net.DatagramPacket)· 函数将会引发 SocketException。</p><ul><li>如果存在内部错误，·DatagramSocket.connect()· 会引发 pendingSocketException。对于 Android 8.0 之前的版本，即使 send() 调用成功，后续的 recv() 调用也会引发 SocketException。为确保一致性，现在这两个调用均会引发 SocketException。</li></ul></li><li>在回退到 TCP Echo 协议之前，InetAddress.isReachable() 会尝试执行 ICMP。<ul><li>对于某些屏蔽端口 7 (TCP Echo) 的主机（例如 google.com），如果它们接受 ICMP Echo 协议，现在也许能够访问它们。</li><li>对于确实无法访问的主机，此项变更意味着调用需要两倍的时间才能返回结果。</li></ul></li></ul><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>Android 8.0 对 <code>ScanRecord.getBytes()</code> 函数检索的数据长度做出以下变更：</p><ul><li><code>getBytes()</code> 函数对于所接收的字节数不作任何假定。因此，应用不应受所返回的任何最小或最大字节数的影响。相反，应用应当计算所返回数组的长度。</li><li>兼容蓝牙 5 的设备返回的数据长度可能会超出之前最大约 60 个字节的限制。</li><li>如果远程设备未提供扫描响应，则也可能返回少于 60 个字节的数据。</li></ul><h2 id="无缝连接"><a href="#无缝连接" class="headerlink" title="无缝连接"></a>无缝连接</h2><p>Android 8.0 对 WLAN 设置进行了多项改进，这样可以更轻松地选择能够提供最佳用户体验的 WLAN 网络。具体变更包括：</p><ul><li>稳定性和可靠性改进。</li><li>更加直观的界面。</li><li>一个合并的 WLAN 首选项菜单。</li><li>当附近存在优质的已保存网络时在兼容设备上自动激活 WLAN。</li></ul><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>Android 8.0 包含以下与安全性有关的变更：</p><ul><li>此平台不再支持 SSLv3。</li><li>在与未正确实现 TLS 协议版本协商的服务器建立 HTTPS 连接时，<code>HttpsURLConnection</code> 不再尝试回退到之前的 TLS 协议版本并重试的权宜方法。</li><li>Android 8.0 将使用安全计算 (SECCOMP) 过滤器来过滤所有应用。允许的系统调用列表仅限于通过 bionic 公开的系统调用。此外，还提供了其他几个后向兼容的系统调用，但我们不建议使用这些系统调用。</li><li>现在，您的应用的 <code>WebView</code> 对象将在多进程模式下运行。网页内容在独立的进程中处理，此进程与包含应用的进程相隔离，以提高安全性。</li><li>您无法再假定 APK 驻留在名称以 -1 或 -2 结尾的目录中。应用应使用 <code>sourceDir</code> 获取此目录，而不能直接使用目录格式。</li><li>如需了解与使用原生库有关的安全性增强的信息，请参阅<a href="https://developer.android.com/about/versions/oreo/android-8.0-changes.html#nl" target="_blank" rel="noopener">原生库</a>。</li></ul><p>有关提升应用安全性的其他准则，请参阅<a href="https://developer.android.com/topic/security/index.html" target="_blank" rel="noopener">面向 Android 开发者的安全性</a>。</p><h2 id="隐私性"><a href="#隐私性" class="headerlink" title="隐私性"></a>隐私性</h2><p>Android 8.0 对平台做出了以下与隐私性有关的变更。</p><ul><li><p>现在，平台改变了标识符的处理方式。</p><ul><li>对于在 OTA 之前安装到某个版本 Android 8.0（API 级别 26）的应用，除非在 OTA 后卸载并重新安装，否则 <code>ANDROID_ID</code> 的值将保持不变。要在 OTA 后在卸载期间保留值，开发者可以使用<code>密钥/值备份</code>关联旧值和新值。</li><li>对于安装在运行 Android 8.0 的设备上的应用，<code>ANDROID_ID</code> 的值现在将根据应用签署密钥和用户确定作用域。应用签署密钥、用户和设备的每个组合都具有唯一的 <code>ANDROID_ID</code> 值。因此，在相同设备上运行但具有不同签署密钥的应用将不会再看到相同的 Android ID（即使对于同一用户来说，也是如此）。</li><li>只要签署密钥相同（并且应用未在 OTA 之前安装到某个版本的 O），<code>ANDROID_ID</code> 的值在软件包卸载或重新安装时就不会发生变化。</li><li>即使系统更新导致软件包签署密钥发生变化，<code>ANDROID_ID</code> 的值也不会变化。<br>要借助一个简单的标准系统实现应用获利，请使用广告 ID。广告 ID 是 Google Play 服务针对广告服务提供的唯一 ID，此 ID 可由用户重置。</li></ul></li><li><p>查询 net.hostname 系统属性返回的结果为空。</p></li></ul><h2 id="记录未捕获的异常"><a href="#记录未捕获的异常" class="headerlink" title="记录未捕获的异常"></a>记录未捕获的异常</h2><p>如果某个应用安装的 <code>Thread.UncaughtExceptionHandler</code> 未移交给默认的 <code>Thread.UncaughtExceptionHandler</code>，则当出现未捕获的异常时，系统不会终止应用。从 Android 8.0 开始，在此情况下系统将记录异常堆栈跟踪情况；在之前的平台版本中，系统不会记录异常堆栈跟踪情况。</p><p>我们建议，自定义 <code>Thread.UncaughtExceptionHandler</code> 实现始终移交给默认处理程序处理；遵循此建议的应用不受 Android 8.0 此项变更的影响。</p><h2 id="联系人提供程序使用情况统计方法的变更"><a href="#联系人提供程序使用情况统计方法的变更" class="headerlink" title="联系人提供程序使用情况统计方法的变更"></a>联系人提供程序使用情况统计方法的变更</h2><p>在之前版本的 Android 中，联系人提供程序组件允许开发者获取每个联系人的使用情况数据。此使用情况数据揭示了与某个联系人相关联的每个电子邮件地址和每个电话号码的信息，包括与该联系人联系的次数以及上次联系该联系人的时间。请求 <code>READ_CONTACTS</code> 权限的应用可以读取此数据。</p><p>如果应用请求 <code>READ_CONTACTS</code> 权限，它们仍可以读取此数据。从 Android 8.0 开始，使用情况数据查询会返回近似值，而不是精确值。不过，Android 系统内部仍然会保留精确值，因此，此变更不会影响 auto-complete API。</p><p>此行为变更会影响以下查询参数：</p><ul><li><code>TIMES_CONTACTED</code></li><li><code>TIMES_USED</code></li><li><code>LAST_TIME_CONTACTED</code></li><li><code>LAST_TIME_USED</code></li></ul><h2 id="集合的处理"><a href="#集合的处理" class="headerlink" title="集合的处理"></a>集合的处理</h2><p>现在，<code>AbstractCollection.removeAll()</code> 和 <code>AbstractCollection.retainAll()</code> 始终引发 <code>NullPointerException</code>；之前，当集合为空时不会引发 <code>NullPointerException</code>。此项变更使行为符合文档要求。</p><h2 id="Android-企业版"><a href="#Android-企业版" class="headerlink" title="Android 企业版"></a>Android 企业版</h2><p>Android 8.0 更改了企业应用（包括设备规范控制器 (DPC)）的某些 API 和功能的行为。这些变更包括：</p><ul><li>新增多种行为，帮助应用支持完全托管设备中的工作资料。</li><li>变更系统更新处理、应用验证和身份验证方式，以提高设备和系统的完整性。</li><li>改进用户在配置、通知、“最近使用的应用”屏幕和 Always on VPN 方面的体验。</li></ul><p>如需查看 Android 8.0 中的所有企业版变更和了解它们可能给您的应用带来的影响，请阅读企业中的 Android。</p><h1 id="针对-Android-8-0-的应用"><a href="#针对-Android-8-0-的应用" class="headerlink" title="针对 Android 8.0 的应用"></a>针对 Android 8.0 的应用</h1><hr><p>这些行为变更专门应用于针对 O 平台或更高平台版本的应用。针对 Android 8.0 或更高平台版本进行编译，或将 targetSdkVersion 设为 Android 8.0 或更高版本的应用开发者必须修改其应用以正确支持这些行为（如果适用）。</p><h2 id="提醒窗口-1"><a href="#提醒窗口-1" class="headerlink" title="提醒窗口"></a>提醒窗口</h2><p>使用 <code>SYSTEM_ALERT_WINDOW</code> 权限的应用无法再使用以下窗口类型来在其他应用和系统窗口上方显示提醒窗口：</p><ul><li><code>TYPE_PHONE</code></li><li><code>TYPE_PRIORITY_PHONE</code></li><li><code>TYPE_SYSTEM_ALERT</code></li><li><code>TYPE_SYSTEM_OVERLAY</code></li><li><code>TYPE_SYSTEM_ERROR</code></li></ul><p>相反，应用必须使用名为 <code>TYPE_APPLICATION_OVERLAY</code> 的新窗口类型。</p><p>使用 <code>TYPE_APPLICATION_OVERLAY</code> 窗口类型显示应用的提醒窗口时，请记住新窗口类型的以下特性：</p><ul><li>应用的提醒窗口始终显示在状态栏和输入法等关键系统窗口的下面。</li><li>系统可以移动使用 TYPE_APPLICATION_OVERLAY 窗口类型的窗口或调整其大小，以改善屏幕显示效果。</li><li>通过打开通知栏，用户可以访问设置来阻止应用显示使用 TYPE_APPLICATION_OVERLAY 窗口类型显示的提醒窗口。</li></ul><h2 id="内容变更通知"><a href="#内容变更通知" class="headerlink" title="内容变更通知"></a>内容变更通知</h2><p>Android 8.0 更改了 <code>ContentResolver.notifyChange()</code> 和 <code>registerContentObserver(Uri, boolean, ContentObserver)</code> 在针对 Android 8.0 的应用中的行为方式。</p><p>现在，这些 API 需要在所有 URI 中为颁发机构定义一个有效的 <code>ContentProvider</code>。使用相关权限定义一个有效的 <code>ContentProvider</code> 可帮助您的应用防范来自恶意应用的内容变更，并防止将可能的私密数据泄露给恶意应用。</p><h2 id="视图焦点"><a href="#视图焦点" class="headerlink" title="视图焦点"></a>视图焦点</h2><p>可点击的 View 对象现在默认也可以成为焦点。如果您希望 View 对象可点击但不可成为焦点，请在包含 View 的布局 XML 文件中将 <code>android:focusable</code> 属性设置为 false，或者将 false 传递至应用界面逻辑中的 <code>setFocusable()</code>。</p><h2 id="安全性-1"><a href="#安全性-1" class="headerlink" title="安全性"></a>安全性</h2><p>如果您的应用的网络安全性配置选择退出对明文流量的支持，那么您的应用的 <code>WebView</code> 对象无法通过 HTTP 访问网站。每个 <code>WebView</code> 对象必须转而使用 HTTPS。</p><p>有关提升应用安全性的其他准则，请参阅<a href="https://developer.android.com/topic/security/index.html" target="_blank" rel="noopener">面向 Android 开发者的安全性</a>。</p><h2 id="帐号访问和可检测性"><a href="#帐号访问和可检测性" class="headerlink" title="帐号访问和可检测性"></a>帐号访问和可检测性</h2><p>除非身份验证器拥有用户帐号或用户授予访问权限，否则，应用将无法再访问用户帐号。仅拥有 <code>GET_ACCOUNTS</code> 权限尚不足以访问用户帐号。要获得帐号访问权限，应用应使用 <code>AccountManager.newChooseAccountIntent()</code> 或特定于身份验证器的函数。获得帐号访问权限后，应用可以调用 <code>AccountManager.getAccounts()</code> 来访问帐号。</p><p>Android 8.0 已弃用 <code>LOGIN_ACCOUNTS_CHANGED_ACTION</code>。相反，应用在运行时应使用 <code>addOnAccountsUpdatedListener()</code> 获取帐号更新信息。</p><p>有关新增 API 和增加的帐号访问和可检测性函数的信息，请参阅此文档的“新增 API”部分中的帐号访问和可检测性。</p><h2 id="隐私性-1"><a href="#隐私性-1" class="headerlink" title="隐私性"></a>隐私性</h2><p>以下变更影响 Android 8.0 的隐私性。</p><ul><li>系统属性 net.dns1、net.dns2、net.dns3 和 net.dns4 不再可用，此项变更可加强平台的隐私性。</li><li>要获取 DNS 服务器之类的网络连接信息，具有 <code>ACCESS_NETWORK_STATE</code> 权限的应用可以注册 <code>NetworkRequest</code> 或 <code>NetworkCallback</code> 对象。这些类在 Android 5.0（API 级别 21）及更高版本中提供。</li><li>Build.SERIAL 已弃用。需要知道硬件序列号的应用应改为使用新的 <code>Build.getSerial()</code> 函数，该函数要求具有 <code>READ_PHONE_STATE</code> 权限。</li><li><code>LauncherApps</code> API 不再允许工作资料应用获取有关主个人资料的信息。当某个用户在托管配置文件中时，<code>LauncherApps</code> API 的行为就像同一配置文件组的其他配置文件中未安装任何应用一样。和之前一样，尝试访问无关联的个人资料会引发 SecurityExceptions。</li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>在 Android 8.0 之前，如果应用在运行时请求权限并且被授予该权限，系统会错误地将属于同一权限组并且在清单中注册的其他权限也一起授予应用。</p><p>对于针对 Android 8.0 的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而，一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p><p>例如，假设某个应用在其清单中列出 <code>READ_EXTERNAL_STORAGE</code> 和 <code>WRITE_EXTERNAL_STORAGE</code>。应用请求 <code>READ_EXTERNAL_STORAGE</code>，并且用户授予了该权限。如果该应用针对的是 API 级别 24 或更低级别，系统还会同时授予 <code>WRITE_EXTERNAL_STORAGE</code>，因为该权限也属于同一 STORAGE 权限组并且也在清单中注册过。如果该应用针对的是 Android 8.0，则系统此时仅会授予 <code>READ_EXTERNAL_STORAGE</code>；不过，如果该应用后来又请求 <code>WRITE_EXTERNAL_STORAGE</code>，则系统会立即授予该权限，而不会提示用户。</p><h2 id="媒体"><a href="#媒体" class="headerlink" title="媒体"></a>媒体</h2><ul><li>框架会执行音频闪避。进行 <code>AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</code> 时，应用不会失去焦点。新的 API 适用于需要暂停而不是闪避的应用。请注意，此行为无法在 Android 8.0 1 版本中实现。</li><li>当用户打电话时，活动的媒体流将在通话期间静音。</li><li>所有与音频相关的 API 都应使用 <code>AudioAttributes</code> 而不是音频流类型来说明音频播放用例。仅为音量控制继续使用音频流类型。流类型（例如，已弃用的 <code>AudioTrack constructor</code>）的其他用途仍然有效，但是系统会将其记录为错误。</li><li>使用 <code>AudioTrack</code> 时，如果应用请求了足够大的音频缓冲区，则框架将尝试使用深度缓冲区输出（如果可用）。</li><li>在 Android 8.0 中，媒体按钮事件的处理有所不同：<ol><li>在界面操作组件中处理媒体按钮未发生变化：前台操作组件在处理媒体按钮时仍然优先。</li><li>如果前台操作组件不处理媒体按钮，系统会将媒体按钮路由到最近在本地播放音频的应用。在确定哪些应用接收媒体按钮事件时，不再考虑活动状态、标志和媒体会话的播放状态。即使在应用调用 <code>setActive(false)</code> 后，媒体会话仍然可以接收媒体按钮事件。</li><li>如果应用的媒体会话已经释放，系统会将媒体按钮事件发送到应用的 <code>MediaButtonReceiver</code>（如果有）。</li><li>对于任何其他情况，系统都会舍弃媒体按钮事件。与其开始播放错误的应用，不如不播放任何东西。</li></ol></li></ul><h2 id="原生库"><a href="#原生库" class="headerlink" title="原生库"></a>原生库</h2><p>在针对 Android 8.0 的应用中，如果原生库包含任何可写且可执行的加载代码段，则不会再加载原生库。倘若某些应用的原生库包含不正确的加载代码段，则此变更可能会导致这些应用停止工作。这是一种安全加强措施。</p><p>如需了解详细信息，请参阅<a href="https://android.googlesource.com/platform/bionic/+/master/android-changes-for-ndk-developers.md#Writable-and-Executable-Segments-Enforced-for-API-level-26" target="_blank" rel="noopener">可写且可执行的代码段</a>。</p><p>与早期的开发者预览版相同，Android 8.0 还有助于更轻松地发现所有与链接器有关的问题。链接器的变更绑定到应用的目标 API 级别。如果应用的目标 API 级别发生链接器变更，则该应用无法加载该库。如果您的目标 API 级别低于发生链接器变更的 API 级别，则 logcat 会显示一条警告消息。在预览版期间，与链接器有关的问题不仅会显示在 logcat 中，也会以 toast 的形式显示。对于特定的 API 级别，警告可能会变成错误，此变更有助于提前发现此类问题。</p><h2 id="集合的处理-1"><a href="#集合的处理-1" class="headerlink" title="集合的处理"></a>集合的处理</h2><p>在 Android 8.0 中，<code>Collections.sort()</code> 是在 <code>List.sort()</code> 的基础上实现的。在 Android 7.x（API 级别 24 和 25）中，则恰恰相反。在过去，<code>List.sort()</code> 的默认实现会调用 <code>Collections.sort()</code>。</p><p>此项变更使 <code>Collections.sort()</code> 可以利用优化的 <code>List.sort()</code> 实现，但具有以下限制：</p><ul><li><code>List.sort()</code> 的实现不能调用 <code>Collections.sort()</code>，因为这会导致堆栈因无限递归而溢出。相反，如果您需要 List 实现的默认行为，应避免重写 sort()。<br>如果父类以不适当的方法实现 sort() ，通常最好使用在 <code>List.toArray()</code>、<code>Arrays.sort()</code> 和 <code>ListIterator.set()</code> 的基础上构建的实现重写 <code>List.sort()</code>。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">  Object[] elements = toArray();</span><br><span class="line">  Arrays.sort(elements, c);</span><br><span class="line">  ListIterator&lt;E&gt; iterator = (ListIterator&lt;Object&gt;) listIterator();</span><br><span class="line">  <span class="keyword">for</span> (Object element : elements) &#123;</span><br><span class="line">    iterator.next();</span><br><span class="line">    iterator.set((E) element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在大多数情况下，您也可以使用根据 API 级别委托给其他默认实现的实现重写 <code>List.sort()</code>。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">    Collections.sort(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.sort(comparator);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果您选择后者只是因为您希望开发一种适用于所有 API 级别的 sort() 函数，可以考虑赋予其一个唯一的名称，例如 sortCompat()，而不是重写 sort()。</p><ul><li><code>现在，Collections.sort()</code> 只是对调用 sort() 的 List 实现进行的一项结构性修改。例如，在 Android 8.0 之前的平台版本中，如果通过调用 <code>List.sort()</code> 进行排序，则当迭代处理 ArrayList 以及在迭代过程中调用 <code>sort()</code> 时，会引发 <code>ConcurrentModificationException</code>。而 <code>Collections.sort()</code> 则不会引发异常。</li></ul><p>此项变更使平台行为更加一致：现在，两种方法都会引发 <code>ConcurrentModificationException</code>。</p><h2 id="类加载行为"><a href="#类加载行为" class="headerlink" title="类加载行为"></a>类加载行为</h2><p>Android 8.0 检查确保类加载器在加载新类时不会违反运行时假设条件。不论类引用自 Java（来自 <code>forName()</code>）、Dalvik 字节码还是 JNI，都会执行这些检查。平台不会拦截 Java 对 <code>loadClass()</code> 函数的直接调用，也不会检查此类调用的结果。此行为不应影响运行良好的类加载器的正常运行。</p><p>平台将检查类加载器返回的类描述符是否与预期的描述符一致。如果返回的描述符与预期不符，平台会引发 <code>NoClassDefFoundError</code> 错误，并在异常日志中存储一条注明不一致之处的详细错误消息。</p><p>平台还检查请求的类描述符是否有效。此检查捕获间接加载诸如 <code>GetFieldID()</code> 等类的 JNI 调用，向这些类传递无效的描述符。例如，找不到包含 java/lang/String 签名的字段，是因为此签名无效；它应为 Ljava/lang/String;。</p><p>这与 JNI 对 <code>FindClass()</code> 的调用不同，其中 java/lang/String 是一个有效的完全限定名称。</p><p>Android 8.0 不支持多个类加载器同时尝试使用相同的 DexFile 对象来定义类。尝试进行此操作，会导致 Android 运行时引发 InternalError 错误，同时显示消息“Attempt to register dex file <filename> with multiple class loaders”。</filename></p><p>DexFile API 现已弃用，强烈建议您改为使用此平台的类加载器之一，包括 PathClassLoader 或 BaseDexClassLoader。</p><blockquote><p><strong>注：</strong> 您可以创建多个引用文件系统中同一个 APK 或 JAR 文件容器的类加载器。这样做通常不会占用大量内存：如果存储而不压缩容器中的 DEX 文件，平台可以对此类文件执行 mmap 操作，而不直接提取它们。但是，如果平台必须从容器中提取 DEX 文件，以这种方式引用 DEX 文件可能占用大量内存。</p></blockquote><p>在 Android 中，所有类加载器都被视为支持并行运行。当多个线程争用同一个类加载器加载相同的类时，第一个完成此操作的线程胜出，而操作结果将用于其他线程。无论类加载器是返回同一个类、返回不同的类还是引发异常，都将发生此行为。该平台静默忽略此类异常。</p><blockquote><p><strong>注意：</strong> 在低于 Android 8.0 的平台版本中，违反这些假设条件可能导致多次定义同一个类、由于类混淆造成堆损坏和其他不良影响。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 8.0 除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。&lt;/p&gt;
&lt;p&gt;其中大部分变更会影响所有应用，而不论应用针对的是何种版本的 Android。不过，有几项变更仅影响针对 A
      
    
    </summary>
    
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Oreo" scheme="http://yoursite.com/tags/Oreo/"/>
    
      <category term="Android8.0" scheme="http://yoursite.com/tags/Android8-0/"/>
    
  </entry>
  
  <entry>
    <title>Android 8.0 功能和 API</title>
    <link href="http://yoursite.com/2017/08/29/android-8-0/"/>
    <id>http://yoursite.com/2017/08/29/android-8-0/</id>
    <published>2017-08-29T11:47:18.000Z</published>
    <updated>2018-03-30T06:23:59.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h1><hr><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p><img src="/2017/08/29/android-8-0/notification-long-press.png" alt="Drawing" style="width: 200px;float:right"><br>在 Android 8.0 中，我们已重新设计通知，以便为管理通知行为和设置提供更轻松和更统一的方式。这些变更包括：<br>-<strong>通知渠道</strong>：Android 8.0 引入了通知渠道，其允许您为要显示的每种通知类型创建用户可自定义的渠道。用户界面将通知渠道称之为通知类别。要了解如何实现通知渠道的信息，请参阅<a href="https://developer.android.com/preview/features/notification-channels.html" target="_blank" rel="noopener">通知渠道</a>指南。<br>-<strong>通知标志</strong>：Android 8.0 引入了对在应用启动器图标上显示通知标志的支持。通知标志可反映某个应用是否存在与其关联、并且用户尚未予以清除也未对其采取行动的通知。通知标志也称为通知点。要了解如何调整通知标志，请参阅<a href="https://developer.android.com/preview/features/notification-badges.html" target="_blank" rel="noopener">通知标志</a>指南。<br>-<strong>休眠</strong>：用户可以将通知置于休眠状态，以便稍后重新显示它。重新显示时通知的重要程度与首次显示时相同。应用可以移除或更新已休眠的通知，但更新休眠的通知并不会使其重新显示。<br>-<strong>通知超时</strong>：现在，使用 <code>setTimeoutAfter()</code>创建通知时您可以设置超时。您可以使用此函数指定一个持续时间，超过该持续时间后，通知应取消。如果需要，您可以在指定的超时持续时间之前取消通知。<br>-<strong>通知设置</strong>：当您使用 <code>Notification.INTENT_CATEGORY_NOTIFICATION_PREFERENCESIntent</code> 从通知创建指向应用通知设置的链接时，您可以调用 <code>setSettingsText()</code> 来设置要显示的文本。此系统可以提供以下 <code>Extra</code> 数据和 <code>Intent</code>，用于过滤应用必须向用户显示的设置：<code>EXTRA_CHANNEL_ID</code>、<code>NOTIFICATION_TAG 和 NOTIFICATION_ID</code>。<br>-<strong>通知清除</strong>：系统现在可区分通知是由用户清除，还是由应用移除。要查看清除通知的方式，您应实现 <code>NotificationListenerService</code> 类的新 <code>onNotificationRemoved()</code> 函数。<br>-<strong>背景颜色</strong>：您现在可以设置和启用通知的背景颜色。只能在用户必须一眼就能看到的持续任务的通知中使用此功能。例如，您可以为与驾车路线或正在进行的通话有关的通知设置背景颜色。您还可以使用 <code>Notification.Builder.setColor()</code> 设置所需的背景颜色。这样做将允许您使用 <code>Notification.Builder.setColorized()</code> 启用通知的背景颜色设置。<br>-<strong>消息样式</strong>：现在，使用 <code>MessagingStyle</code> 类的通知可在其折叠形式中显示更多内容。对于与消息有关的通知，您应使用 <code>MessagingStyle</code> 类。您还可以使用新的 <code>addHistoricMessage()</code> 函数，通过向与消息相关的通知添加历史消息为会话提供上下文。</p><h2 id="自动填充框架"><a href="#自动填充框架" class="headerlink" title="自动填充框架"></a>自动填充框架</h2><p>帐号创建、登录和信用卡交易需要时间并且容易出错。在使用要求执行此类重复性任务的应用时，用户很容易遭受挫折。<br>Android 8.0 通过引入自动填充框架，简化了登录和信用卡表单之类表单的填写工作。在用户选择接受自动填充之后，新老应用都可使用自动填充框架。<br>您可以采取某些措施，优化您的应用使用此框架的方式。如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/autofill.html" target="_blank" rel="noopener">自动填充框架概览</a>。</p><h2 id="画中画模式"><a href="#画中画模式" class="headerlink" title="画中画模式"></a>画中画模式</h2><p>Android 8.0 允许以画中画 (PIP) 模式启动操作组件。PIP 是一种特殊的多窗口模式，最常用于视频播放。目前，PIP 模式可用于 Android TV，而 Android 8.0 则让该功能可进一步用于其他 Android 设备。<br>当某个 Activity 处于 PIP 模式时，它会处于暂停状态，但仍应继续显示内容。因此，您应确保您的应用在 <code>onPause()</code> 处理程序中进行处理时不会暂停播放。相反，您应在 onStop() 中暂停播放视频，并在 <code>onStart()</code> 中继续播放。如需了解详细信息，请参阅<a href="https://developer.android.com/guide/topics/ui/multi-window.html#lifecycle" target="_blank" rel="noopener">多窗口生命周期</a>。<br>要指定您的 Activity 可以使用 PIP 模式，请在清单中将 android:supportsPictureInPicture 设置为 true。（从 Android 8.0 开始，如果您打算在 Android TV 或其他 Android 设备上支持 PIP 模式，则无需将 android:resizeableActivity 设置为 true；只有在您的 Activity 支持其他多窗口模式时，才需要设置 android:resizeableActivity。）</p><h2 id="API-变更"><a href="#API-变更" class="headerlink" title="API 变更"></a>API 变更</h2><p>Android 8.0 引入一种新的对象 PictureInPictureParams，您可以将该对象传递给 PIP 函数来指定某个 Activity 在其处于 PIP 模式时的行为。此对象还指定了各种属性，例如操作组件的首选纵横比。</p><p>现在，在添加画中画中介绍的现有 PIP 函数可用于所有 Android 设备，而不仅限于 Android TV。此外，Android 8.0 还提供以下函数来支持 PIP 模式：</p><ul><li><p><strong>Activity.enterPictureInPictureMode(PictureInPictureParams args)</strong>：将操作组件置于画中画模式。操作组件的纵横比和其他配置设置均由 <code>args</code> 指定。如果 <code>args</code> 中的任何字段为空，系统将使用您上次调用 <code>Activity.setPictureInPictureParams()</code> 时所设置的值。<br>指定的操作组件被置于屏幕的一角，屏幕剩余部分则被屏幕显示的上一个操作组件填满。进入 PIP 模式的 Activity 将进入暂停状态，但仍保持已启动状态。如果用户点按此 PIP 操作组件，系统将显示一个菜单供用户操作，而在操作组件处于 PIP 状态期间，不会理会任何触摸事件。</p></li><li><p><strong>Activity.setPictureInPictureParams()</strong>：更新操作组件的 PIP 配置设置。如果操作组件目前处于 PIP 模式，则会更新此设置；如果操作组件的纵横比发生变化，这非常有用。如果操作组件不处于 PIP 模式，则会使用这些配置设置，而不会考虑您调用的 <code>enterPictureInPictureMode()</code> 函数。</p></li></ul><h2 id="可下载字体"><a href="#可下载字体" class="headerlink" title="可下载字体"></a>可下载字体</h2><p>Android 8.0 和 Android 支持库 26 允许您从提供程序应用请求字体，而无需将字体绑定到 APK 中或让 APK 下载字体。此功能可减小 APK 大小，提高应用安装成功率，使多个应用可以共享同一种字体。</p><p>如需了解有关下载字体的详细信息，请参阅 <a href="https://developer.android.com/preview/features/downloadable-fonts.html" target="_blank" rel="noopener">可下载字体</a>。</p><h2 id="XML-中的字体"><a href="#XML-中的字体" class="headerlink" title="XML 中的字体"></a>XML 中的字体</h2><p>Android 8.0 推出一项新功能，即 XML 中的字体，允许您使用字体作为资源。这意味着，不再需要以资产的形式捆绑字体。字体在 R 文件中编译，并且作为一种资源，可自动用于系统。然后，您可以利用一种新的资源类型 font 来访问这些字体。</p><p>在运行 API 版本 14 及更高版本的设备中，支持库 26 对此功能提供完全支持。</p><p>如需了解有关以资源形式使用字体以及检索系统字体有关的详细信息，请参阅 <a href="https://developer.android.com/preview/features/fonts-in-xml.html" target="_blank" rel="noopener">XML 中的字体</a>。</p><h2 id="自动调整-TextView-的大小"><a href="#自动调整-TextView-的大小" class="headerlink" title="自动调整 TextView 的大小"></a>自动调整 TextView 的大小</h2><p>Android 8.0 允许您根据 TextView 的大小自动设置文本展开或收缩的大小。这意味着，在不同屏幕上优化文本大小或者优化包含动态内容的文本大小比以往简单多了。如需了解有关如何在 Android 8.0 中自动调整 TextView 的大小的详细信息，请参阅<a href="https://developer.android.com/preview/features/autosizing-textview.html" target="_blank" rel="noopener">自动调整 TextView 的大小</a>。</p><h2 id="自适应图标"><a href="#自适应图标" class="headerlink" title="自适应图标"></a>自适应图标</h2><p>Android 8.0 引入自适应启动器图标。自适应图标支持视觉效果，可在不同设备型号上显示为各种不同的形状。要了解如何创建自适应图标，请参阅<a href="https://developer.android.com/preview/features/adaptive-icons.html" target="_blank" rel="noopener">自适应图标预览功能指南</a>。</p><h2 id="颜色管理"><a href="#颜色管理" class="headerlink" title="颜色管理"></a>颜色管理</h2><p>图像应用的 Android 开发者现在可以利用支持广色域彩色显示的新设备。要显示广色域图像，应用需要在其清单（每个操作组件）中启用一个标志，并加载具有嵌入的广域彩色配置文件（AdobeRGB、Pro Photo RGB、DCI-P3 等）的位图。</p><h2 id="WebView-API"><a href="#WebView-API" class="headerlink" title="WebView API"></a>WebView API</h2><p>Android 8.0 提供多种 API，帮助您管理在应用中显示网页内容的 <code>WebView</code> 对象。这些 API 可增强应用的稳定性和安全性，它们包括：</p><ul><li>Version API</li><li>Google SafeBrowsing API</li><li>Termination Handle API</li><li>Renderer Importance API<br>要详细了解如何这些 API，请参阅<a href="https://developer.android.com/preview/features/managing-webview.html" target="_blank" rel="noopener">管理 WebView</a>。</li></ul><h2 id="固定快捷方式和小部件"><a href="#固定快捷方式和小部件" class="headerlink" title="固定快捷方式和小部件"></a>固定快捷方式和小部件</h2><p>Android 8.0 引入了快捷方式和微件的应用内固定功能。在您的应用中，您可以根据用户权限为支持的启动器创建固定的快捷方式和小部件。</p><p>如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/pinning-shortcuts-widgets.html" target="_blank" rel="noopener">固定快捷方式和微件</a>预览功能指南。</p><p>##最大屏幕纵横比<br>以 Android 7.1（API 级别 25）或更低版本为目标平台的应用默认的最大屏幕纵横比为 1.86。针对 Android 8.0 或更高版本的应用没有默认的最大纵横比。如果您的应用需要设置最大纵横比，请使用定义您的操作组件的清单文件中的 <code>maxAspectRatio</code> 属性。</p><h2 id="多显示器支持"><a href="#多显示器支持" class="headerlink" title="多显示器支持"></a>多显示器支持</h2><p>从 Android 8.0 开始，此平台为多显示器提供增强的支持。如果 Activity 支持多窗口模式，并且在具有多显示器的设备上运行，则用户可以将 Activity 从一个显示器移动到另一个显示器。当应用启动 Activity 时，此应用可指定 Activity 应在哪个显示器上运行。</p><blockquote><p><strong>注</strong>：如果 Activity 支持多窗口模式，则 Android 8.0 将为该 Activity 自动启用多显示器支持。您应测试您的应用，确保它在多显示器环境下可正常运行。<br>每次只有一个 Activity 可以处于继续状态，即使此应用具有多个显示器。具有焦点的 Activity 将处于继续状态，所有其他可见的 Activity 均暂停，但不会停止。如需了解有关当多个 Activity 可见时活动生命周期的详细信息，请参阅<a href="https://developer.android.com/guide/topics/ui/multi-window.html#lifecycle" target="_blank" rel="noopener">多窗口生命周期</a>。</p></blockquote><p>当用户将 Activity 从一个显示器移动到另一个显示器时，系统将调整 Activity 大小，并根据需要发起运行时变更。您的 Activity 可以自行处理配置变更，或允许系统销毁包含该 Activity 的进程，并以新的尺寸重新创建它。如需了解详细信息，请参阅<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理配置变更</a>。<br><strong>setLaunchDisplayId()</strong><br>&emsp;&emsp;指定 Activity 在启动后应显示在哪个显示器上。<br><strong>getLaunchDisplayId()</strong><br>&emsp;&emsp;返回操作组件的当前启动显示器。<br>对 adb shell 进行了扩展，以支持多个显示器。shell start 命令现在可用于启动操作组件，并指定操作组件的目标显示器：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell start &lt;activity_name&gt; --display &lt;display_id&gt;</span><br></pre></td></tr></table></figure></p><h2 id="统一的布局外边距和内边距"><a href="#统一的布局外边距和内边距" class="headerlink" title="统一的布局外边距和内边距"></a>统一的布局外边距和内边距</h2><p>Android 8.0 让您可以更轻松地指定 View 元素的对边使用相同外边距和内边距的情形。具体来说，您现在可以在布局 XML 文件中使用以下属性：<br>-<strong>layout_marginVertical</strong>，同时定义 <code>layout_marginTop</code> 和 <code>layout_marginBottom</code>。<br>-<strong>layout_marginHorizontal</strong>，同时定义 <code>layout_marginLeft</code> 和 <code>layout_marginRight</code>。<br>-<strong>paddingVertical</strong>，同时定义 <code>paddingTop</code> 和 <code>paddingBottom</code>。<br>-<strong>paddingHorizontal</strong>，同时定义 <code>paddingLeft</code> 和 <code>paddingRight</code>。</p><blockquote><p><strong>注</strong>：如果您自定义应用逻辑以支持不同语言和文化（包括文本方向），请记住，这些属性不会影响 <code>layout_marginStart</code>、<code>layout_marginEnd</code>、<code>paddingStart</code> 或 <code>paddingEnd</code> 的值。您可以自行设置这些值和新的垂直与水平布局属性来创建取决于文本方向的布局行为。</p></blockquote><h2 id="指针捕获"><a href="#指针捕获" class="headerlink" title="指针捕获"></a>指针捕获</h2><p>某些应用（例如游戏、远程桌面和虚拟化客户端）将大大受益于鼠标指针控制。指针捕获是 Android 8.0 中的一项新功能，可以通过将所有鼠标事件传递到您的应用中焦点视图的方式提供此类控制。</p><p>从 Android 8.0 开始，您的应用中的 View 可以请求指针捕获并定义一个侦听器来处理捕获的指针事件。鼠标指针在此模式下将隐藏。如果不再需要鼠标信息，该视图可以释放指针捕获。系统也可以在视图丢失焦点时（例如，当用户打开另一个应用时）释放指针捕获。</p><p>如需了解有关如何在您的应用中使用此功能的信息，请参<a href="https://developer.android.com/preview/features/pointer-capture.html" target="_blank" rel="noopener">阅指针捕获</a>。</p><h2 id="应用类别"><a href="#应用类别" class="headerlink" title="应用类别"></a>应用类别</h2><p>在适当的情况下，Android 8.0 允许每个应用声明其所属的类别。这些类别用于将应用呈现给用户的用途或功能类似的应用归类在一起，例如按流量消耗、电池消耗和存储消耗将应用归类。您可以在 <application> 清单标记中设置 android:appCategory 属性，定义应用的类别。</application></p><h2 id="Android-TV-启动器"><a href="#Android-TV-启动器" class="headerlink" title="Android TV 启动器"></a>Android TV 启动器</h2><p>Android 8.0 添加了一种以内容为中心的全新 Android TV 主屏幕体验，支持 Android TV 模拟器和 Nexus Player Android 8.0 设备映像。新的主屏幕在对应于频道的行中组织视频内容，这些频道在系统上通过应用填充各个节目。应用可以发布多个频道，用户可以配置他们希望在主屏幕上看到哪些频道。Android TV 也包含一个 Watch Next 行，此行根据用户的观看习惯从应用填充节目。应用也可以提供视频预览，这些预览会在用户聚焦到节目时自动播放。用于填充频道和节目的 API 属于 TvProvider API，这些 API 以 Android 支持库模块的形式随 Android 8.0 分发。</p><h2 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a>AnimatorSet</h2><p>从 Android 8.0 开始，AnimatorSet API 现在支持寻道和倒播功能。寻道功能允许您将动画的位置设置为指定的时间点处。如果您的应用包含可撤消的操作的动画，倒播功能会很有用。现在，您不必定义两组独立的动画，而只需反向播放同一组动画。</p><h2 id="输入和导航"><a href="#输入和导航" class="headerlink" title="输入和导航"></a>输入和导航</h2><h3 id="键盘导航键区"><a href="#键盘导航键区" class="headerlink" title="键盘导航键区"></a>键盘导航键区</h3><p>如果您的应用中，某个操作组件使用一种复杂的视图层次结构，可考虑将多组界面元素组成一个键区，简化键盘导航这些元素的操作。用户可以在 Chromebook 设备上按 Meta+Tab 或 Search+Tab，在不同键区之间导航。键区的一些范例包括：侧面板、导航栏、主内容区域和可能包含多个子元素的元素。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/08/29/android-8-0/keyboard-navigation-clusters.png" alt="包含 5 个键区的操作组件" title="">                </div>                <div class="image-caption">包含 5 个键区的操作组件</div>            </figure><br>要将一个 <code>View</code> 或 <code>ViewGroup</code> 元素设置为一个键区，请在元素的布局 XML 文件中将 <code>android:keyboardNavigationCluster</code> 属性设置为 true，或者将 true 传递至应用界面逻辑中的 <code>setKeyboardNavigationCluster()</code>。</p><blockquote><p><strong>注</strong>：键区不能嵌套，不过，非嵌套键区可以显示在层次结构的不同层级。如果您尝试嵌套键区，框架仅会将最顶层的 ViewGroup 元素视为键区。</p></blockquote><p>在具有触摸屏的设备中，您可以将某个键区指定的 ViewGroup 对象的 <code>android:touchscreenBlocksFocus</code> 元素设置为 true，仅允许从键区导航进入和离开此键区。如果您将此配置应用于某个键区，用户将无法使用 Tab 键或箭头键导航进入或离开此键区，而是必须按键区导航键盘组合键</p><h3 id="视图默认焦点"><a href="#视图默认焦点" class="headerlink" title="视图默认焦点"></a>视图默认焦点</h3><p>在 Android 8.0 中，您可以指定在（重新）创建的操作组件继续运行并且用户按下键盘导航键（例如 Tab 键）之后应接收焦点的 View。要应用“设为默认焦点”设置，请在包含界面元素的布局 XML 文件中将 View 元素的 <code>android:focusedByDefault</code> 属性设置为 true，或者将 true 传递至应用界面逻辑中的 <code>setFocusedByDefault()</code>。</p><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><hr><h2 id="新的-StrictMode-检测程序"><a href="#新的-StrictMode-检测程序" class="headerlink" title="新的 StrictMode 检测程序"></a>新的 StrictMode 检测程序</h2><p>Android 8.0 添加了三个新的 StrictMode 检测程序，帮助识别应用可能出现的错误：</p><ul><li><code>detectUnbufferedIo()</code> 将检测您的应用何时读取或写入未缓冲的数据，这可能极大影响性能。</li><li><code>detectContentUriWithoutPermission()</code> 将检测您的应用在其外部启动 Activity 时何时意外忘记向其他应用授予权限。</li><li><code>detectUntaggedSockets()</code> 将检测您的应用何时使用网络流量，而不使用 setThreadStatsTag(int) 将流量标记用于调试目的。</li></ul><h2 id="缓存数据"><a href="#缓存数据" class="headerlink" title="缓存数据"></a>缓存数据</h2><p>Android 8.0 优化了缓存数据的导航和行为。现在，每个应用均获得一定的磁盘空间配额，用于存储 <code>getCacheQuotaBytes(UUID)</code> 返回的缓存数据。</p><p>当系统需要释放磁盘空间时，将开始从超过配额最多的应用中删除缓存文件。因此，如果将您的缓存数据量始终保持低于配额的水平，则在必须清除系统中的某些文件时，您的缓存文件将能坚持到最后。系统在决定删除您的应用中的哪些缓存文件时，将首先考虑删除最旧的文件（由修改时间确定）。</p><p>您还可以针对每个目录启用两种新行为，以控制系统如何释放缓存数据：</p><ul><li><strong>StorageManager.setCacheBehaviorAtomic()</strong> 可用于指示某个目录及其所有内容应作为一个不可分割的整体进行删除。</li><li><strong>setCacheBehaviorTombstone(File, boolean)</strong> 可用于指示不应删除某个目录内的文件，而应将它们截断到 0 字节长度，使空文件保持完好。</li></ul><p>最后，在需要为大文件分配磁盘空间时，可考虑使用新的 <code>allocateBytes(FileDescriptor, long)</code> API，它将自动清除属于其他应用的缓存文件（根据需要），以满足您的请求。在确定设备是否有足够的磁盘空间保存您的新数据时，请调用 <code>getAllocatableBytes(UUID)</code> 而不要使用 <code>getUsableSpace()</code>，因为前者会考虑系统要为您清除的任何缓存数据。</p><h2 id="内容提供程序分页"><a href="#内容提供程序分页" class="headerlink" title="内容提供程序分页"></a>内容提供程序分页</h2><p>我们已更新内容提供程序以支持加载大型数据集，每次加载一页。例如，一个具有大量图像的照片应用可查询要在页面中显示的数据的子集。内容提供程序返回的每个结果页面由一个 Cursor 对象表示。客户端和提供程序必须实现分页才能利用此功能。</p><p>如需了解有关内容提供程序变更的详细信息，请参阅<a href="https://developer.android.com/reference/android/content/ContentProvider.html" target="_blank" rel="noopener">ContentProvider</a>和<a href="https://developer.android.com/reference/android/content/ContentProviderClient.html" target="_blank" rel="noopener">ContentProviderClient</a>。</p><h2 id="内容刷新请求"><a href="#内容刷新请求" class="headerlink" title="内容刷新请求"></a>内容刷新请求</h2><p>现在，<strong>ContentProvider</strong> 和 <strong>ContentResolver</strong> 类均包含 <code>refresh()</code> 函数，这样，客户端可以更轻松地知道所请求的信息是否为最新信息。</p><p>您可以扩展 <strong>ContentProvider</strong> 以添加自定义的内容刷新逻辑。请务必重写 <code>refresh()</code>函数，以返回 true，告知提供程序的客户端您已尝试自行刷新数据。</p><p>您的客户端应用可通过调用另一个函数（又称 refresh()），显式请求已刷新的内容。在调用此函数时，传入待刷新数据的 URI。</p><blockquote><p><strong>注：</strong>由于您可能通过网络不断请求数据，您应仅在有明显迹象表明内容确已过时时才从客户端调用 refresh()。执行此类内容刷新最常见的原因是响应滑动刷新手势，该手势显式请求当前界面显示最新内容。</p></blockquote><h2 id="JobScheduler-改进"><a href="#JobScheduler-改进" class="headerlink" title="JobScheduler 改进"></a>JobScheduler 改进</h2><p>Android 8.0 引入了对 <strong>JobScheduler</strong> 的多项改进。由于您通常可以使用计划作业替代现在受限的后台服务或隐式广播接收器，这些改进可以让您的应用更轻松地符合新的后台执行限制。</p><p><strong>JobScheduler</strong> 的更新包括：</p><ul><li>您现在可以将工作队列与计划作业关联。要将一个工作项添加到作业的队列中，请调用 JobScheduler.enqueue()。当作业运行时，它可以将待定工作从队列中剥离并进行处理。这种功能可以处理之前需要启动后台服务（尤其是实现 IntentService 的服务）的许多用例。</li><li>您现在可以通过调用 JobInfo.Builder.setClipData() 的方式将 ClipData 与作业关联。利用此选项，您可以将 URI 权限授予与作业关联，类似于这些权限传递到 Context.startService() 的方式。您也可以将 URI 权限授予用于工作队列上的 intent。</li><li>计划作业现在支持多个新的约束条件：<br><code>JobInfo.isRequireStorageNotLow()</code><br>&emsp;&emsp;如果设备的可用存储空间非常低，作业将不会运行。<br><code>JobInfo.isRequireBatteryNotLow()</code><br>&emsp;&emsp;如果电池电量等于或低于临界阈值，作业将不会运行；临界阈值是指设备显示 Low battery warning 系统对话框的电量。<br><code>NETWORK_TYPE_METERED</code><br>&emsp;&emsp;作业需要一个按流量计费的网络连接，比如大多数移动数据网络数据套餐。</li></ul><h2 id="自定义数据存储"><a href="#自定义数据存储" class="headerlink" title="自定义数据存储"></a>自定义数据存储</h2><p>Android 8.0 允许您为首选项提供自定义数据存储，如果您的应用将首选项存储在云或本地数据库中，或者如果首选项特定于某个设备，此功能会非常有用。如需了解有关实现数据存储的详细信息，请参阅<a href="https://developer.android.com/preview/features/custom-data-store.html" target="_blank" rel="noopener">自定义数据存储</a>。</p><h2 id="findViewById-签名变更"><a href="#findViewById-签名变更" class="headerlink" title="findViewById() 签名变更"></a>findViewById() 签名变更</h2><p>现在，findViewById() 函数的全部实例均返回 <code>&lt;T extends View&gt;</code> T，而不是 View。此变更会带来以下影响：</p><ul><li>例如，如果 <code>someMethod(View)</code> 和 <code>someMethod(TextView)</code> 均接受调用 <code>findViewById()</code> 的结果，这可能导致现有代码的返回类型不确定。</li><li>在使用 Java 8 源语言时，这需要在返回类型不受限制时（例如，<code>assertNotNull(findViewById(...)).someViewMethod())</code>）显式转换为 View。</li><li>重写非最终的 <code>findViewById()</code> 函数（例如，Activity.findViewById()）将需要更新其返回类型。</li></ul><h1 id="媒体增强功能"><a href="#媒体增强功能" class="headerlink" title="媒体增强功能"></a>媒体增强功能</h1><hr><p><a href="https://developer.android.com/guide/topics/providers/document-provider.html" target="_blank" rel="noopener">存储访问框架 (SAF)</a> 允许应用显示自定义 <strong>DocumentsProvider</strong>，后者可以为其他应用提供访问数据源中的文件的权限。事实上，文档提供程序甚至可以提供驻留在网络存储区或使用<a href="https://en.wikipedia.org/wiki/Media_Transfer_Protocol" target="_blank" rel="noopener">媒体传输协议 (MTP) </a>等协议的文件的访问权限。</p><p>但是，访问远程数据源中的大媒体文件面临一些挑战：</p><ul><li>媒体播放器需要以寻址方式访问来自文档提供程序的文件。当大媒体文件驻留在远程数据源上时，文档提供程序必须事先提取所有数据，并创建快照文件描述符。媒体播放器无法播放没有文件描述符的文件，因此在文档提供程序完成文件下载前，无法开始播放。</li><li>照片应用等媒体集合管理器必须通过作用域文件夹遍历一系列访问 URI 才能访问存储在外部 SD 卡上的媒体。这种访问模式会让媒体上的批量操作（例如移动、复制和删除）变得非常缓慢。</li><li>媒体集合管理器无法根据文档的 URI 确定其位置。这就让这些类型的应用难以允许用户选择媒体文件的保存位置。<br>Android 8.0 通过改进存储访问框架解决了各个挑战。</li></ul><h3 id="自定义文档提供程序"><a href="#自定义文档提供程序" class="headerlink" title="自定义文档提供程序"></a>自定义文档提供程序</h3><p>从 Android 8.0 开始，存储访问框架允许自定义<a href="https://developer.android.com/guide/topics/providers/create-document-provider.html" target="_blank" rel="noopener">文档提供程序</a>为驻留在远程数据源中的文件创建可寻址的文件描述符。SAF 可打开文件，获取原生可寻址的文件描述符。然后 SAF 向文档提供程序提交离散字节请求。此功能使文档提供程序可以返回媒体播放器应用请求的准确字节范围，而不必事先缓存整个文件。</p><p>要使用此功能，您需要调用新的 <code>StorageManager.openProxyFileDescriptor()</code> 函数。<code>openProxyFileDescriptor()</code> 函数可接受 <strong>ProxyFileDescriptorCallback</strong> 对象作为回调。任何时候，当客户端应用对文档提供程序返回的文件描述符执行文件操作时，SAF 都会调用回调。</p><h3 id="直接文档访问"><a href="#直接文档访问" class="headerlink" title="直接文档访问"></a>直接文档访问</h3><p>从 Android 8.0 开始，您可以使用 <code>getDocumentUri()</code> 函数获得与给定 mediaUri 引用相同文档的 URI。不过，由于返回的 URI 由 <strong>DocumentsProvider</strong> 提供支持，媒体集合管理器可以直接访问文档，不用遍历作用域目录树。因此，媒体管理器能够以明显加快的速度对文档执行文件操作。</p><blockquote><p><strong>注意：</strong><code>getDocumentUri()</code> 函数仅可以定位媒体文件；无法授予应用访问这些文件的权限。要详细了解如何获取媒体文件的访问权限，请参阅参考文档。</p></blockquote><h3 id="文档路径"><a href="#文档路径" class="headerlink" title="文档路径"></a>文档路径</h3><p>在 Android 8.0 中使用存储访问框架时，您可以根据文档的 ID，使用 <code>findDocumentPath()</code> 函数（存在于 <strong>DocumentsContract</strong> 和 <strong>DocumentsProvider</strong> 类中）从文件系统的根目录中确定路径。该函数将在 DocumentsContract.Path 对象中返回此路径。如果文件系统对相同文档有多个定义的路径，该函数将返回访问具有给定 ID 的文档时最常使用的路径。</p><p>此功能在下列情况下特别有用：</p><ul><li>您的应用使用可以显示特定文档位置的“另存为”对话框。</li><li>您的应用在搜索结果视图中显示文件夹并且如果用户选择某个文件夹，应用必须加载此特定文件夹内的子文档。<blockquote><p><strong>注：</strong>如果您的应用仅具有路径中某些文档的访问权限，那么 <code>findDocumentPath()</code> 的返回值将仅包含您的应用可以访问的文件夹和文档。</p></blockquote></li></ul><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><hr><h2 id="WLAN-感知"><a href="#WLAN-感知" class="headerlink" title="WLAN 感知"></a>WLAN 感知</h2><p>Android 8.0 新增了对 WLAN 感知的支持，此技术基于周边感知联网 (NAN) 规范。在具有相应 WLAN 感知硬件的设备上，应用和附近设备可以通过 WLAN 进行搜索和通信，无需依赖互联网接入点。我们正在与硬件合作伙伴合作，以尽快将 WLAN 感知技术应用于设备。要了解有关如何将 WLAN 感知集成到您的应用中的信息，请参阅 <a href="https://developer.android.com/preview/features/wifi-aware.html" target="_blank" rel="noopener">WLAN 感知</a>。</p><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>Android 8.0 通过增加以下功能，增强了平台对蓝牙的支持：</p><ul><li>支持 AVRCP 1.4 标准，该标准支持音乐库浏览。</li><li>支持蓝牙低功耗 (BLE) 5.0 标准。</li><li>将 Sony LDAC 编解码器集成到蓝牙堆叠中。</li></ul><h2 id="配套设备配对"><a href="#配套设备配对" class="headerlink" title="配套设备配对"></a>配套设备配对</h2><p>在尝试通过蓝牙、BLE 和 WLAN 与配套设备配对时，Android 8.0 提供的 API 允许您自定义配对请求对话框。如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/companion-device-pairing.html" target="_blank" rel="noopener">配套设备配对</a>。</p><p>如需了解有关在 Android 上使用<a href="https://developer.android.com/guide/topics/connectivity/bluetooth.html" target="_blank" rel="noopener">蓝牙</a>的详细信息，请参阅蓝牙指南。有关对蓝牙所作的特定于 Android 8.0 的变更，请参阅 <a href="https://developer.android.com/preview/behavior-changes.html" target="_blank" rel="noopener">Android 8.0 行为变更</a>页面的<a href="https://developer.android.com/preview/behavior-changes.html#bt" target="_blank" rel="noopener">蓝牙</a>部分。</p><h1 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h1><hr><h2 id="智能共享"><a href="#智能共享" class="headerlink" title="智能共享"></a>智能共享</h2><p>Android 8.0 了解用户的个性化分享首选项，在通过哪些应用分享各个类型的内容方面，也有着更好的把握。例如，如果用户为一张收据拍照，Android 8.0 可以建议费用跟踪应用；如果用户自拍，一款社交媒体应用可以更好地处理图像。Android 8.0 可以根据用户的个性化首选项自动学习所有这些模式。</p><p>智能分享适用于 image 之外的内容类型，例如 <strong>audio</strong>、<strong>video</strong>、<strong>text</strong> 和 <strong>URL</strong> 等。</p><p>要启用智能分享，请将具有最多三个字符串注释的 <strong>ArrayList</strong> 添加到分享内容的 intent。这些注释应说明内容中的主要部分或主题。下面的代码示例显示了如何向 intent 添加注释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; annotations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">annotations.add(<span class="string">"topic1"</span>);</span><br><span class="line">annotations.add(<span class="string">"topic2"</span>);</span><br><span class="line">annotations.add(<span class="string">"topic3"</span>);</span><br><span class="line"></span><br><span class="line">intent.putStringArrayListExtra(</span><br><span class="line">    Intent.EXTRA_CONTENT_ANNOTATIONS,</span><br><span class="line">    annotations</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>如需了解有关智能分享注释的详细信息，请参阅 <code>EXTRA_CONTENT_ANNOTATIONS</code>。</p><h2 id="智能文本选择"><a href="#智能文本选择" class="headerlink" title="智能文本选择"></a>智能文本选择</h2><p>在兼容设备上，Android 8.0 让应用可以帮助用户以更有意义的方式与文本交互。当用户长按某个实体中可识别格式的单词（例如某个地址或餐馆名称）时，系统会选中整个实体。用户会看到一个浮动工具栏，该工具栏包含可以处理所选文本实体的应用。例如，如果系统识别出某个地址，它可以将用户导向地图应用。</p><p>系统识别的实体包括地址、网址、电话号码和电子邮件地址。如需了解详细信息，请参阅 <strong>TextClassifier</strong>。</p><h1 id="无障碍功能"><a href="#无障碍功能" class="headerlink" title="无障碍功能"></a>无障碍功能</h1><hr><p>Android 8.0 支持开发者使用以下无障碍功能创建自己的无障碍服务。如需了解有关如何让您的应用更便于访问的更多信息，请参阅<a href="https://developer.android.com/guide/topics/ui/accessibility/index.html" target="_blank" rel="noopener">无障碍功能</a>。</p><h2 id="无障碍功能按钮"><a href="#无障碍功能按钮" class="headerlink" title="无障碍功能按钮"></a>无障碍功能按钮</h2><p>您的无障碍服务现在可以请求在系统的导航区域显示无障碍功能按钮，该按钮让用户可从其设备上的任意位置快速激活您的服务功能。要执行此操作，请在某个 <strong>AccessibilityServiceInfo</strong> 对象的 <strong>android:accessibilityFlags</strong> 属性中添加 <strong>FLAG_REQUEST_ACCESSIBILITY_BUTTON</strong> 标志。稍后，您可以使用 <code>registerAccessibilityButtonCallback()</code> 注册回调。</p><blockquote><p><strong>注：</strong>此功能仅适用于提供软件渲染导航区域的设备。请始终使用 <code>isAccessibilityButtonAvailable()</code>，并通过实现 <code>onAvailabilityChanged()</code> 根据无障碍功能按钮的可用性来响应变更。通过该方式，用户可以始终访问您的服务功能，即使该无障碍功能按钮不受支持或变得不可用。</p></blockquote><h2 id="独立的音量调整"><a href="#独立的音量调整" class="headerlink" title="独立的音量调整"></a>独立的音量调整</h2><p>Android 8.0 引入了 <strong>STREAM_ACCESSIBILITY</strong> 音量类别，允许您单独控制无障碍服务音频输出的音量，而不会影响设备上的其他声音。</p><p>要使用这个新的流类型来控制无障碍服务音量，请在无障碍服务中设置 <strong>FLAG_ENABLE_ACCESSIBILITY_VOLUME</strong> 选项。然后，您可以使用 <code>adjustStreamVolume()</code> 更改设备的无障碍服务音频音量。</p><h2 id="指纹手势"><a href="#指纹手势" class="headerlink" title="指纹手势"></a>指纹手势</h2><p>您的无障碍服务也可以响应替代的输入机制，即沿设备的指纹传感器按特定方向滑动（上、下、左和右）。要接收有关这些交互的回调，请完成以下一系列步骤：</p><ol><li>声明 <strong>USE_FINGERPRINT </strong>权限和 <strong>CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES</strong> 功能。</li><li>在 <strong>android:accessibilityFlags</strong> 属性中设置 <strong>FLAG_REQUEST_FINGERPRINT_GESTURES</strong> 标志。</li><li>使用 <code>registerFingerprintGestureCallback()</code> 注册回调。</li></ol><p>请记住，并非所有设备都包含指纹传感器。您可以使用 <code>isHardwareDetected()</code> 函数识别设备是否支持此传感器。即使对于包含指纹传感器的设备，您的服务也只有在指纹传感器不用于身份验证目的时才可使用它。要识别此传感器何时可用，请调用 <code>isGestureDetectionAvailable()</code> 函数并实现 <code>onGestureDetectionAvailabilityChanged()</code> 回调。</p><h2 id="字词级突出显示"><a href="#字词级突出显示" class="headerlink" title="字词级突出显示"></a>字词级突出显示</h2><p>要确定 <strong>TextView</strong> 对象中可见字符的位置，您可以在 <strong>EXTRA_DATA_TEXT_CHARACTER_LOCATION_KEY</strong> 中将其作为第一个参数传递到 <code>refreshWithExtraData()</code> 中。随后会更新您为 <code>refreshWithExtraData()</code> 提供的作为第二个参数的 <strong>Bundle</strong> 对象，使之包含一个可打包的 <strong>Rect</strong> 对象数组。每个 <strong>Rect</strong> 对象代表某个特定字符的边界框。</p><p>如果您的服务使用 <strong>TextToSpeech</strong> 对象朗读屏幕上出现的内容，您可以获取有关文本到语音转换引擎何时开始朗读单个合成字词时的准确时间信息，前提是文本到语音转换引擎提供此信息。当引擎即将开始播放特定范围文本的音频时，Text-to-Speech API 会通知您的服务，将使用 <code>onRangeStart()</code> 函数开始朗读此范围的文本。</p><p>如果您创建自己的 <strong>TextToSpeechService</strong> 实现，您可以使用 <code>rangeStart()</code> 函数支持这一新功能。</p><h2 id="标准化单端范围值"><a href="#标准化单端范围值" class="headerlink" title="标准化单端范围值"></a>标准化单端范围值</h2><p><strong>AccessibilityNodeInfo</strong> 的一些实例使用 <code>AccessibilityNodeInfo.RangeInfo</code> 的某个实例来表明界面元素可接受一定范围的值。使用 <code>RangeInfo.obtain()</code> 创建范围或使用 <code>getMin()</code> 和 <code>getMax()</code> 检索此范围的极值时，请注意，Android 8.0 规定了标准化单端范围：</p><ul><li>对于没有最小值的范围，<strong>Float.NEGATIVE_INFINITY</strong> 表示最小值。</li><li>对于没有最大值的范围，<strong>Float.POSITIVE_INFINITY</strong> 表示最大值。</li></ul><h2 id="提示文本"><a href="#提示文本" class="headerlink" title="提示文本"></a>提示文本</h2><p>Android 8.0 包含可用于与文本可编辑对象的提示文本进行交互的多个函数：</p><ul><li><code>isShowingHintText()</code> 和 <code>setShowingHintText()</code> 函数分别显示和设置节点的当前文本内容是否表示节点的提示文本。如果节点不包含可编辑文本，则它不应包含提示文本。</li><li>要访问提示文本本身，请使用 <code>getHintText()</code>。即使某个对象当前未显示提示文本，系统也能成功调用 <code>getHintText()</code>。</li></ul><h2 id="连续的手势分派"><a href="#连续的手势分派" class="headerlink" title="连续的手势分派"></a>连续的手势分派</h2><p>您的服务现在可以使用 <code>GestureDescription.StrokeDescription</code> 构造函数中的最后一个参数 <strong>willContinue</strong>，指定属于同一设定手势的笔划的顺序。</p><h1 id="安全性与隐私"><a href="#安全性与隐私" class="headerlink" title="安全性与隐私"></a>安全性与隐私</h1><hr><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>Android 8.0 引入了多个与电话有关的新权限：</p><ul><li><strong>ANSWER_PHONE_CALLS</strong> 允许您的应用通过编程方式接听呼入电话。要在您的应用中处理呼入电话，您可以使用 <code>acceptRingingCall()</code> 函数。</li><li><strong>READ_PHONE_NUMBERS</strong> 权限允许您的应用读取设备中存储的电话号码。<br>这些权限均被划分为<strong>危险</strong>类别，属于 <strong>PHONE</strong> 权限组。</li></ul><p>##新的帐号访问和 Discovery API<br>Android 8.0 对应用访问用户帐号的方式引入多项改进。对于由身份验证器管理的帐号，身份验证器在决定对应用隐藏帐号还是显示帐号时可以使用自己的策略。Android 系统跟踪可以访问特定帐号的应用。</p><p>在以前的 Android 版本中，想要跟踪用户帐号列表的应用必须获取有关所有帐号的更新，包括具有不相关类型的帐号。Android 8.0 添加了 addOnAccountsUpdatedListener(android.accounts.OnAccountsUpdateListener, android.os.Handler, boolean, java.lang.String[]) 函数，其允许应用指定应接收帐号变更的帐号类型列表。</p><h3 id="API-变更-1"><a href="#API-变更-1" class="headerlink" title="API 变更"></a>API 变更</h3><p>AccountManager 提供六个新函数以帮助身份验证器管理哪些应用可以查看某个帐号：</p><ul><li><code>setAccountVisibility(android.accounts.Account, java.lang.String, int)</code>：针对特定用户帐号和软件包组合设置可见性级别。</li><li><code>getAccountVisibility(android.accounts.Account, java.lang.String)</code>：获取特定用户帐号和软件包组合的可见性级别。</li><li><code>getAccountsAndVisibilityForPackage(java.lang.String, java.lang.String)</code>：允许身份验证器获取帐号和给定软件包的可见性级别。</li><li><code>getPackagesAndVisibilityForAccount(android.accounts.Account)</code>：允许身份验证器获取存储的给定帐号的可见性值。</li><li><code>addAccountExplicitly(android.accounts.Account, java.lang.String, android.os.Bundle, java.util.Map&lt;java.lang.String, java.lang.Integer&gt;)</code>：允许身份验证器初始化帐号的可见性值。</li><li><code>addOnAccountsUpdatedListener(android.accounts.OnAccountsUpdateListener, android.os.Handler, boolean, java.lang.String[])</code>：将 <strong>OnAccountsUpdateListener</strong> 侦听器添加到 <strong>AccountManager</strong> 对象。无论设备上的帐号列表何时发生变化，系统都将调用此侦听器。</li></ul><p>Android 8.0 引入两个特殊的软件包名称值，以使用 <code>setAccountVisibility(android.accounts.Account, java.lang.String, int)</code> 函数指定未设置的应用的可见性级别。<strong>PACKAGE_NAME_KEY_LEGACY_VISIBLE</strong> 可见性值应用于具有 <strong>GET_ACCOUNTS</strong> 权限的应用，并且其目标 Android 版本低于 Android 8.0，或其签名与针对任意 Android 版本的身份验证器匹配。<strong>PACKAGE_NAME_KEY_LEGACY_NOT_VISIBLE</strong> 为之前未设置的应用提供默认的可见性值，对于此类应用，<strong>PACKAGE_NAME_KEY_LEGACY_VISIBLE</strong> 不适用。</p><p>如需了解有关新的帐号访问和发现 API 的详细信息，请参阅 <strong>AccountManager</strong> 和 <strong>OnAccountsUpdateListener</strong> 参考。</p><p>##Google Safe Browsing API<br>WebView 类现在添加了一个 Safe Browsing API 来增强网络浏览的安全性。如需了解详细信息，请参阅 <a href="https://developer.android.com/preview/features/managing-webview.html#safe-browsing" target="_blank" rel="noopener">Google Safe Browsing API</a>。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="仪器测试"><a href="#仪器测试" class="headerlink" title="仪器测试"></a>仪器测试</h2><p>Android 8.0 为应用的仪器测试提供以下几项额外支持。</p><h3 id="针对非默认应用进程运行"><a href="#针对非默认应用进程运行" class="headerlink" title="针对非默认应用进程运行"></a>针对非默认应用进程运行</h3><p>现在，您可以指定针对您的应用的默认进程以外的进程运行特定仪器测试。如果您的应用包含多个在不同进程中运行的操作组件，此配置非常有用。</p><p>要定义非默认进程仪器测试，请导航至您的清单文件，然后导航至所需的 <code>&lt;instrumentation&gt;</code> 元素。添加 <code>android:targetProcess</code> 属性，并将它的值设置为以下值之一：</p><ul><li>特定进程的名称。</li><li>以逗号分隔的进程名称列表。</li><li>通配符（”*”），允许针对任何执行 <strong>android:targetPackage</strong> 属性中指定的软件包中的代码的已启动进程运行仪器测试。<br>在执行仪器测试时，您可以通过调用 <code>getProcessName()</code> 检查正在测试哪个进程。</li></ul><h3 id="在测试过程中报告结果"><a href="#在测试过程中报告结果" class="headerlink" title="在测试过程中报告结果"></a>在测试过程中报告结果</h3><p>现在，通过调用 <code>addResults()</code>，您可以在执行仪器测试时（而不用等到测试后）报告结果。</p><h2 id="用于测试的模拟-Intent"><a href="#用于测试的模拟-Intent" class="headerlink" title="用于测试的模拟 Intent"></a>用于测试的模拟 Intent</h2><p>为了更轻松地为您应用的操作组件创建隔离、独立的界面测试，Android 8.0 引入了 <code>onStartActivity()</code> 函数。要处理您的测试类调用的特定 intent，您可以在 <code>nstrumentation.ActivityMonitor</code> 类的自定义子类中替换此函数。</p><p>当您的测试类调用 intent 时，该函数将返回一个存根 <code>Instrumentation.ActivityResult</code> 对象，而不是执行 intent 本身。通过在您的测试中使用这种模拟 intent 逻辑，您可以侧重于自己的操作组件如何准备和处理您传递到不同操作组件或完全不同的应用中的 intent。</p><h1 id="运行时和工具"><a href="#运行时和工具" class="headerlink" title="运行时和工具"></a>运行时和工具</h1><hr><h2 id="平台优化"><a href="#平台优化" class="headerlink" title="平台优化"></a>平台优化</h2><p>Android 8.0 为平台引入了运行时优化和其他优化，这些优化将带来多项性能改进。这些优化包括并发压缩垃圾回收、更有效的内存利用和代码区域。</p><p>它们可以加快启动时间，并为 OS 和应用带来更好的性能。</p><h2 id="更新的-Java-支持"><a href="#更新的-Java-支持" class="headerlink" title="更新的 Java 支持"></a>更新的 Java 支持</h2><p>Android 8.0 添加了对更多 OpenJDK Java API 的支持：</p><ul><li>OpenJDK 8 中的 java.time。</li><li>OpenJDK 7 中的 java.nio.file 和 java.lang.invoke。<br>要详细了解这些新添加的软件包中的类和函数，请参阅 API 参考文档。</li></ul><p>如果您想要在 Android Studio 中使用 <a href="https://developer.android.com/studio/preview/features/java8-support.html" target="_blank" rel="noopener">Java 8 语言功能</a>，您应下载最新的预览版本。</p><h2 id="更新的-ICU4J-Android-Framework-API"><a href="#更新的-ICU4J-Android-Framework-API" class="headerlink" title="更新的 ICU4J Android Framework API"></a>更新的 ICU4J Android Framework API</h2><p>Android 8.0 扩展了 ICU4J Android 框架 API—，它是 ICU4J API 的子集—，供应用开发者在 android.icu 软件包中使用。这些 API 使用设备上具有的本地化数据。因此，您无需在 APK 中编译 ICU4J 库，从而减少 APK 占用空间。</p><h1 id="Android-企业版"><a href="#Android-企业版" class="headerlink" title="Android 企业版"></a>Android 企业版</h1><hr><p>已为运行 Android 8.0 的设备引入新的企业功能和 API。重要功能包括如下：</p><ul><li>完全托管的设备中的工作资料使企业可以在管理工作数据与个人数据的同时，将它们分离开来。</li><li>API 委派允许设备所有者和个人资料所有者将应用管理分配给其他应用。</li><li>配置流程中的用户体验改进措施（包含新的自定义选项）缩短了设置时间。</li><li>蓝牙、WLAN、备份和安全性方面的新增控制选项使企业可以更精细地管理设备。网络操作组件日志记录可帮助企业追查问题。</li></ul><p>如需详细了解上述及其他新增 Android 企业版 API 和功能，请参阅<a href="https://developer.android.com/preview/features/work.html" target="_blank" rel="noopener">企业中的 Android</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用户体验&quot;&gt;&lt;a href=&quot;#用户体验&quot; class=&quot;headerlink&quot; title=&quot;用户体验&quot;&gt;&lt;/a&gt;用户体验&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;通知&quot;&gt;&lt;a href=&quot;#通知&quot; class=&quot;headerlink&quot; title=&quot;通知&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Oreo" scheme="http://yoursite.com/tags/Oreo/"/>
    
      <category term="Android8.0" scheme="http://yoursite.com/tags/Android8-0/"/>
    
  </entry>
  
  <entry>
    <title>Android 7.0 行为变更</title>
    <link href="http://yoursite.com/2017/01/10/android-7-0-changes/"/>
    <id>http://yoursite.com/2017/01/10/android-7-0-changes/</id>
    <published>2017-01-10T07:15:08.000Z</published>
    <updated>2018-03-30T07:17:43.890Z</updated>
    
    <content type="html"><![CDATA[<p>Android 7.0 除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。</p><p>如果您之前发布过 Android 应用，请注意您的应用可能受到这些平台变化的影响。</p><h1 id="电池和内存"><a href="#电池和内存" class="headerlink" title="电池和内存"></a>电池和内存</h1><hr><p>Android 7.0 包括旨在延长设备电池寿命和减少 RAM 使用的系统行为变更。这些变更可能会影响您的应用访问系统资源，以及您的应用通过特定隐式 intent 与其他应用交互的方式。</p><h2 id="低电耗模式"><a href="#低电耗模式" class="headerlink" title="低电耗模式"></a>低电耗模式</h2><p>Android 6.0（API 级别 23）引入了低电耗模式，当用户设备未插接电源、处于静止状态且屏幕关闭时，该模式会推迟 CPU 和网络活动，从而延长电池寿命。而 Android 7.0 则通过在设备未插接电源且屏幕关闭状态下、但不一定要处于静止状态（例如用户外出时把手持式设备装在口袋里）时应用部分 CPU 和网络限制，进一步增强了低电耗模式。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/01/10/android-7-0-changes/doze-diagram-1.png" alt="dhd" title="">                </div>                <div class="image-caption">dhd</div>            </figure><br>图 1. 低电耗模式如何应用第一级系统活动限制以延长电池寿命的图示。</p><p>当设备处于充电状态且屏幕已关闭一定时间后，设备会进入低电耗模式并应用第一部分限制：关闭应用网络访问、推迟作业和同步。如果进入低电耗模式后设备处于静止状态达到一定时间，系统则会对 <code>PowerManager.WakeLock</code>、<code>AlarmManager</code> 闹铃、GPS 和 WLAN 扫描应用余下的低电耗模式限制。无论是应用部分还是全部低电耗模式限制，系统都会唤醒设备以提供简短的维护时间窗口，在此窗口期间，应用程序可以访问网络并执行任何被推迟的作业/同步。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2017/01/10/android-7-0-changes/doze-diagram-2.png" alt="dhd" title="">                </div>                <div class="image-caption">dhd</div>            </figure><br>图 2. 低电耗模式如何在设备处于静止状态达到一定时间后应用第二级系统活动限制的图示。</p><p>请注意，激活屏幕或插接设备电源时，系统将退出低电耗模式并移除这些处理限制。此项新增的行为不会影响有关使您的应用适应 Android 6.0（API 级别 23）中所推出的旧版本低电耗模式的建议和最佳做法，如<a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html" target="_blank" rel="noopener">对低电耗模式和应用待机模式进行针对性优化</a>中所讨论。您仍应遵循这些建议（例如使用 Google 云消息传递 (GCM) 发送和接收消息）并开始安排更新计划以适应新增的低电耗模式行为。</p><h2 id="Project-Svelte：后台优化"><a href="#Project-Svelte：后台优化" class="headerlink" title="Project Svelte：后台优化"></a>Project Svelte：后台优化</h2><p>Android 7.0 移除了三项隐式广播，以帮助优化内存使用和电量消耗。此项变更很有必要，因为隐式广播会在后台频繁启动已注册侦听这些广播的应用。删除这些广播可以显著提升设备性能和用户体验。</p><p>移动设备会经历频繁的连接变更，例如在 WLAN 和移动数据之间切换时。目前，可以通过在应用清单中注册一个接收器来侦听隐式 <code>CONNECTIVITY_ACTION</code> 广播，让应用能够监控这些变更。由于很多应用会注册接收此广播，因此单次网络切换即会导致所有应用被唤醒并同时处理此广播。</p><p>同理，在之前版本的 Android 中，应用可以注册接收来自其他应用（例如相机）的隐式 <code>ACTION_NEW_PICTURE</code> 和 <code>ACTION_NEW_VIDEO</code> 广播。当用户使用相机应用拍摄照片时，这些应用即会被唤醒以处理广播。</p><p>为缓解这些问题，Android 7.0 应用了以下优化措施：</p><ul><li>面向 Android 7.0 开发的应用不会收到 <code>CONNECTIVITY_ACTION</code> 广播，即使它们已有清单条目来请求接受这些事件的通知。在前台运行的应用如果使用 <code>BroadcastReceiver</code> 请求接收通知，则仍可以在主线程中侦听 CONNECTIVITY_CHANGE。</li><li>应用无法发送或接收 <code>ACTION_NEW_PICTURE</code> 或 <code>ACTION_NEW_VIDEO</code> 广播。此项优化会影响所有应用，而不仅仅是面向 Android 7.0 的应用。</li></ul><p>如果您的应用使用任何 intent，您仍需要尽快移除它们的依赖关系，以正确适配 Android 7.0 设备。Android 框架提供多个解决方案来缓解对这些隐式广播的需求。例如，<code>JobScheduler</code> API 提供了一个稳健可靠的机制来安排满足指定条件（例如连入无限流量网络）时所执行的网络操作。您甚至可以使用 <code>JobScheduler</code> 来适应内容提供程序变化。</p><p>如需了解有关 Android N 中后台优化以及如何改写应用的详细信息，请参阅<a href="https://developer.android.com/preview/features/background-optimization.html" target="_blank" rel="noopener">后台优化</a>。</p><h1 id="权限更改"><a href="#权限更改" class="headerlink" title="权限更改"></a>权限更改</h1><hr><p>Android 7.0 做了一些权限更改，这些更改可能会影响您的应用。</p><h2 id="系统权限更改"><a href="#系统权限更改" class="headerlink" title="系统权限更改"></a>系统权限更改</h2><p>为了提高私有文件的安全性，面向 Android 7.0 或更高版本的应用私有目录被限制访问　(0700)。此设置可防止私有文件的元数据泄漏，如它们的大小或存在性。此权限更改有多重副作用：</p><ul><li><p>私有文件的文件权限不应再由所有者放宽，为使用 <code>MODE_WORLD_READABLE</code> 和/或 <code>MODE_WORLD_WRITEABLE</code> 而进行的此类尝试将触发 <code>SecurityException</code>。</p><blockquote><p><strong>注：</strong>迄今为止，这种限制尚不能完全执行。应用仍可能使用原生 API 或 File API 来修改它们的私有目录权限。但是，我们强烈反对放宽私有目录的权限。</p></blockquote></li><li><p>传递软件包网域外的 file:// URI 可能给接收器留下无法访问的路径。因此，尝试传递 file:// URI 会触发 <code>FileUriExposedException</code>。分享私有文件内容的推荐方法是使用 <code>FileProvider</code>。</p></li><li><code>DownloadManager</code> 不再按文件名分享私人存储的文件。旧版应用在访问 <code>COLUMN_LOCAL_FILENAME</code> 时可能出现无法访问的路径。面向 Android 7.0 或更高版本的应用在尝试访问 <code>COLUMN_LOCAL_FILENAME</code> 时会触发 <code>SecurityException</code>。通过使用 <code>DownloadManager.Request.setDestinationInExternalFilesDir()</code> 或 <code>DownloadManager.Request.setDestinationInExternalPublicDir()</code> 将下载位置设置为公共位置的旧版应用仍可以访问 <code>COLUMN_LOCAL_FILENAME</code> 中的路径，但是我们强烈反对使用这种方法。对于由 <code>DownloadManager</code> 公开的文件，首选的访问方式是使用<code>ContentResolver.openFileDescriptor()</code>。</li></ul><h1 id="在应用间共享文件"><a href="#在应用间共享文件" class="headerlink" title="在应用间共享文件"></a>在应用间共享文件</h1><hr><p>对于面向 Android 7.0 的应用，Android 框架执行的 <code>StrictMode</code> API 政策禁止在您的应用外部公开 file:// URI。如果一项包含文件 URI 的 intent 离开您的应用，则应用出现故障，并出现 FileUriExposedException 异常。</p><p>要在应用间共享文件，您应发送一项 content:// URI，并授予 URI 临时访问权限。进行此授权的最简单方式是使用 FileProvider 类。如需了解有关权限和共享文件的详细信息，请参阅<a href="https://developer.android.com/training/secure-file-sharing/index.html" target="_blank" rel="noopener">共享文件</a>。</p><h1 id="无障碍改进"><a href="#无障碍改进" class="headerlink" title="无障碍改进"></a>无障碍改进</h1><hr><p>为提高平台对于视力不佳或视力受损用户的易用性，Android 7.0 做出了一些更改。这些更改一般并不要求更改您的应用代码，不过您应仔细检查并使用您的应用测试这些功能，以评估它们对用户体验的潜在影响。</p><h2 id="屏幕缩放"><a href="#屏幕缩放" class="headerlink" title="屏幕缩放"></a>屏幕缩放</h2><p>Android 7.0 支持用户设置显示尺寸，以放大或缩小屏幕上的所有元素，从而提升设备对视力不佳用户的可访问性。用户无法将屏幕缩放至低于最小屏幕宽度 <code>sw320dp</code>，该宽度是 Nexus 4 的宽度，也是常规中等大小手机的宽度。<br><img src="/2017/01/10/android-7-0-changes/screen-zoom-1.png" style="width:45%; float:left"><br><img src="/2017/01/10/android-7-0-changes/screen-zoom-2.png" style="width:45%; float:left"><br> <div style="clear:both"></div><br>图 3. 右侧屏幕显示的是一台运行 Android 7.0 系统映像的设备增大显示尺寸后的效果。</p><p>当设备密度发生更改时，系统会以如下方式通知正在运行的应用：</p><ul><li>如果是面向 API 级别 23 或更低版本系统的应用，系统会自动终止其所有后台进程。这意味着如果用户切换离开此类应用，转而打开 Settings 屏幕并更改 <strong>Display size</strong> 设置，则系统会像处理内存不足的情况一样终止该应用。如果应用具有任何前台进程，则系统会如处理运行时更改中所述将配置变更通知给这些进程，就像对待设备屏幕方向变更一样。</li><li>如果是面向 Android 7.0 的应用，则其所有进程（前台和后台）都会收到有关配置变更的通知，如<a href="https://developer.android.com/guide/topics/resources/runtime-changes.html" target="_blank" rel="noopener">处理运行时更改</a>中所述。</li></ul><p>大多数应用并不需要进行任何更改即可支持此功能，不过前提是这些应用遵循 Android 最佳做法。具体要检查的事项：</p><ul><li>在屏幕宽度为 sw320dp 的设备上测试您的应用，并确保其充分运行。</li><li><p>当设备配置发生变更时，更新任何与密度相关的缓存信息，例如缓存位图或从网络加载的资源。当应用从暂停状态恢复运行时，检查配置变更。</p><blockquote><p><strong>注：</strong>如果您要缓存与配置相关的数据，则最好也包括相关元数据，例如该数据对应的屏幕尺寸或像素密度。保存这些元数据便于您在配置变更后决定是否需要刷新缓存数据。</p></blockquote></li><li><p>避免用像素单位指定尺寸，因为像素不会随屏幕密度缩放。应改为使用与密度无关像素 (dp) 单位指定尺寸。</p></li></ul><h2 id="设置向导中的视觉设置"><a href="#设置向导中的视觉设置" class="headerlink" title="设置向导中的视觉设置"></a>设置向导中的视觉设置</h2><p>Android 7.0 在“Welcome”屏幕中加入了“Vision Settings”，用户可以在新设备上设置以下无障碍功能设置：<strong>Magnification gesture</strong>、<strong>Font size</strong>、<strong>Display size</strong> 和话语提示。此项变更让您可以更容易发现与不同屏幕设置有关的错误。要评估此功能的影响，您应在启用这些设置的状态下测试应用。您可以在 <strong>Settings &gt; Accessibility</strong> 中找到这些设置。</p><h1 id="NDK-应用链接至平台库"><a href="#NDK-应用链接至平台库" class="headerlink" title="NDK 应用链接至平台库"></a>NDK 应用链接至平台库</h1><hr><p>从 Android 7.0 开始，系统将阻止应用动态链接非公开 NDK 库，这种库可能会导致您的应用崩溃。此行为变更旨在为跨平台更新和不同设备提供统一的应用体验。即使您的代码可能不会链接私有库，但您的应用中的第三方静态库可能会这么做。因此，所有开发者都应进行相应检查，确保他们的应用不会在运行 Android 7.0 的设备上崩溃。如果您的应用使用原生代码，则只能使用<a href="https://developer.android.com/ndk/guides/stable_apis.html" target="_blank" rel="noopener">公开 NDK API</a>。</p><p>您的应用可通过以下三种方式尝试访问私有平台 API：</p><ul><li>您的应用直接访问私有平台库。您应更新您的应用以添加该应用的库副本，或使用<a href="https://developer.android.com/ndk/guides/stable_apis.html" target="_blank" rel="noopener">公开 NDK API</a>。</li><li>您的应用使用一个可访问私有平台库的第三方库。即使您确定您的应用不会直接访问私有库，您仍应针对此情景测试您的应用。</li><li>您的应用引用一个其 APK 中未包含的库。例如，如果您尝试使用您自己的 OpenSSL 副本，但忘记将它与应用的 APK 进行捆绑，则可能会出现此情况。正常情况下，此应用可在包含 libcrypto.so 的 Android 平台版本上运行。不过，此应用在不包含此库的新版 Android（例如，Android 6.0 和更高的版本）上会崩溃。为修复此问题，请确保您的 APK 捆绑您的所有非 NDK 库。</li></ul><p>应用不应使用 NDK 中未包含的原生库，因为这些库可能会发生更改或在不同 Android 版本之间的可用性不同。例如，从 OpenSSL 切换至 BoringSSL 即属于此类更改。此外，由于不属于 NDK 中的平台库没有兼容性要求，因此不同的设备可能提供不同级别的兼容性。</p><p>为降低此限制可能对当前发布的应用的影响，面向 API 级别 23 或更低级别的应用在 Android N 上可暂时访问颇为常用的一组库，例如 <code>libandroid_runtime.so</code>、<code>libcutils.so</code>、<code>libcrypto.so</code> 和 <code>libssl.so</code>。如果您的应用加载其中某个库，logcat 会生成一个警告，并在目标设备上显示一个 Toast 来通知您。如果您看到这些警告，您应更新您的应用以添加该应用自己的库副本，或仅使用公开 NDK API。将来发布的 Android 平台可能会完全限制对私有库的使用，并导致您的应用崩溃。</p><p>所有应用在调用既非公开又不可暂时访问的 API 时都会生成一个运行时错误。结果就是 <code>System.loadLibrary</code> 和 <code>dlopen(3)</code> 同时返回 NULL，并可能导致您的应用崩溃。您应检查应用代码以移除对私有平台 API 的使用，并使用预览版设备或模拟器全面测试应用。如果您不确定您的应用是否使用私有库，您可以检查 logcat 以识别运行时错误。</p><p>下表描述的是根据应用使用的私有原生库及其目标 API 级别 (android:targetSdkVersion)，应用预期显示的行为。<br>| Item      |    Value | Qty  |<br>| :——– | ——–:| :–: |<br>| Computer  | 1600 USD |  5   |<br>| Phone     |   12 USD |  12  |<br>| Pipe      |    1 USD | 234  |</p><table><thead><tr><th style="text-align:left">库</th><th style="text-align:left">目标 API 级别</th><th style="text-align:left">通过动态链接器进行运行时访问</th><th style="text-align:left">N Developer Preview 行为</th><th style="text-align:left">最终 Android N 版本行为</th><th style="text-align:left">未来的 Android 平台行为</th></tr></thead><tbody><tr><td style="text-align:left">公开 NDK</td><td style="text-align:left">任意</td><td style="text-align:left">可访问</td><td style="text-align:left">合乎预期</td><td style="text-align:left">合乎预期</td><td style="text-align:left">合乎预期</td></tr><tr><td style="text-align:left">私有（暂时可访问的私有库）</td><td style="text-align:left">23 或更低</td><td style="text-align:left">暂时可访问</td><td style="text-align:left">合乎预期，但您会在目标设备上收到一个 logcat 警告和一条消息。</td><td style="text-align:left">合乎预期，但您会收到一个 logcat 警告。</td><td style="text-align:left">运行时错误</td></tr><tr><td style="text-align:left">私有（暂时可访问的私有库）</td><td style="text-align:left">24 或更高</td><td style="text-align:left">受限</td><td style="text-align:left">运行时错误</td><td style="text-align:left">运行时错误</td><td style="text-align:left">运行时错误</td></tr><tr><td style="text-align:left">私有（其他）</td><td style="text-align:left">任意</td><td style="text-align:left">受限</td><td style="text-align:left">运行时错误</td><td style="text-align:left">运行时错误</td><td style="text-align:left">运行时错误</td></tr></tbody></table><h2 id="检查您的应用是否使用私有库"><a href="#检查您的应用是否使用私有库" class="headerlink" title="检查您的应用是否使用私有库"></a>检查您的应用是否使用私有库</h2><p>为帮助您识别加载私有库的问题，logcat 可能会生成一个警告或运行时错误。例如，如果您的应用面向 API 级别 23 或更低级别，并在运行 Android 7.0 的设备上尝试访问私有库，您可能会看到一个类似于下面所示的警告：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">03</span><span class="number">-21</span> <span class="number">17</span>:<span class="number">07</span>:<span class="number">51.502</span> <span class="number">31234</span> <span class="number">31234</span> W linker  : library <span class="string">"libandroid_runtime.so"</span></span><br><span class="line">(<span class="string">"/system/lib/libandroid_runtime.so"</span>) needed <span class="keyword">or</span> dlopened by</span><br><span class="line"><span class="string">"/data/app/com.popular-app.android-2/lib/arm/libapplib.so"</span> is <span class="keyword">not</span> accessible</span><br><span class="line"><span class="keyword">for</span> the <span class="keyword">namespace</span> <span class="string">"classloader-namespace"</span> - the access is temporarily granted</span><br><span class="line">as a workaround <span class="keyword">for</span> http:<span class="comment">//b/26394120</span></span><br></pre></td></tr></table></figure></p><p>这些 logcat 警告通知您哪个库正在尝试访问私有平台 API，但不会导致您的应用崩溃。但是，如果应用面向 API 级别 24 或更高级别，logcat 会生成以下运行时错误，您的应用可能会崩溃：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.UnsatisfiedLinkError: dlopen failed: library <span class="string">"libcutils.so"</span></span><br><span class="line">(<span class="string">"/system/lib/libcutils.so"</span>) needed <span class="keyword">or</span> dlopened by</span><br><span class="line"><span class="string">"/system/lib/libnativeloader.so"</span> is <span class="keyword">not</span> accessible <span class="keyword">for</span> the <span class="keyword">namespace</span></span><br><span class="line"><span class="string">"classloader-namespace"</span></span><br><span class="line">  at java.lang.Runtime.loadLibrary0(Runtime.java:<span class="number">977</span>)</span><br><span class="line">  at java.lang.System.loadLibrary(System.java:<span class="number">1602</span>)</span><br></pre></td></tr></table></figure></p><p>如果您的应用使用动态链接到私有平台 API 的第三方库，您可能也会看到上述 logcat 输出。利用 Android 7.0DK 中的 readelf 工具，您可以通过运行以下命令生成给定 .so 文件的所有动态链接的共享库列表：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-android-readelf -dW libMyLibrary.so</span><br></pre></td></tr></table></figure></p><h2 id="更新您的应用"><a href="#更新您的应用" class="headerlink" title="更新您的应用"></a>更新您的应用</h2><p>通过下面的一些步骤，您可以修复上述类型的错误并确保您的应用不会在将来的更新版平台上崩溃：</p><ul><li>如果您的应用使用私有平台库，您应更新它，以添加该应用自己的库副本或使用<a href="https://developer.android.com/ndk/guides/stable_apis.html" target="_blank" rel="noopener">公开 NDK API</a>。</li><li>如果您的应用使用访问私有符号的第三方库，则联系库作者以更新库。</li><li>请确保将您的所有非 NDK 库与您的 APK 打包在一起。</li><li><p>使用标准 JNI 函数而非来自 libandroid_runtime.so 的 getJavaVM 和 getJNIEnv：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AndroidRuntime::getJavaVM -&gt; GetJavaVM from &lt;jni.h&gt;</span><br><span class="line">AndroidRuntime::getJNIEnv -&gt; JavaVM::GetEnv <span class="keyword">or</span></span><br><span class="line">JavaVM::AttachCurrentThread from &lt;jni.h&gt;.</span><br></pre></td></tr></table></figure></li><li><p>使用 <strong>system_property_get 而非来自 libcutils.so 的私有 property_get 符号。为此，请使用 </strong>system_property_get 及以下 include 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/system_properties.h&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>注：</strong>系统属性的可用性和内容未通过 CTS 进行测试。应执行进一步修复以避免同时使用这些属性。</p></blockquote><ul><li>使用来自 <code>libcrypto.so</code> 的 SSL_ctrl 符号的本地版本。例如，您应在您的 .so 文件中静态链接 <code>libcyrpto.a</code>，或从 <strong>BoringSSL/OpenSSL</strong> 添加一个动态链接的 <code>libcrypto.so</code> 版本，并将其打包到您的 APK 中。</li></ul><h1 id="Android-for-Work"><a href="#Android-for-Work" class="headerlink" title="Android for Work"></a>Android for Work</h1><hr><p>Android 7.0 包含一些针对面向 Android for Work 的应用的变更，包括对证书安装、密码重置、二级用户管理、设备标识符访问权限的变更。如果您是要针对 Android for Work 环境开发应用，则应仔细检查这些变更并相应地修改您的应用。</p><ul><li>您必须先安装授权证书安装程序，然后 DPC 才能对其进行设置。对于面向 N SDK 的配置文件和设备所有者应用，您应在设备规范控制器 (DPC) 调用 <code>DevicePolicyManager.setCertInstallerPackage()</code> 之前安装授权证书安装程序。如果尚未安装此安装程序，则系统会引发 <code>IllegalArgumentException</code>。</li><li>针对设备管理员的重置密码限制现在也适用于配置文件所有者。设备管理员无法再使用 <code>DevicePolicyManager.resetPassword()</code> 来清除或更改已经设置的密码。设备管理员仍可以设置密码，但只能在设备没有密码、PIN 码或图案时这样做。</li><li>即使设置了限制，设备所有者和配置文件所有者仍可以管理帐户。而且，即使具有 <code>DISALLOW_MODIFY_ACCOUNTS</code> 用户限制，设备所有者和配置文件所有者仍可调用 Account Management API。</li><li>设备所有者可以更轻松地管理二级用户。当设备在设备所有者模式下运行时，系统将自动设置 DISALLOW_ADD_USER 限制。这样可以防止用户创建非托管二级用户。此外，<code>CreateUser()</code> 和 <code>createAndInitializeUser()</code> 方法已弃用，取而代之的是 <code>DevicePolicyManager.createAndManageUser()</code> 方法。</li><li>设备所有者可以访问设备标识符。设备所有者可以使用 <code>DevicePolicyManagewr.getWifiMacAddress()</code> 访问设备的 WLAN MAC 地址。如果设备上从未启用 WLAN，则此方法将返回一个 null 值。</li><li>工作模式设置控制工作应用访问。当工作模式关闭时，系统启动器通过使工作应用显示为灰色来指示它们不可用。启用工作模式会再次恢复正常行为。</li><li>从 Settings UI 安装包含客户端证书链和对应的私钥的 PKCS #12 文件时，系统不再将该证书链中的 CA 证书安装到受信任的凭据存储空间。当应用稍后尝试检索客户端证书链时，这不会影响 <code>KeyChain.getCertificateChain()</code> 的结果。如果需要，使用 .crt 或 .cer 文件扩展名的 DER 编码格式通过 Settings UI 单独将 CA 证书安装到受信任的凭据存储空间。</li><li>从 Android 7.0 开始，可针对每个用户管理指纹登记和存储空间。如果配置文件所有者的设备规范客户端 (DPC) 面向 Android N 设备上的 Android N 之前的版本，则用户仍可以在该设备上设置指纹，但工作应用不能访问设备指纹。当 DPC 面向 Android N 和更高版本时，用户可以通过转到 <strong>Settings &gt; Security &gt; Work profile security</strong> 专门为托管配置文件设置指纹。</li><li><code>DevicePolicyManager.getStorageEncryptionStatus()</code> 返回新的加密状态 <code>ENCRYPTION_STATUS_ACTIVE_PER_USER</code>，以表明加密处于活动状态，且加密密钥与用户关联。仅当 DPC 面向 API 级别 24 和更高级别时才会返回新的状态。对于面向更早的 API 级别的应用，即使加密密钥是用户或配置文件特有的，系统也会返回 <code>ENCRYPTION_STATUS_ACTIVE</code>。</li><li>在 Android 7.0 中，如果设备通过单独的工作挑战安装了托管配置文件，则原本通常会影响整个设备的多个方法将会改变其行为方式。这些方法将仅应用于托管配置文件，而不是影响整个设备。（此类方法的完整列表位于 <code>DevicePolicyManager.getParentProfileInstance()</code> 文档中。）例如，<code>DevicePolicyManager.lockNow()</code> 只锁定托管配置文件，而不是锁定整个设备。对于上述每个方法，您可以通过对 DevicePolicyManager 的父实例调用该方法来获取以前的行为；您可以通过调用 <code>DevicePolicyManager.getParentProfileInstance()</code> 获取此父项。例如，如果您调用父实例的 <code>lockNow()</code> 方法，则整个设备将被锁定。</li></ul><p>如需了解有关 Android 7.0 中针对 Android for Work 所做变更的详细信息，请参阅 Android for Work 更新。</p><h1 id="注解保留"><a href="#注解保留" class="headerlink" title="注解保留"></a>注解保留</h1><hr><p>Android 7.0 修复了一个注解可见性被忽略的错误。这种问题会导致应用可在运行时访问原本不允许访问的注解。这些注解包括：</p><ul><li><code>VISIBILITY_BUILD</code>：仅应编译时可见。</li><li><code>VISIBILITY_SYSTEM</code>：运行时应可见，但仅限底层系统。<br>如果您的应用依赖这种行为，请为运行时必须可用的注解添加保留政策。您可通过使用 <code>@Retention(RetentionPolicy.RUNTIME)</code> 来执行此操作。</li></ul><h1 id="其他重要说明"><a href="#其他重要说明" class="headerlink" title="其他重要说明"></a>其他重要说明</h1><hr><ul><li><p>如果一个应用在 Android 7.0 上运行，但却是针对更低 API 级别开发的，那么在用户更改显示尺寸时，系统将终止此应用进程。应用必须能够妥善处理此情景。否则，当用户从最近使用记录中恢复运行应用时，应用将会出现崩溃现象。<br>您应测试应用以确保不会发生此行为。要进行此测试，您可以通过 DDMS 手动终止应用，以造成相同的崩溃现象。<br>在密度发生更改时，系统不会自动终止面向 N 及更高版本的应用；不过，这些应用仍可能对配置变更做出不良响应。</p></li><li><p>Android 7.0 上的应用应能够妥善处理配置变更，并且在后续启动时不会出现崩溃现象。您可以通过更改字体大小 <code>(Setting &gt;Display &gt; Font size)</code> 并随后从最近使用记录中恢复运行应用，来验证应用行为。</p></li><li>由于之前的 Android 版本中的一项错误，系统未能将对主线程上的一个 TCP 套接字的写入操作举报为违反严格模式。Android 7.0 修复了此错误。呈现出这种行为的应用现在会引发 <code>android.os.NetworkOnMainThreadException</code>。一般情况下，我们不建议在主线程上执行网络操作，因为这些操作通常会出现可能导致 ANR 和卡顿的高尾延迟。</li><li><code>Debug.startMethodTracing()</code> 方法系列现在默认在您的共享存储空间上的软件包特定目录中存储输出，而非 SD 卡根目录。这意味着应用不再需要请求 <code>WRITE_EXTERNAL_STORAGE</code> 权限来使用这些 API 。</li><li>许多平台 API 现在开始检查在 <code>Binder</code> 事务间发送的大负载，系统现在会将 <code>TransactionTooLargeExceptions</code> 作为 RuntimeExceptions 再次引发，而不再只是默默记录或抑制它们。一个常见例子是在 <code>Activity.onSaveInstanceState()</code> 上存储过多数据，导致 ActivityThread.StopInfo 在您的应用面向 Android 7.0 时引发 RuntimeException。</li><li>如果应用向 View 发布 <code>Runnable</code> 任务，并且 View 未附加到窗口，系统会用 View 为 <code>Runnable</code> 任务排队；在 View 附加到窗口之前，不会执行 <code>Runnable</code> 任务。此行为会修复以下错误：<ul><li>如果一项应用是从并非预期窗口 UI 线程的其他线程发布到 View，则 <code>Runnable</code> 可能会因此运行错误的线程。</li><li>如果 <code>Runnable</code> 任务是从并非环路线程的其他线程发布，则应用可能会曝光 Runnable 任务。</li></ul></li><li>如果 Android 7.0 上一项有 <code>DELETE_PACKAGES</code> 权限的应用尝试删除一个软件包，但另一项应用已经安装了这个软件包，则系统需要用户进行确认。在这种情况下，应用在调用 <code>PackageInstaller.uninstall()</code> 时预计的返回状态应为 <code>STATUS_PENDING_USER_ACTION</code>。</li><li>名为 Crypto 的 JCA 提供程序已弃用，因为它仅有的 SHA1PRNG 算法为弱加密。应用无法再使用 SHA1PRNG（不安全地）派生密钥，因为不再提供此提供程序。如需了解详细信息，请参阅博文 <a href="http://android-developers.blogspot.com/2016/06/security-crypto-provider-deprecated-in.html" target="_blank" rel="noopener">Android N 中已弃用“Crypto”安全提供程序</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 7.0 除了提供诸多新特性和功能外，还对系统和 API 行为做出了各种变更。本文重点介绍您应该了解并在开发应用时加以考虑的一些主要变更。&lt;/p&gt;
&lt;p&gt;如果您之前发布过 Android 应用，请注意您的应用可能受到这些平台变化的影响。&lt;/p&gt;
&lt;h1 id=
      
    
    </summary>
    
    
      <category term="Anroid" scheme="http://yoursite.com/tags/Anroid/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
      <category term="Nougat" scheme="http://yoursite.com/tags/Nougat/"/>
    
      <category term="Anroid7.0" scheme="http://yoursite.com/tags/Anroid7-0/"/>
    
  </entry>
  
  <entry>
    <title>Android 7.0 API 概览</title>
    <link href="http://yoursite.com/2016/12/30/android-7-0/"/>
    <id>http://yoursite.com/2016/12/30/android-7-0/</id>
    <published>2016-12-30T06:12:49.000Z</published>
    <updated>2018-03-30T06:23:38.937Z</updated>
    
    <content type="html"><![CDATA[<p>Android 7.0 Nougat 为用户和开发者引入多种新功能。本文重点介绍面向开发者的新功能。</p><p>请务必查阅 Android 7.0 行为变更以了解平台变更可能影响您的应用的领域。</p><p>要详细了解 Android 7.0 的消费者功能，请访问 <a href="https://www.android.com" target="_blank" rel="noopener">www.android.com</a>。</p><h1 id="多窗口支持"><a href="#多窗口支持" class="headerlink" title="多窗口支持"></a>多窗口支持</h1><hr><p>在 Android 7.0 中，我们为该平台引入了一个新的而且非常需要的多任务处理功能 — 多窗口支持。</p><p>现在，用户可以一次在屏幕上打开两个应用。</p><ul><li>在运行 Android 7.0 的手机和平板电脑上，用户可以并排运行两个应用，或者处于分屏模式时一个应用位于另一个应用之上。用户可以通过拖动两个应用之间的分隔线来调整应用。</li><li>在 Android TV 设备上，应用可以将自身置于画中画模式，从而让它们可以在用户浏览或与其他应用交互时继续显示内容。<br><p style="overflow:hidden"><br><img src="/2016/12/30/android-7-0/mw-portrait.png" style="width:200px;float:left;margin-right:40px"><br><span><br>多窗口支持为您提供新的吸引用户方式，特别是在平板电脑和其他更大屏幕的设备上。您甚至可以在您的应用中启用拖放，从而使用户可以方便地将内容拖放到您的应用或从其中拖出内容—这是一个非常好的增强用户体验的方式。<br><br><br><br>向您的应用添加多窗口支持并配置多窗口显示的处理方式非常简单。例如，您可以指定您的 Activity 允许的最小尺寸，从而防止用户将 Activity 调整到该尺寸以下。您还可以为应用停用多窗口显示，这可确保系统将仅以全屏模式显示应用。<br><br><br><br></span></p></li></ul><p></p><p></p><h1 id="通知增强功能"><a href="#通知增强功能" class="headerlink" title="通知增强功能"></a>通知增强功能</h1><hr><p>在 Android 7.0 中，我们重新设计了通知，使其更易于使用并且速度更快。部分变更包括：</p><ul><li><strong>模板更新：</strong>我们正在更新通知模板，新强调了英雄形象和化身。开发者将能够充分利用新模板，只需进行少量的代码调整。</li><li><strong>消息传递样式自定义：</strong>您可以自定义更多与您的使用 MessagingStyle 类的通知相关的用户界面标签。您可以配置消息、会话标题和内容视图。</li><li><strong>捆绑通知：</strong>系统可以将消息组合在一起（例如，按消息主题）并显示组。用户可以适当地进行拒绝或归档等操作。如果您已实现 Android Wear 的通知，那么您已经很熟悉此模式。</li><li><strong>直接回复：</strong>对于实时通信应用，Android 系统支持内联回复，以便用户可以直接在通知界面中快速回复短信。</li><li><strong>自定义视图：</strong>两个新的 API 让您在通知中使用自定义视图时可以充分利用系统装饰元素，如通知标题和操作。<br><img src="/2016/12/30/android-7-0/notifications-1.png" style="width:30%; margin:10px; float:left;"> <img src="/2016/12/30/android-7-0/notifications-3.png" style="width:30%; margin:10px; float:left;"><img src="/2016/12/30/android-7-0/notifications-2.png" style="width:30%; margin:10px;"><br>图 2. 绑定的通知和直接回复。</li></ul><p>要了解如何实现新功能的信息，请参阅<a href="https://developer.android.com/preview/features/notification-updates.html" target="_blank" rel="noopener">通知</a>指南。</p><h1 id="配置文件指导的-JIT-AOT-编译"><a href="#配置文件指导的-JIT-AOT-编译" class="headerlink" title="配置文件指导的 JIT/AOT 编译"></a>配置文件指导的 JIT/AOT 编译</h1><hr><p>在 Android 7.0 中，我们添加了即时 (JIT) 编译器，对 ART 进行代码分析，让它可以在应用运行时持续提升 Android 应用的性能。JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。</p><p>配置文件指导的编译让 Android 运行组件能够根据应用的实际使用以及设备上的情况管理每个应用的 AOT/JIT 编译。例如，Android 运行组件维护每个应用热方法的配置文件，并且可以预编译和缓存这些方法以实现最佳性能。对于应用的其他部分，在实际使用之前不会进行编译。</p><p>除提升应用的关键部分的性能外，配置文件指导的编译还有助于减少整个 RAM 占用，包括关联的二进制文件。此功能对于低内存设备非常尤其重要。</p><p>Android 运行组件在管理配置文件指导的编译时，可最大程度降低对设备电池的影响。仅当设备处于空闲状态和充电时才进行编译，从而可以通过提前执行该工作节约时间和省电。</p><h1 id="快速的应用安装路径"><a href="#快速的应用安装路径" class="headerlink" title="快速的应用安装路径"></a>快速的应用安装路径</h1><hr><p>Android 运行组件的 JIT 编译器最实际的好处之一是应用安装和系统更新的速度。即使在 Android 6.0 中需要几分钟进行优化和安装的大型应用，现在只需几秒钟就可以完成安装。系统更新也变得更快，因为省去了优化步骤。</p><h1 id="随时随地低电耗模式…"><a href="#随时随地低电耗模式…" class="headerlink" title="随时随地低电耗模式…"></a>随时随地低电耗模式…</h1><hr><p>Android 6.0 推出了低电耗模式，即设备处于空闲状态时，通过推迟应用的 CPU 和网络活动以实现省电目的的系统模式，例如，设备放在桌上或抽屉里时。</p><p>现在，在 Android 7.0 中，低电耗模式又前进了一步，随时随地可以省电。只要屏幕关闭了一段时间，且设备未插入电源，低电耗模式就会对应用使用熟悉的 CPU 和网络限制。这意味着用户即使将设备放入口袋里也可以省电。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://developer.android.com/images/android-7.0/doze-diagram-1.png" alt="dd" title="">                </div>                <div class="image-caption">dd</div>            </figure><p>图 3. 低电耗模式现在应用限制以延长电池寿命，即使设备未处于静止状态。</p><p>屏幕关闭片刻后，设备在使用电池时，低电耗模式将限制网络访问，同时延迟作业和同步。在短暂的维护时间范围后，其允许应用访问网络，并执行延迟的作业/同步。打开屏幕或将设备插入电源会使设备退出低电耗模式。</p><p>当设备再次处于静止状态时，屏幕关闭且使用电池一段时间，低电耗模式针对 <code>PowerManager.WakeLock</code>、<code>AlarmManager</code> 警报和 GPS/WLAN 扫描应用完整 CPU 和网络限制。</p><p>无论设备是否处于运动状态，将应用调整到低电耗模式的最佳做法均相同，因此，如果您已更新应用以妥善处理低电耗模式，则一切就绪。如果不是，请立即开始<a href="https://developer.android.com/training/monitoring-device-state/doze-standby.html#assessing_your_app" target="_blank" rel="noopener">将应用调整到低电耗模式</a></p><h1 id="Project-Svelte：后台优化"><a href="#Project-Svelte：后台优化" class="headerlink" title="Project Svelte：后台优化"></a>Project Svelte：后台优化</h1><hr><p>Project Svelte 在持续改善，以最大程度减少生态系统中一系列 Android 设备中系统和应用使用的 RAM。在 Android 7.0 中，Project Svelte 注重优化在后台中运行应用的方式。</p><p>后台处理是大多数应用的一个重要部分。处理得当，可让您实现非常棒的用户体验 — 即时、快速和情境感知。如果处理不得当，后台处理会毫无必要地消耗 RAM（和电池），同时影响其他应用的系统性能。</p><p>自 Android 5.0 发布以来，<code>JobScheduler</code> 已成为执行后台工作的首选方式，其工作方式有利于用户。应用可以在安排作业的同时允许系统基于内存、电源和连接情况进行优化。<code>JobScheduler</code> 可实现控制和简洁性，我们想要所有应用都使用它。</p><p>另一个非常好的选择是 <code>GCMNetworkManager</code>（Google Play 服务的一部分），其在旧版 Android 中提供类似的作业安排和兼容性。</p><p>我们在继续扩展 <code>JobScheduler</code> 和 <code>GCMNetworkManager</code>，以符合多个用例 — 例如，在 Android 7.0 中，现在，您可以基于内容提供程序中的更改安排后台工作。同时，我们开始弃用一些较旧的模式，这些模式会降低系统性能，特别是低内存设备的系统性能。</p><p>在 Android 7.0 中，我们删除了三个常用隐式广播 — <code>CONNECTIVITY_ACTION</code>、<code>ACTION_NEW_PICTURE</code> 和<code>ACTION_NEW_VIDEO</code> — 因为这些广播可能会一次唤醒多个应用的后台进程，同时会耗尽内存和电池。如果您的应用收到这些广播，请充分利用 Android 7.0 以迁移到 JobScheduler 和相关的 API。</p><p>如需了解详情，请查看<a href="https://developer.android.com/preview/features/background-optimization.html" target="_blank" rel="noopener">后台优化</a>文档。</p><h1 id="SurfaceView"><a href="#SurfaceView" class="headerlink" title="SurfaceView"></a>SurfaceView</h1><hr><p>Android 7.0 可同步移动到 <code>SurfaceView</code> 类，此类在某些情况下提供的电池性能优于 <code>TextureView</code>：在渲染视频或 3D 内容时，包含滚动和动画视频位置的应用在使用 <code>SurfaceView</code> 时比 <code>TextureView</code> 耗电更少。</p><p><code>SurfaceView</code> 类可减少屏幕合成对电池的消耗，因为它是在专用硬件中合成，与应用窗口内容分隔开。因此，它产生的中间副本少于 TextureView。<br>现在，<code>SurfaceView</code> 对象的内容位置和包含的应用内容同步更新。这一变化导致的一个结果是，在画面移动时，SurfaceView 中播放的视频的简单的平移或缩放不再在画面侧面产生黑条。</p><p>从 Android 7.0 开始，我们强烈建议您使用 <code>SurfaceView</code> 代替 <code>TextureView</code>，以实现省电。</p><h1 id="流量节省程序"><a href="#流量节省程序" class="headerlink" title="流量节省程序"></a>流量节省程序</h1><hr><p style="overflow:hidden"><br><img src="/2016/12/30/android-7-0/datasaver.png" style="width:50%;float:left;margin-right:40px"><br><span style="font-size:14px"><br>在移动设备的整个生命周期，移动数据网络计划的成本通常会超出设备本身的成本。对于许多用户而言，移动数据网络是他们想要节省的昂贵资源。<br><br><br>Android 7.0 推出了流量节省模式，这是一项新的系统服务，有助于减少应用使用的移动数据网络，无论是在漫游，账单周期即将结束，还是使用少量的预付费数据包。流量节省程序让用户可以控制应用使用移动数据网络的方式，同时让开发者打开流量节省程序时可以提供更多有效的服务。<br><br><br>用户在 Settings 中启用流量节省程序且设备位于按流量计费的网络上时，系统屏蔽后台流量消耗，同时指示应用在前台尽可能使用较少的流量 — 例如，通过限制用于流媒体服务的比特率、降低图像质量、延迟最佳的预缓冲等方法来实现。用户可以将特定应用加入白名单以允许后台按流量计费的流量消耗，即使在打开流量节省程序时也是如此。<br><br><br>Android 7.0 扩展了 ConnectivityManager，以便为应用检索用户的流量节省程序首选项并监控首选项变更提供一种方式。所有应用均应检查用户是否已启用流量节省程序并努力限制前台和后台流量消耗。<br></span><br></p><h1 id="Vulkan-API"><a href="#Vulkan-API" class="headerlink" title="Vulkan API"></a>Vulkan API</h1><hr><p>Android 7.0 将一项新的 3D 渲染 API <a href="http://www.khronos.org/vulkan" target="_blank" rel="noopener">Vulkan™</a> 集成到平台中。就像 <a href="https://www.khronos.org/opengles/" target="_blank" rel="noopener">OpenGL™</a> ES 一样，Vulkan 是 3D 图形和渲染的一项开放标准，由 Khronos Group 维护。</p><p>Vulkan 是完全从零开始设计，以最小化驱动器中的 CPU 开销，并能让您的应用更直接地控制 GPU 操作。Vulkan 还允许多个线程同时执行工作，如命令缓冲区构建，以获得更好的并行化。</p><p>Vulkan 开发工具和库都已卷入 Android 7.0DK。它们包括：</p><ul><li>标头</li><li>验证层（调试库）</li><li>SPIR-V 着色程序编译器</li><li>SPIR-V 运行时着色器编译库</li></ul><p>Vulkan 仅适用于已启用 Vulkan 硬件的设备上的应用，如 Nexus 5X、Nexus 6P 和 Nexus Player。我们正在与合作伙伴密切合作，以尽快使 Vulkan 能面向更多的设备。</p><p>如需了解详细信息，请参阅 <a href="https://developer.android.com/ndk/guides/graphics/index.html" target="_blank" rel="noopener">API 文档</a>。</p><h1 id="Quick-Settings-Tile-API"><a href="#Quick-Settings-Tile-API" class="headerlink" title="Quick Settings Tile API"></a>Quick Settings Tile API</h1><hr><p><img src="/2016/12/30/android-7-0/quicksettings.png" style="width:260px; float:right; margin-left:20px"></p><p>“快速设置”通常用于直接从通知栏显示关键设置和操作，非常简单。在 Android 7.0 中，我们已扩展“快速设置”的范围，使其更加有用更方便。</p><p>我们为额外的“快速设置”图块添加了更多空间，用户可以通过向左或向右滑动跨分页的显示区域访问它们。我们还让用户可以控制显示哪些“快速设置”图块以及显示的位置 — 用户可以通过拖放图块来添加或移动图块。</p><p>对于开发者，Android 7.0 还添加了一个新的 API，从而让您可以定义自己的“快速设置”图块，使用户可以轻松访问您应用中的关键控件和操作。</p><p>对于急需或频繁使用的控件和操作，保留“快速设置”图块，且不应将其用作启动应用的快捷方式。</p><p>定义图块后，您可以将它们显示给用户，用户可通过拖放将图块添加到“快速设置”。</p><p>如需了解有关创建应用图块的信息，请参阅可下载的 API 参考中的文件 android.service.quicksettings.Tile。</p><h1 id="号码屏蔽"><a href="#号码屏蔽" class="headerlink" title="号码屏蔽"></a>号码屏蔽</h1><hr><p>Android 7.0 现在支持在平台中进行号码屏蔽，提供框架 API，让服务提供商可以维护屏蔽的号码列表。默认短信应用、默认手机应用和运营商应用可以对屏蔽的号码列表进行读取和写入操作。其他应用则无法访问此列表。</p><p>通过使号码屏蔽成为平台的标准功能，Android 为应用提供一致的方式来支持广泛的设备上的号码屏蔽。应用可以利用的其他优势包括：</p><ul><li>还会屏蔽已屏蔽的来电号码发出的短信</li><li>通过 Backup &amp; Restore（备份和还原）功能可以跨重置和设备保留屏蔽的号码</li><li>多个应用可以使用相同的屏蔽号码列表</li></ul><p>此外，通过 Android 的运营商应用集成表示运营商可以读取设备上屏蔽的号码列表，并为用户执行服务端屏蔽，以阻止不需要的来电和短信通过任何介质（如 VOIP 端点或转接电话）到达用户。</p><p>如需了解详细信息，请参阅可下载的 <a href="https://developer.android.com/preview/setup-sdk.html#docs-dl" target="_blank" rel="noopener">API 参考</a>中的 <code>android.provider.BlockedNumberContract</code>。</p><h1 id="来电过滤"><a href="#来电过滤" class="headerlink" title="来电过滤"></a>来电过滤</h1><hr><p>Android 7.0 允许默认的手机应用过滤来电。手机应用执行此操作的方式是实现新的 <code>CallScreeningService</code>，该方法允许手机应用基于来电的 <code>Call.Details</code> 执行大量操作，例如：</p><ul><li>拒绝来电</li><li>不允许来电到达通话记录</li><li>不向用户显示来电通知</li></ul><p>如需了解详细信息，请参阅可下载的 <a href="https://developer.android.com/preview/setup-sdk.html#docs-dl" target="_blank" rel="noopener">API 参考</a>中的 <code>android.telecom.CallScreeningService</code>。</p><h1 id="多语言区域支持，更多语言"><a href="#多语言区域支持，更多语言" class="headerlink" title="多语言区域支持，更多语言"></a>多语言区域支持，更多语言</h1><hr><p>Android 7.0 现在允许用户在设置中选择多个语言区域，以更好地支持双语用例。应用可以使用新的 API 获取用户选择的语言区域，然后为多区域设置用户提供更成熟的用户体验 — 如以多个语言显示搜索结果，并且不会以用户了解的语言翻译网页。</p><p>除多语言区域支持外，Android 7.0 还扩展了用户可用的语言范围。它针对常用语言提供超过 25 种的变体，如英语、西班牙语、法语和阿拉伯语。它还针对 100 多种新语言添加了部分支持。</p><p>应用可以通过调用 <code>LocaleList.GetDefault()</code> 获取用户设置的语言区域列表。为支持扩展的语言区域数量，Android 7.0 正在改变其解析资源的方式。请务必使用新的资源解析逻辑测试和验证您的应用是否能如期运行。</p><p>要了解新资源解析行为和应遵循的最佳做法，请参阅<a href="https://developer.android.com/preview/features/multilingual-support.html" target="_blank" rel="noopener">多语言支持</a>。</p><h1 id="新增的表情符号"><a href="#新增的表情符号" class="headerlink" title="新增的表情符号"></a>新增的表情符号</h1><hr><p>Android 7.0 引入更多表情符号和表情符号相关功能，包括肤色表情符号和支持变量选择符。如果您的应用支持表情符号，请遵循以下准则，以便能充分利用这些表情符号相关功能优势。</p><ul><li><strong>在插入之前，检查设备是否包含表情符号。</strong>要检查系统字体中有哪些表情符号，使用 <code>hasGlyph(String)</code> 方法。</li><li><strong>检查表情符号是否支持变量选择符。</strong>变量选择符使您能够呈现一些彩色或黑白的表情符号。在移动设备上，应用应呈现彩色的表情符号，而不是黑白的。但是，如果您的应用显示嵌入在文本中的表情符号，那应使用黑白变量。要确定表情符号是否有变量，使用变量选择符。如需有关支持变量的字符的完整清单，请参阅<a href="http://www.unicode.org/Public/9.0.0/ucd/StandardizedVariants-9.0.0d1.txt" target="_blank" rel="noopener">变量的 Unicode 文档</a>中的表情符号变量序列部分。</li><li><strong>检查表情符号是否支持肤色。</strong>Android 7.0 允许用户按照他们的喜好修改表情符号呈现的肤色。键盘应用应为有多个肤色的表情符号提供可视化的指示，并应允许用户选择他们喜欢的肤色。要确定哪些系统表情符号有肤色修改器，使用 <code>hasGlyph(String)</code> 方法。您可以通过读取 Unicode 文档来确定哪些表情符号使用肤色。<h1 id="Android-中的-ICU4J-API"><a href="#Android-中的-ICU4J-API" class="headerlink" title="Android 中的 ICU4J API"></a>Android 中的 ICU4J API</h1></li></ul><hr><p>Android 7.0 目前在 Android 框架（位于 android.icu 软件包下）中提供 <code>ICU4J</code> API 的子集。迁移很简单，主要是需要从 com.java.icu 命名空间更改为 android.icu。如果您已在您的应用中使用 ICU4J 捆绑包，切换到 Android 框架中提供的 android.icu API 可以大量节省 APK 大小。</p><p>要详细了解 Android ICU4J API，请参阅 <a href="https://developer.android.com/preview/features/icu4j-framework.html" target="_blank" rel="noopener">ICU4J 支持</a>。</p><h1 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h1><hr><h2 id="Chrome-和-WebView-配合使用"><a href="#Chrome-和-WebView-配合使用" class="headerlink" title="Chrome 和 WebView 配合使用"></a>Chrome 和 WebView 配合使用</h2><p>从 Android 7.0 及更高版本中的 Chrome 版本 51 开始，您的设备中的 Chrome APK 用于提供和渲染 Android 系统 WebView。这种方法改善了设备本身的内存使用率，同时减少保持 WebView 更新所需的带宽（因为只要保持启用 Chrome，单机版 WebView APK 将不再进行更新）。</p><p>您可以启用开发者选项和选择 WebView 实现，选择您的 WebView 提供商。您可以使用设备上安装的任何兼容的 Chrome 版本（Dev、Beta 或 Stable）或单机版 Webview APK，作为 WebView 实现。</p><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><p>从 Android 7.0 中的 Chrome 版本 51 开始，WebView 将开发者选项“多进程 WebView”被启用时，在一个单独的沙盒进程中运行网页内容。</p><p>我们正在寻求关于 N 中的兼容性和运行时性能的反馈，并随后将在未来 Android 版本中启用多进程 WebView。在这个版本中，可预期启动时间回归、总内存使用和软件渲染性能。</p><p>如果您在多进程模式中遇到意外问题，请告诉我们。请通过 Chromium 错误跟踪程序联系 WebView 团队。</p><h2 id="Javascript-在页面加载之前运行"><a href="#Javascript-在页面加载之前运行" class="headerlink" title="Javascript 在页面加载之前运行"></a>Javascript 在页面加载之前运行</h2><p>从以 Android 7.0 为目标平台的应用开始，JavaScript 上下文会在加载新页面时重置。目前，新 WebView 实例中加载的第一个页面会继承上下文。</p><p>想要在 WebView 中注入 Javascript 的开发者应在页面开始加载后执行脚本。</p><h2 id="不安全起点上的地理定位"><a href="#不安全起点上的地理定位" class="headerlink" title="不安全起点上的地理定位"></a>不安全起点上的地理定位</h2><p>从以 Android 7.0 为目标平台的应用开始，地理定位 API 将仅在安全的起点（通过 HTTPS）上被允许。此政策的目的是在用户使用不安全连接时保护他们的私人信息。</p><h2 id="测试-WebView-测试版"><a href="#测试-WebView-测试版" class="headerlink" title="测试 WebView 测试版"></a>测试 WebView 测试版</h2><p>WebViewis 定期更新，因此我们建议您经常使用 WebView 的测试版本测试应用的兼容性。要在 Android 7.0 上着手测试 WebView 的预发布版本，请下载并安装 Chrome Dev 或 Chrome 测试版，然后按上述说明在开发者选项下面选择它作为 WebView 实现。请通过 Chromium 错误跟踪程序报告问题，以便我们可以在发布新的 WebView 版本前修复问题。</p><p>如果您遇到其他任何问题，可随时通过我们的 G+ 社区与 WebView 团队联系。</p><h1 id="OpenGL™-ES-3-2-API"><a href="#OpenGL™-ES-3-2-API" class="headerlink" title="OpenGL™ ES 3.2 API"></a>OpenGL™ ES 3.2 API</h1><hr><p>Android 7.0 添加了框架接口和对 OpenGL ES 3.2 的平台支持，包括：</p><ul><li>来自 <a href="https://www.khronos.org/registry/gles/extensions/ANDROID/ANDROID_extension_pack_es31a.txt" target="_blank" rel="noopener">Android 扩展包</a> (AEP) 的所有扩展（EXT_texture_sRGB_decode 除外）。</li><li>针对 HDR 的浮点帧缓冲和延迟着色。</li><li>BaseVertex 绘图调用可实现更好的批处理和流媒体服务。</li><li>强大的缓冲区访问控制可减少 WebGL 开销。</li></ul><p>Android 7.0 上适用于 OpenGL ES 3.2 的框架 API 与 GLES32 类一起提供。使用 OpenGL ES 3.2 时，请务必通过 <code>&lt;uses-feature&gt;</code> 标记和 <code>android:glEsVersion</code> 属性在您的清单文件中声明要求。</p><p>如需了解有关使用 OpenGL ES 的信息，包括如何在运行时检查设备支持的 OpenGL ES 版本，请参阅 OpenGL ES API 指南。</p><h1 id="Android-TV-录制"><a href="#Android-TV-录制" class="headerlink" title="Android TV 录制"></a>Android TV 录制</h1><hr><p>Android 7.0 通过新的录制 API 添加了从 Android TV 输入服务录制和播放内容的功能。构建在现有时移 API 之上，TV 输入服务可以控制能够录制的渠道数据、保存录制的会话的方式，同时可通过录制的内容管理用户交互。</p><p>如需了解详细信息，请参阅 <a href="https://developer.android.com/preview/features/tv-recording-api.html" target="_blank" rel="noopener">Android TV Recording API</a>。</p><h1 id="Android-for-Work"><a href="#Android-for-Work" class="headerlink" title="Android for Work"></a>Android for Work</h1><hr><p>Android for Work 针对运行 Android 7.0 的设备添加了许多新功能和 API。部分重要内容如下— 有关变更的完整列表，请参阅 <a href="https://developer.android.com/preview/features/afw.html" target="_blank" rel="noopener">Android for Work 更新</a>。</p><h2 id="工作资料安全性挑战"><a href="#工作资料安全性挑战" class="headerlink" title="工作资料安全性挑战"></a>工作资料安全性挑战</h2><p>面向 N SDK 的配置文件所有者可以为在工作资料中运行的应用指定单独的安全性挑战。当用户尝试打开任何工作应用时将显示工作挑战。成功完成安全性挑战可解锁工作资料并将其解密（如果需要）。对于配置文件所有者，<code>ACTION_SET_NEW_PASSWORD</code> 提示用户设置工作挑战，<code>ACTION_SET_NEW_PARENT_PROFILE_PASSWORD</code> 提示用户设置设备锁。</p><p>配置文件所有者可以使用 <code>setPasswordQuality()</code>、<code>setPasswordMinimumLength()</code> 和相关方法针对工作挑战设置不同的密码策略（例如，PIN 码必须多长，或是否可以使用指纹解锁配置文件）。配置文件所有者还可以使用新的 <code>getParentProfileInstance()</code> 方法返回的 <code>DevicePolicyManager</code> 实例设置设备锁定。此外，配置文件所有者可以使用新的 <code>setOrganizationColor()</code> 和 <code>setOrganizationName()</code> 方法针对工作挑战自定义凭据屏幕。</p><h2 id="关闭工作"><a href="#关闭工作" class="headerlink" title="关闭工作"></a>关闭工作</h2><p>在有工作资料的设备上，用户可以切换工作模式。工作模式关闭时，管理的用户临时关闭，其停用托管工作资料应用、后台同步和通知。这包括配置文件所有者应用。关闭工作模式时，系统显示永久状态图标，以提醒用户他们无法启动工作应用。启动器指示该工作应用和小部件无法访问。</p><h2 id="Always-on-VPN"><a href="#Always-on-VPN" class="headerlink" title="Always on VPN"></a>Always on VPN</h2><p>设备所有者和配置文件所有者可以确保工作应用始终通过指定的 VPN 连接。系统在设备启动后自动启动该 VPN。</p><p>新的 <code>DevicePolicyManager</code> 方法为 <code>setAlwaysOnVpnPackage()</code> 和 <code>getAlwaysOnVpnPackage()</code>。</p><p>由于 VPN 服务无需应用交互即可由系统直接绑定，因此，VPN 客户端必须针对 Always on VPN 处理新的入口点。和以前一样，由与操作 <code>android.net.VpnService</code> 匹配的 intent 过滤器将服务指示给系统。</p><p>用户还可以使用 <strong>Settings&gt;More&gt;Vpn</strong> 手动设置实现 <code>VPNService</code> 方法的 Always on VPN 客户端。通过“设置”启用 Always on VPN 的选项仅在 VPN 客户端以 API 级别 24 为目标时可用。</p><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>应用可以用企业颜色和徽标来自定义配置文件所有者和设备所有者配置流程。<code>DevicePolicyManager.EXTRA_PROVISIONING_MAIN_COLOR</code> 自定义流程颜色。<code>DevicePolicyManager.EXTRA_PROVISIONING_LOGO_URI</code> 用企业徽标自定义流程。</p><h1 id="无障碍增强功能"><a href="#无障碍增强功能" class="headerlink" title="无障碍增强功能"></a>无障碍增强功能</h1><hr><p>Android 7.0 现在针对新的设备设置直接在欢迎屏幕上提供“Vision Settings”。这使用户可以更容易发现和配置他们设备上的无障碍功能，包括放大手势、字体大小、显示屏尺寸和话语提示。</p><p>随着这些无障碍功能更为突出，在启用这些功能后，您的用户更可能试用您的应用。请务必提前启用这些设置测试您的应用。您可以通过 Settings &gt; Accessibility 启用它们。</p><p>还是在 Android 7.0 中，无障碍服务现在可以帮助具有动作障碍的用户触摸屏幕。全新的 API 允许使用人脸追踪、眼球追踪、点扫描等功能构建服务，以满足这些用户的需求。</p><p>如需了解详细信息，请参阅可下载的 <a href="https://developer.android.com/preview/setup-sdk.html#docs-dl" target="_blank" rel="noopener">API 参考</a>中的 <code>android.accessibilityservice.GestureDescription</code>。</p><h1 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h1><hr><p>直接启动可以缩短设备启动时间，让注册的应用具有有限的功能，即使在意外重启后。例如，如果当用户睡觉时加密的设备重启，那么注册的警报、消息和来电现在可以和往常一样继续通知用户。这也意味着重启后无障碍服务会立即可用。</p><p>在 Android 7.0 中，直接启动充分利用基于文件的加密，以针对系统和应用数据启用细化的加密策略。系统针对选定的系统数据和显式注册的应用数据使用设备加密存储。默认情况下，凭据加密存储可用于所有其他系统数据、用户数据、应用及应用数据。</p><p>启动时，系统在受限的模式中启动，仅访问设备加密数据，不会对应用或数据进行常规访问。如果您有想要在此模式下运行的组件，您可以通过在清单中设置标记注册它们。重启后，系统通过广播 LOCKED_BOOT_COMPLETED intent 激活注册的组件。系统确保注册的设备加密的应用数据在解锁前可用。所有其他数据在用户确认锁定屏幕凭据进行解密前均不可用。</p><p>如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/direct-boot.html" target="_blank" rel="noopener">直接启动</a>。</p><h1 id="密钥认证"><a href="#密钥认证" class="headerlink" title="密钥认证"></a>密钥认证</h1><hr><p>Android 7.0 引入密钥认证，这是一个新的安全工具，可帮助您确保设备的硬件支持的密钥库中存储的密钥对适当保护您的应用使用的敏感信息。借助此工具，您可以更加放心地让您的应用与驻留在安全硬件中的密钥交互，即使运行您的应用的设备已被破解 root 权限。如果您在应用中使用硬件支持的密钥库中的密钥，您应使用此工具，尤其当您使用密钥验证应用中的敏感信息时。</p><p>通过密钥认证，您可以在设备的可信执行环境 (TEE) 中验证在设备的硬件支持的密钥库中创建和存储的 RSA 或 EC 密钥对。通过此工具，您还可以使用设备服务，例如您的应用的后端服务器，确定和有效验证密钥对的使用和有效性。这些功能为保护密钥对提供额外的安全级别，即使有人破解设备的 root 权限或损害运行于设备的 Android 平台的安全。</p><blockquote><p><strong>注：</strong>仅少部分运行 Android 7.0 的设备支持硬件级密钥认证；其他所有运行 Android 7.0 的设备则使用软件级密钥认证。在生产级环境中验证设备的硬件支持的密钥之属性前，您应确保设备支持硬件级密钥认证。为此，您应确保认证证书链包含由 Google 认证根密钥签署的根证书，且密钥说明数据结构中的 attestationSecurityLevel 元素设置为 TrustedEnvironment 安全级别。</p></blockquote><p>如需了解详细信息，请参阅密钥认证开发者文档。</p><h1 id="网络安全性配置"><a href="#网络安全性配置" class="headerlink" title="网络安全性配置"></a>网络安全性配置</h1><hr><p>在 Android 7.0 中，通过使用说明性“网络安全性配置”（而不是使用传统的易出错的编程 API（例如，X509TrustManager）），应用可以安全地自定义其安全（HTTPS、TLS）连接的行为，无需任何代码修改。</p><p>支持的功能：</p><ul><li><strong>自定义信任锚。</strong>让应用可以针对安全连接自定义哪些证书颁发机构 (CA) 值得信赖。例如，信任特定的自签署证书或限制应用信任的公共 CA 集。</li><li><strong>仅调试重写。</strong>让应用开发者可以安全调试其应用的安全连接，而不会增加安装基础的风险。</li><li><strong>明文流量选择退出。</strong>让应用可以防止自身意外使用明文流量。</li><li><strong>证书固定。</strong>这是一项高级功能，让应用可以针对安全连接限制哪些服务器密钥受信任。</li></ul><p>如需了解详细信息，请参阅<a href="https://developer.android.com/preview/features/security-config.html" target="_blank" rel="noopener">网络安全性配置</a>。</p><h1 id="默认受信任的证书颁发机构"><a href="#默认受信任的证书颁发机构" class="headerlink" title="默认受信任的证书颁发机构"></a>默认受信任的证书颁发机构</h1><hr><p>默认情况下，面向 Android 7.0 的应用仅信任系统提供的证书，且不再信任用户添加的证书颁发机构 (CA)。如果面向 Android N 的应用希望信任用户添加的 CA，则应使用<a href="https://developer.android.com/preview/features/security-config.html" target="_blank" rel="noopener">网络安全性配置</a>以指定信任用户 CA 的方式。</p><h1 id="APK-signature-scheme-v2"><a href="#APK-signature-scheme-v2" class="headerlink" title="APK signature scheme v2"></a>APK signature scheme v2</h1><hr><p>Android 7.0 引入一项新的应用签名方案 APK Signature Scheme v2，它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。在默认情况下，Android Studio 2.2 和 Android Plugin for Gradle 2.2 会使用 APK Signature Scheme v2 和传统签名方案来签署您的应用。</p><p>虽然我们建议您对您的应用采用 APK Signature Scheme v2，但这项新方案并非强制性的。如果您的应用在使用 APK Signature Scheme v2 时不能正确开发，您可以停用这项新方案。禁用过程会导致 Android Studio 2.2 和 Android Plugin for Gradle 2.2 仅使用传统签名方案来签署您的应用。要仅用传统方案签署，打开模块级 <code>build.gradle</code> 文件，然后将行 v2SigningEnabled false 添加到您的版本签名配置中：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line">  defaultConfig &#123; ... &#125;</span><br><span class="line">  signingConfigs &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">      storeFile <span class="keyword">file</span>(<span class="string">"myreleasekey.keystore"</span>)</span><br><span class="line">      storePassword <span class="string">"password"</span></span><br><span class="line">      keyAlias <span class="string">"MyReleaseKey"</span></span><br><span class="line">      keyPassword <span class="string">"password"</span></span><br><span class="line">      v2SigningEnabled <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：</strong>如果您使用 APK Signature Scheme v2 签署您的应用，并对应用进行了进一步更改，则应用的签名将无效。出于这个原因，请在使用 APK Signature Scheme v2 签署您的应用之前、而非之后使用 zipalign 等工具。</p></blockquote><p>如需了解详细信息，请阅读相关的 Android Studio 文档，这些文档介绍了如何在 Android Studio 中签署应用以及如何使用 Android Plugin for Gradle <a href="https://developer.android.com/studio/build/build-variants.html#signing" target="_blank" rel="noopener">为签署应用配置构建文件</a>。</p><h1 id="作用域目录访问"><a href="#作用域目录访问" class="headerlink" title="作用域目录访问"></a>作用域目录访问</h1><hr><p>在 Android 7.0 中，应用可以使用新的 API 请求访问特定的外部存储目录，包括可移动媒体上的目录，如 SD 卡。新 API 大大简化了应用访问标准外部存储目录的方式，如 Pictures 目录。应用（如照片应用）可以使用这些 API（而不是使用 READ_EXTERNAL_STORAGE），其授予所有存储目录的访问权限或存储访问框架，从而让用户可以导航到目录。</p><p>此外，新的 API 简化了用户向应用授予外部存储访问权限的步骤。当您使用新的 API 时，系统使用一个简单的权限 UI，其清楚地详细介绍应用正在请求访问的目录。</p><p>如需了解详细信息，请参阅作用域目录访问开发者文档。</p><h1 id="键盘快捷键辅助工具"><a href="#键盘快捷键辅助工具" class="headerlink" title="键盘快捷键辅助工具"></a>键盘快捷键辅助工具</h1><hr><p>在 Android 7.0 中，用户可以按“Meta + /”触发“键盘快捷键”屏幕，它会显示的系统和对焦的应用中可用的所有快捷键。如果快捷键存在，系统自动从应用菜单检索这些快捷键。您也可以为屏幕提供微调的快捷键列表。您可以通过重写新 Activity.onProvideKeyboardShortcuts() 的方法来进行这项操作，如可下载的 API 参考中所述。</p><blockquote><p><strong>注：</strong>所有键盘都没有 Meta 键：在 Macintosh 键盘上，它是 Command 键；在 Windows 键盘上，它是 Windows 键；而在 Pixel C 和 Chrome 操作系统键盘上，它是 Search 键。</p></blockquote><p>要在您的应用的任何地方触发键盘快捷键辅助工具，为相关 Activity 调用 Activity.requestKeyboardShortcutsHelper()。</p><h1 id="Custom-Pointer-API"><a href="#Custom-Pointer-API" class="headerlink" title="Custom Pointer API"></a>Custom Pointer API</h1><hr><p>Android 7.0 引入 Custom Pointer API，以便您可以自定义指针的外观、 可见性和行为。此功能在用户使用鼠标或触控板与 UI 对象交互尤为有用。默认指针使用标准图标。此 API 还包含多种高级功能，例如根据鼠标或触控板特定移动情况改变指针图标外观。</p><p>要设置指针图标，请替换 View 类的 onResolvePointerIcon() 方法。此方法使用 PointerIcon 对象绘制与特定移动事件对应的图标。</p><h1 id="Sustained-Performance-API"><a href="#Sustained-Performance-API" class="headerlink" title="Sustained Performance API"></a>Sustained Performance API</h1><hr><p>长期运行的应用的性能可能会显著波动，因为系统会阻止系统芯片在设备组件达到温度限制时启动。这种波动是建立高性能长期运行应用的应用开发者的移动目标。</p><p>为解决这些限制，Android 7.0 包括了对持续性能模式的支持，帮助原始设备制造商 (OEM) 提供关于长期运行应用的设备性能能力的提示。应用开发者可以使用这些提示来根据可预测的一致设备性能水平调整长期应用。</p><p>应用开发者只能在 Nexus 6P 设备的 Android 7.0 中尝试这款新 API。要使用此功能，为您希望以持续性能模式运行的窗口设置持续性能窗口标记。使用 Window.setSustainedPerformanceMode() 方法设置此标记。当窗口不再对焦时，系统会自动停用此模式。</p><h1 id="VR-支持"><a href="#VR-支持" class="headerlink" title="VR 支持"></a>VR 支持</h1><hr><p>Android 7.0 添加了新的 VR 模式的平台支持和优化，以使开发者能为用户打造高质量移动 VR 体验。增加了一些性能增强特性，包括允许 VR 应用访问某个专属的 CPU 核心。在您的应用中，您可以充分利用到专为 VR 设计的智能头部跟踪和立体声通知功能。最重要的是，Android 7.0 的图形延时非常低。如需了解有关开发面向 Android 7.0 的 VR 应用的完整信息，请参阅<a href="https://developers.google.com/vr/android/" target="_blank" rel="noopener">面向 Android 的 Google VR SDK</a>。</p><h1 id="打印服务增强"><a href="#打印服务增强" class="headerlink" title="打印服务增强"></a>打印服务增强</h1><hr><p>在 Android 7.0 中，打印服务开发者现在可以公开关于个别打印机和打印作业的其他信息。</p><p>在列出各打印机时，打印服务现在可以通过两种方式来设置按打印机的图标：</p><ul><li>您可以通过调用 PrinterInfo.Builder.setResourceIconId() 设置源于资源 ID 的图标</li><li>您可以通过调用 PrinterInfo.Builder.setHasCustomPrinterIcon()，并针对使用 android.printservice.PrinterDiscoverySession.onRequestCustomPrinterIcon() 请求图标的情况设置回调来显示源自网络的图标</li></ul><p>此外，您还可以通过调用 PrinterInfo.Builder.setInfoIntent() 提供按打印机活动，以显示其他信息。</p><p>您可以通过分别调用 android.printservice.PrintJob.setProgress() 和 android.printservice.PrintJob.setStatus() 在打印任务通知中指示打印任务的进度和状态。</p><p>如需了解有关这些方法的详细信息，请参阅可下载的 <a href="https://developer.android.com/preview/setup-sdk.html#docs-dl" target="_blank" rel="noopener">API 参考</a>。</p><h1 id="FrameMetricsListener-API"><a href="#FrameMetricsListener-API" class="headerlink" title="FrameMetricsListener API"></a>FrameMetricsListener API</h1><hr><p>FrameMetricsListener API 允许应用监测它的 UI 渲染性能。API 通过公开流式传输 Pub/Sub API 来提供此能力，以传递应用当前窗口的帧计时信息。返回的数据相当于 adb shell dumpsys gfxinfo framestats 显示的数据，但不限定于在过去的 120 帧内。</p><p>您可以使用 <code>FrameMetricsListener</code> 来衡量生产中的交互级 UI 性能，无需 USB 连接。此 API 允许在比 adb shell dumpsys gfxinfo 更高的粒度上收集数据。因为系统可以从应用中的特定交互中收集数据，因此更高的粒度变得可行；系统不需要采集关于完整应用性能的全局概要或清除任何全局状态。您可以使用这种能力来针对应用的真实使用案例收集性能数据和捕捉 UI 性能回归。</p><p>要监测一个窗口，实现 <code>FrameMetricsListener.onMetricsAvailable()</code> 回调方法，并在窗口上注册。如需了解详细信息，请参阅可下载的 API 参考中的 FrameMetricsListener 类文档。</p><p>API 提供了一个包含计时数据的 <code>FrameMetrics</code> 对象，其渲染子系统会在一帧长度内报告各种里程碑。支持的指标有：<code>UNKNOWN_DELAY_DURATION</code>、<code>INPUT_HANDLING_DURATION</code>、<code>ANIMATION_DURATION</code>、<code>LAYOUT_MEASURE_DURATION</code>、<code>DRAW_DURATION</code>、 <code>SYNC_DURATION</code>、<code>COMMAND_ISSUE_DURATION</code>、<code>SWAP_BUFFERS_DURATION</code>、<code>TOTAL_DURATION</code> 和 <code>FIRST_DRAW_FRAME</code>。</p><h1 id="虚拟文件"><a href="#虚拟文件" class="headerlink" title="虚拟文件"></a>虚拟文件</h1><hr><p>在较早的 Android 版本中，您的应用可以使用存储访问框架来允许用户从他们的云存储帐户中选择文件，如 Google Drive。但是，不能表示没有直接字节码表示的文件；每个文件都必须提供一个输入流。</p><p>Android 7.0 在存储访问框架中添加了虚拟文件的概念。虚拟文件功能可以让您的 <code>DocumentsProvider</code> 返回可与 <code>ACTION_VIEW</code> intent 使用的文件 URI，即使它们没有直接字节码表示。Android 7.0 还允许您为用户文件（虚拟或其他类）提供备用格式。</p><p>为获得您的应用中的虚拟文件的 URI，首先您应创建一个 Intent 以打开文件选择器 UI。由于应用不能使用 <code>openInputStream()</code> 方法来直接打开一个虚拟文件，因此如果您包括了 CATEGORY_OPENABLE 类别，您的应用不会收到任何虚拟文件。</p><p>在用户选择之后，系统调用 <code>onActivityResult()</code> 方法。您的应用可以检索虚拟文件的 URI，并得到一个输入流，这表现在以下片段中的代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Other Activity code ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span> REQUEST_CODE = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We listen to the OnActivityResult event to respond to the user's selection.</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">    Intent resultData)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE &amp;&amp;</span><br><span class="line">            resultCode == Activity.RESULT_OK) &#123;</span><br><span class="line"></span><br><span class="line">            Uri uri = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (resultData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                uri = resultData.getData();</span><br><span class="line"></span><br><span class="line">                ContentResolver resolver = getContentResolver();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Before attempting to coerce a file into a MIME type,</span></span><br><span class="line">                <span class="comment">// check to see what alternative MIME types are available to</span></span><br><span class="line">                <span class="comment">// coerce this file into.</span></span><br><span class="line">                String[] streamTypes =</span><br><span class="line">                  resolver.getStreamTypes(uri, <span class="string">"*/*"</span>);</span><br><span class="line"></span><br><span class="line">                AssetFileDescriptor descriptor =</span><br><span class="line">                    resolver.openTypedAssetFileDescriptor(</span><br><span class="line">                        uri,</span><br><span class="line">                        streamTypes[<span class="number">0</span>],</span><br><span class="line">                        <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Retrieve a stream to the virtual file.</span></span><br><span class="line">                InputStream inputStream = descriptor.createInputStream();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        Log.e(<span class="string">"EXCEPTION"</span>, <span class="string">"ERROR: "</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>如需了解有关访问用户文件的详细信息，请参阅存储访问框架指南。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 7.0 Nougat 为用户和开发者引入多种新功能。本文重点介绍面向开发者的新功能。&lt;/p&gt;
&lt;p&gt;请务必查阅 Android 7.0 行为变更以了解平台变更可能影响您的应用的领域。&lt;/p&gt;
&lt;p&gt;要详细了解 Android 7.0 的消费者功能，请访问 &lt;
      
    
    </summary>
    
    
      <category term="Anroid" scheme="http://yoursite.com/tags/Anroid/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
      <category term="Nougat" scheme="http://yoursite.com/tags/Nougat/"/>
    
      <category term="Anroid7.0" scheme="http://yoursite.com/tags/Anroid7-0/"/>
    
  </entry>
  
  <entry>
    <title>Android 6.0 API 概述</title>
    <link href="http://yoursite.com/2016/04/30/android-6-0/"/>
    <id>http://yoursite.com/2016/04/30/android-6-0/</id>
    <published>2016-04-30T08:29:28.000Z</published>
    <updated>2018-03-30T08:31:33.078Z</updated>
    
    <content type="html"><![CDATA[<p>Android 6.0 (M) 为用户和应用开发者提供了新功能。本文旨在介绍其中最值得关注的 API。</p><h2 id="着手开发"><a href="#着手开发" class="headerlink" title="着手开发"></a>着手开发</h2><p>要着手开发 Android 6.0 应用，您必须先获得 Android SDK，然后使用 SDK 管理器下载 Android 6.0 SDK Platform 和系统映像。</p><h2 id="更新目标-API-级别"><a href="#更新目标-API-级别" class="headerlink" title="更新目标 API 级别"></a>更新目标 API 级别</h2><p>要进一步优化您的应用在运行 Android 的设备上的性能，请将您的 targetSdkVersion 设置为”23”，在 Android 系统映像上安装您的应用并进行测试，然后发布更新了此变更的应用。</p><p>您可以通过在代码中加入条件，在执行您的 minSdkVersion 不支持的 API 之前检查系统 API 级别，实现在使用 Android API 的同时仍为旧版本提供支持。要详细了解如何保持向后兼容性，请阅读支持不同平台版本。</p><p>如需了解有关 API 级别工作方式的详细信息，请阅读什么是 API 级别？</p><h1 id="指纹身份验证"><a href="#指纹身份验证" class="headerlink" title="指纹身份验证"></a>指纹身份验证</h1><hr><p>此版本提供了一些新的 API，在受支持的设备上，用户只需扫描其指纹即可完成身份验证，这些 API 还可与 <a href="https://developer.android.com/training/articles/keystore.html" target="_blank" rel="noopener">Android 密钥库系统</a>结合使用。</p><p>要通过指纹扫描验证用户身份，请获取新 <code>FingerprintManager</code> 类的实例，并调用 <code>authenticate()</code>方法。您的应用必须运行在带有指纹传感器的兼容设备上。您必须在应用中实现指纹身份验证流的用户界面，并在 UI 中使用标准 Android 指纹图标。<a href="https://developer.android.com/samples/FingerprintDialog/index.html" target="_blank" rel="noopener">FingerprintDialog 示例</a>中包含有 Android 指纹图标 (c_fp_40px.png)。请注意，如果您要开发多个使用指纹身份验证的应用，每个应用必须独立验证用户的指纹。</p><p>要在您的应用中使用此功能，请先在清单中添加 <code>USE_FINGERPRINT</code> 权限。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.permission.USE_FINGERPRINT"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>要查看指纹身份验证的应用实现，请参阅<a href="https://developer.android.com/samples/FingerprintDialog/index.html" target="_blank" rel="noopener">FingerprintDialog 示例</a>。要查看有关将这些身份验证 API 与其他 Android API 结合使用方法的演示，请观看视频 <a href="https://www.youtube.com/watch?v=VOn7VrTRlA4" target="_blank" rel="noopener">Fingerprint API 和 Payment API</a>。<br><img src="/2016/04/30/android-6-0/fingerprint-screen.png" style="width:200px; float:right"><br>如果您要测试此功能，请执行以下步骤：</p><ol><li>如果您尚未安装 Android SDK 工具 24.3 修订版，请执行此操作。</li><li>转到 <strong>Settings &gt; Security &gt; Fingerprint</strong>，然后按照登记说明在模拟器中登记新指纹。</li><li>使用模拟器通过以下命令模拟指纹触摸事件。使用同一命令模拟锁屏上或应用中的指纹触摸事件。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -e emu finger touch &lt;finger_id&gt;</span><br></pre></td></tr></table></figure></li></ol><p>在 Windows 上，您可能需要运行带有 finger touch &lt;finger_id&gt; 参数的 telnet 127.0.0.1 <emulator-id> 命令。</emulator-id></p><h1 id="确认凭据"><a href="#确认凭据" class="headerlink" title="确认凭据"></a>确认凭据</h1><hr><p>您的应用可以根据用户在多久之前最后一次解锁设备来验证其身份。此功能让用户不必费心记忆应用特定密码，您也无需实现自己的身份验证用户界面。您的应用应当利用此功能并结合实现公钥或私钥，以进行用户身份验证。</p><p>要设置成功验证用户身份后可再次使用同一密钥的超时持续时间，请在设置<a href="https://developer.android.com/reference/javax/crypto/KeyGenerator.html" target="_blank" rel="noopener">KeyGenerator</a> 或<a href="https://developer.android.com/reference/java/security/KeyPairGenerator.html" target="_blank" rel="noopener">KeyPairGenerator</a> 时调用新增的 <code>setUserAuthenticationValidityDurationSeconds()</code> 方法。</p><p>避免过多显示重新验证对话框 – 您的应用应尝试先使用加密对象，如果超时到期，请使用 createConfirmDeviceCredentialIntent() 方法在您的应用内重新验证用户身份。</p><p>要查看此功能的应用实现，请参阅 <a href="https://developer.android.com/samples/ConfirmCredential/index.html" target="_blank" rel="noopener">ConfirmCredential 示例</a>。</p><h1 id="应用链接"><a href="#应用链接" class="headerlink" title="应用链接"></a>应用链接</h1><hr><p>此版本通过提供功能更强大的应用链接，增强了 Android 的 intent 系统。您可以利用此功能将应用与您拥有的某个 Web 域关联。平台可以根据此关联确定在处理特定 Web 链接时默认使用的应用，跳过提示用户选择应用的步骤。要了解如何实现此功能，请参阅<a href="https://developer.android.com/training/app-links/index.html" target="_blank" rel="noopener">处理应用链接</a>。</p><h1 id="自动备份应用"><a href="#自动备份应用" class="headerlink" title="自动备份应用"></a>自动备份应用</h1><hr><p>现在，系统可以自动为应用执行完整数据备份和恢复。您的应用的目标平台必须是 Android 6.0（API 级别 23），才能启用此行为；您无需额外添加任何代码。如果用户删除其 Google 帐户，其备份数据也会随之删除。要了解该功能的工作方式以及配置文件系统备份内容的方法，请参阅<a href="https://developer.android.com/training/backup/autosyncapi.html" target="_blank" rel="noopener">配置应用自动备份</a>。</p><h1 id="直接共享"><a href="#直接共享" class="headerlink" title="直接共享"></a>直接共享</h1><hr><p><img src="/2016/04/30/android-6-0/direct-share-screen.png" style="width:200px; float:right; margin_left:20px"><br>此版本为您提供的一些 API 可让用户直观、快捷地进行共享。现在，您可以定义可在您的应用内启动特定 Activity 的直接共享目标。这些直接共享目标通过“共享”菜单公开给用户。此功能让用户可以向其他应用内的目标（如联系人）共享内容。例如，直接共享目标可以启动另一社交网络应用中的某个 Activity，让用户可以直接向该应用中的某位朋友或某个社区共享内容。</p><p>要启用直接共享目标，您必须定义一个类，用于扩展 <code>ChooserTargetService</code> 类。在清单中声明您的服务。在该声明内，指定 <code>BIND_CHOOSER_TARGET_SERVICE</code> 权限和一个使用 <code>SERVICE_INTERFACE</code> 操作的 intent 过滤器。</p><p>以下示例展示了如何在清单中声明 <code>ChooserTargetService</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".ChooserTargetService"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/service_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:permission</span>=<span class="string">"android.permission.BIND_CHOOSER_TARGET_SERVICE"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.service.chooser.ChooserTargetService"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>对于您想要向 <code>ChooserTargetService</code> 公开的每个 Activity，请在您的应用清单中为其添加一个名为 <strong>“android.service.chooser.chooser_target_service”</strong> 的 <code>&lt;meta-data&gt;</code> 元素。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MyShareActivity”</span></span></span><br><span class="line"><span class="tag"><span class="string">        android:label="</span>@<span class="attr">string</span>/<span class="attr">share_activity_label</span>"&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SEND"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">"android.service.chooser.chooser_target_service"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:value</span>=<span class="string">".ChooserTargetService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="语音交互"><a href="#语音交互" class="headerlink" title="语音交互"></a>语音交互</h1><hr><p>此版本提供了一个新的语音交互 API，与语音操作一起使用时，可让您为应用打造对话式语音体验。调用 <code>isVoiceInteraction()</code> 方法可确定是否是响应语音操作触发了您的 Activity。如果是这样，则您的应用可以使用 <code>VoiceInteractor</code> 类请求用户进行语音确认、从选项列表中进行选择以及执行其他操作。</p><p>大多数语音交互都由用户语音操作发起。但语音交互 Activity 也可在没有用户输入的情况下启动。例如，通过语音交互启动的另一应用也可发送 intent 来启动语音交互。要确定您的 Activity 是由用户语音查询还是另一语音交互应用启动，请调用 <code>isVoiceInteractionRoot()</code> 方法。如果另一应用启动了您的 Activity，该方法会返回 false。您的应用可能随即提示用户确认其有意执行此操作。</p><p>要详细了解如何实现语音操作，请参阅<a href="https://developers.google.com/voice-actions/interaction/" target="_blank" rel="noopener">语音操作开发者网站</a>。</p><h1 id="Assist-API"><a href="#Assist-API" class="headerlink" title="Assist API"></a>Assist API</h1><hr><p>此版本提供了一种让用户通过助手程序与应用进行互动的新方式。要使用此功能，用户必须启用助手以使用当前上下文。启用助手后，用户可通过长按首页按钮在任何应用内召唤助手。</p><p>您的应用可通过设置 <code>FLAG_SECURE</code> 标记选择不与助手共享当前上下文。除了平台传递给助手的一组标准信息外，您的应用还可利用新增的 <code>AssistContent</code> 类共享其他信息。</p><p>要为助手提供您的应用内的其他上下文，请执行以下步骤：</p><ol><li>实现 <code>Application.OnProvideAssistDataListener</code> 接口。</li><li>利用 <code>registerOnProvideAssistDataListener()</code> 注册此侦听器。</li><li>要提供特定于 Activity 的上下文信息，请重写 <code>onProvideAssistData()</code> 回调和新的 <code>onProvideAssistContent()</code> 回调（可选操作）。<h1 id="可采用的存储设备"><a href="#可采用的存储设备" class="headerlink" title="可采用的存储设备"></a>可采用的存储设备</h1></li></ol><hr><p>使用此版本时，用户可以采用 SD 卡等外部存储设备。采用外部存储设备可加密和格式化设备，使其具有类似内部存储设备的行为。用户可以利用此特性在存储设备之间移动应用及其私有数据。移动应用时，系统会遵守清单中的 <code>android:installLocation</code> 首选项。</p><p>请注意，在内部存储设备与外部存储设备之间移动应用时，如果您的应用访问以下 API 或字段，它们返回的文件路径将会动态变化。强烈建议：在生成文件路径时，请始终动态调用这些 API。请勿使用硬编码文件路径或之前生成的永久性完全限定文件路径。</p><ul><li><code>Context</code> 方法：<ul><li><code>getFilesDir()</code></li><li><code>getCacheDir()</code></li><li><code>getCodeCacheDir()</code></li><li><code>getDatabasePath()</code></li><li><code>getDir()</code></li><li><code>getNoBackupFilesDir()</code></li><li><code>getFileStreamPath()</code></li><li><code>getPackageCodePath()</code></li><li><code>getPackageResourcePath()</code></li></ul></li><li><code>ApplicationInfo</code> 字段：<ul><li><code>dataDir</code></li><li><code>sourceDir</code></li><li><code>nativeLibraryDir</code></li><li><code>publicSourceDir</code></li><li><code>splitSourceDirs</code></li><li><code>splitPublicSourceDirs</code></li></ul></li></ul><p>要调试此功能，您可以将一个 USB 驱动器通过一根 USB On-The-Go (OTG) 电缆连接到 Android 设备并运行以下命令启用该 USB 驱动器：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ adb shell sm <span class="built_in">set</span>-force-adoptable <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><hr><p>此版本针对通知功能引入了下列 API 变更：</p><ul><li>新增了 <code>INTERRUPTION_FILTER_ALARMS</code> 过滤级别，它对应于新增的“仅闹铃”免打扰模式。</li><li>新增了 <code>CATEGORY_REMINDER</code> 类别值，用于区分用户安排的提醒与其他事件 (<code>CATEGORY_EVENT</code>) 和闹铃 (<code>CATEGORY_ALARM</code>)。</li><li>新增了 <code>Icon</code> 类，您可以通过 <code>setSmallIcon()</code>方法和 <code>setLargeIcon()</code>方法将其附加到通知上。同理，<code>addAction()</code> 方法现在接受 <code>Icon</code> 对象，而不接受可绘制资源 ID。</li><li>新增了 <code>getActiveNotifications()</code> 方法，让您的应用能够了解哪些通知目前处于活动状态。要查看使用此功能的应用实现，请参阅 <code>ActiveNotifications</code> 示例。</li></ul><h1 id="蓝牙触控笔支持"><a href="#蓝牙触控笔支持" class="headerlink" title="蓝牙触控笔支持"></a>蓝牙触控笔支持</h1><hr><p>此版本改善了对用户使用蓝牙触控笔进行输入的支持。用户可将兼容的蓝牙触控笔与其手机或平板电脑配对并建立连接。连接后，来自触摸屏的位置信息将与来自触控笔的压力和按键信息融合，从而实现比单纯使用触摸屏更丰富的表达。您的应用可以通过在 Activity 中注册 <code>View.OnContextClickListener</code> 对象和 <code>GestureDetector.OnContextClickListener</code> 对象，侦听触控笔按键动作并执行辅助操作。</p><p>可使用 <code>MotionEvent</code> 方法和常量来检测触控笔按键交互：</p><ul><li>如果用户使用带按键的触控笔触按应用屏幕，<code>getTooltype()</code> 方法会返回 <code>TOOL_TYPE_STYLUS</code>。</li><li>对于以 Android 6.0（API 级别 23）为目标平台的应用，当用户按触控笔的主按键时，<code>getButtonState()</code> 方法会返回 <code>BUTTON_STYLUS_PRIMARY</code>。如果触控笔有辅助按键，当用户按下它时，该方法会返回 <code>BUTTON_STYLUS_SECONDARY</code>。如果用户同时按下两个按键，该方法会同时返回通过 OR 运算符连接起来的两个值 (<code>BUTTON_STYLUS_PRIMARY|BUTTON_STYLUS_SECONDARY</code>)。</li><li>对于以较低平台版本为目标的应用，<code>getButtonState()</code> 方法返回 <code>BUTTON_SECONDARY</code>（按下触控笔主按键时）、<code>BUTTON_TERTIARY</code>（按下触控笔辅助按键时）之一或同时返回这两者。</li></ul><h1 id="改进的蓝牙低功耗扫描"><a href="#改进的蓝牙低功耗扫描" class="headerlink" title="改进的蓝牙低功耗扫描"></a>改进的蓝牙低功耗扫描</h1><hr><p>如果您的应用执行蓝牙低功耗扫描，可以使用新增的 <code>setCallbackType()</code> 方法指定您只希望在下列条件下通知回调：首次找到与设置的 <code>ScanFilter</code> 匹配的播发数据包，或者已过很长时间后才再次看到该数据包。这种扫描方法与旧平台版本中提供的方法相比更加节能。</p><h1 id="Hotspot-2-0-第-1-版支持"><a href="#Hotspot-2-0-第-1-版支持" class="headerlink" title="Hotspot 2.0 第 1 版支持"></a>Hotspot 2.0 第 1 版支持</h1><hr><p>此版本在 Nexus 6 和 Nexus 9 设备上添加了对 Hotspot 2.0 第 1 版规范的支持。要在您的应用中配置 Hotspot 2.0 凭据，请使用 <code>WifiEnterpriseConfig</code> 类的新方法，如 <code>setPlmn()</code> 方法和 <code>setRealm()</code> 方法。在 <code>WifiConfiguration</code> 对象中，您可以设置 <code>FQDN</code> 字段和 <code>providerFriendlyName</code> 字段。新增的 <code>isPasspointNetwork()</code> 方法可指示检测到的网络是否为 Hotspot 2.0 接入点。</p><h1 id="4K-显示模式"><a href="#4K-显示模式" class="headerlink" title="4K 显示模式"></a>4K 显示模式</h1><hr><p>现在，平台允许应用在兼容硬件上请求将显示分辨率升级到 4K 渲染。要查询当前物理分辨率，请使用新增的 <code>Display.Mode</code> API。请注意，如果 UI 是以较低逻辑分辨率绘制并通过放大达到更高的物理分辨率，则 <code>getPhysicalWidth()</code> 方法返回的物理分辨率可能不同于 <code>getSize()</code> 所报告的逻辑分辨率。</p><p>您可以通过设置应用窗口的 <code>preferredDisplayModeId</code> 属性请求系统更改应用运行时的物理分辨率。如果您想切换到 4K 显示分辨率，此功能会很有帮助。在 4K 显示模式下，UI 仍然以原始分辨率（如 1080p）渲染，通过放大达到 4K，但 <code>SurfaceView</code> 对象可能会以原生分辨率显示内容。</p><h1 id="主题化-ColorStateList"><a href="#主题化-ColorStateList" class="headerlink" title="主题化 ColorStateList"></a>主题化 ColorStateList</h1><hr><p>对于运行 Android 6.0（API 级别 23）的设备，现在支持在 <code>ColorStateList</code> 中使用主题属性。<code>Resources.getColorStateList()</code> 方法和 <code>Resources.getColor()</code> 方法已弃用。如果您要调用这些 API，请改为调用新增的 <code>Context.getColorStateList()</code> 方法或 <code>Context.getColor()</code> 方法。还可在 v4 appcompat 库中通过 <code>ContextCompat</code> 使用这些方法。</p><h1 id="音频功能"><a href="#音频功能" class="headerlink" title="音频功能"></a>音频功能</h1><hr><p>此版本增强了 Android 上的音频处理功能，包括：</p><ul><li>通过新增的 <code>android.media.midi</code> API 提供了对 <code>MIDI</code> 协议的支持。使用这些 API 可发送和接收 <code>MIDI</code> 事件。</li><li>新增了 <code>AudioRecord.Builder</code> 类和 <code>AudioTrack.Builder</code> 类，分别用于创建数字音频采集和回放对象，还可用于配置音频源和接收器属性来替换系统默认值。</li><li>用于关联音频和输入设备的 API 钩子。如果您的应用允许用户通过与 Android TV 相连的游戏控制器或遥控器启动语音搜索，此功能尤为有用。系统会在用户启动搜索时调用新增的 <code>onSearchRequested()</code> 回调。要确定用户的输入设备是否内置麦克风，请从该回调检索 InputDevice 对象，然后调用新的 <code>hasMicrophone()</code> 方法。</li><li>新增了 <code>getDevices()</code> 方法，让您可以检索系统当前连接的所有音频设备的列表。如果您想让系统在音频设备连接或断开时通知应用，还可以注册一个 <code>AudioDeviceCallback</code> 对象。</li></ul><h1 id="视频功能"><a href="#视频功能" class="headerlink" title="视频功能"></a>视频功能</h1><hr><p>此版本为视频处理 API 添加了新功能，包括：</p><ul><li>新增了 <code>MediaSync</code> 类，可帮助应用同步渲染音频流和视频流。音频缓冲区以非锁定方式提交，并通过回调返回。此外，它还支持动态回放速率。</li><li>新增了 <code>EVENT_SESSION_RECLAIMED</code> 事件，它表示应用打开的会话已被资源管理器收回。如果您的应用使用 DRM 会话，则应处理此事件，并确保不使用收回的会话。</li><li>新增了 <code>ERROR_RECLAIMED</code> 错误代码，它表示资源管理器收回了编解码器使用的媒体资源。出现此异常时，必须释放编解码器，因为它已转入终止状态。</li><li>新增了 <code>getMaxSupportedInstances()</code> 接口，用于获取有关支持的编解码器实例最大并发数量的提示。</li><li>新增了 <code>setPlaybackParams()</code> 方法，用于设置快动作回放或慢动作回放的媒体回放速率。此外，它还会随视频一起自动拉长或加速音频回放。</li></ul><h2 id="相机功能"><a href="#相机功能" class="headerlink" title="#相机功能"></a>#相机功能</h2><p>此版本提供了下列用于访问相机闪光灯和相机图像再处理的新 API：</p><h2 id="Flashlight-API"><a href="#Flashlight-API" class="headerlink" title="Flashlight API"></a>Flashlight API</h2><p>如果相机设备带有闪光灯，您可以通过调用 <code>setTorchMode()</code> 方法，在不打开相机设备的情况下打开或关闭闪光灯的火炬模式。应用对闪光灯或相机设备不享有独占所有权。每当相机设备不可用，或者开启火炬的其他相机资源不可用时，火炬模式即会被关闭并变为不可用状态。其他应用也可调用 <code>setTorchMode()</code> 来关闭火炬模式。当最后一个开启火炬模式的应用关闭时，火炬模式就会被关闭。</p><p>您可以注册一个回调，通过调用 <code>registerTorchCallback()</code> 方法接收有关火炬模式状态的通知。第一次注册回调时，系统会立即调用它，并返回所有当前已知配备闪光灯的相机设备的火炬模式状态。如果成功开启或关闭火炬模式，系统会调用 <code>onTorchModeChanged()</code> 方法。</p><h2 id="Reprocessing-API"><a href="#Reprocessing-API" class="headerlink" title="Reprocessing API"></a>Reprocessing API</h2><p><code>Camera2</code> API 进行了扩展，以支持 YUV 和专用不透明格式图像再处理。要确定这些再处理功能是否可用，请调用 <code>getCameraCharacteristics()</code> 并检查有无 <code>REPROCESS_MAX_CAPTURE_STALL</code> 密钥。如果设备支持再处理，您可以通过调用 <code>createReprocessableCaptureSession()</code> 创建一个可再处理的相机采集会话并创建输入缓冲区再处理请求。</p><p>使用 <code>ImageWriter</code> 类可将输入缓冲区流与相机再处理输入相连。要获得空白缓冲区，请遵循以下编程模型：</p><ol><li>调用 <code>dequeueInputImage()</code> 方法。</li><li>在输入缓冲区中填充数据。</li><li>通过调用 <code>queueInputImage()</code>方法将缓冲区发送至相机。</li></ol><p>如果您将 <code>ImageWriter</code> 对象与 <code>PRIVATE</code> 图像一起使用，您的应用并不能直接访问图像数据。请改为调用 <code>queueInputImage()</code> 方法，将 <code>PRIVATE</code> 图像直接传递给 <code>ImageWriter</code>，而不进行任何缓冲区复制。</p><p><code>ImageReader</code> 类现在支持 PRIVATE 格式图像流。凭借此支持特性，您的应用可使 <code>ImageReader</code> 输出图像保持为循环图像队列，还可选择一个或多个图像并将其发送给 <code>ImageWriter</code> 进行相机再处理。</p><h1 id="Android-for-Work-功能"><a href="#Android-for-Work-功能" class="headerlink" title="Android for Work 功能"></a>Android for Work 功能</h1><hr><p>此版本提供了下列用于 Android for Work 的新 API：</p><ul><li><strong>用于企业所有、单一用途设备的增强型控件：</strong>现在，设备所有者可以通过控制以下设置来改善 企业所有、单一用途 (COSU) 设备的管理：<ul><li>通过 <code>setKeyguardDisabled()</code> 方法停用或重新启用键盘锁。</li><li>通过 <code>setStatusBarDisabled()</code> 方法停用或重新启用状态栏（包括快速设置、通知以及启动 Google 即时的向上划动导航手势）。</li><li>通过 <code>UserManager</code> 常量 <code>DISALLOW_SAFE_BOOT</code> 停用或重新启用安全启动。</li><li>通过 <code>STAY_ON_WHILE_PLUGGED_IN</code> 常量防止屏幕在插入电源的情况下关闭。</li></ul></li><li><strong>设备所有者静默式安装和卸载应用：</strong>现在，设备所有者可使用 <code>PackageInstaller</code> API 在不依赖 Google Play for Work 的情况下静默式安装和卸载应用。现在，您可以通过设备所有者配置设备，从而无需用户干预即可获取并安装应用。此功能可用于在不激活 Google 帐户的情况下实现信息亭或其他此类设备的一键式配置。</li><li><strong>静默式企业证书访问：</strong> 现在，当应用调用 <code>choosePrivateKeyAlias()</code> 时，配置文件所有者或设备所有者可以在系统提示用户选择证书前调用 <code>onChoosePrivateKeyAlias()</code> 方法，静默式向发出请求的应用提供别名。此功能让您可以在无需用户交互的情况下授予托管应用访问证书的权限。</li><li><strong>自动接受系统更新：</strong>现在，设备所有者可以通过 <code>setSystemUpdatePolicy()</code> 设置一个系统更新政策来自动接受系统更新（例如对于信息亭设备），或者推迟更新并在至多 30 天的时间内防止用户获取更新。此外，管理员还可设置每日必须获取更新的时间窗口，例如在信息亭设备无人使用的时段。有可用的系统更新时，系统会检查设备规范控制器应用是否设置了系统更新政策，并相应地执行操作。</li><li><strong>授权证书安装：</strong>配置文件所有者或设备所有者现在可以授权第三方应用调用以下 <code>DevicePolicyManager</code> 证书管理 API：<ul><li><code>getInstalledCaCerts()</code></li><li><code>hasCaCertInstalled()</code></li><li><code>installCaCert()</code></li><li><code>uninstallCaCert()</code></li><li><code>uninstallAllUserCaCerts()</code></li><li><code>installKeyPair()</code><br><img src="/2016/04/30/android-6-0/work-profile-screen.png" style="width:200px; float:right; margin_left:20px"></li></ul></li><li><strong>流量消耗情况跟踪：</strong>现在，配置文件所有者或设备所有者可以利用新增的 <code>NetworkStatsManager</code> 方法查询 <strong>Settings &gt; Data Usage</strong> 中显示的流量使用情况统计信息。配置文件所有者会被自动授予查询其管理的配置文件相关数据的权限，而设备所有者则被授予对其管理的主要用户使用情况数据的访问权。</li><li><p><strong>运行时权限管理：</strong>配置文件所有者或设备所有者可以利用 <code>setPermissionPolicy()</code> 设置适用于所有应用全部运行时请求的权限政策，以提示用户授予权限，或自动以静默方式授予或拒绝权限。如果设置后一种政策，则用户将无法修改配置文件所有者或设备所有者在应用权限屏幕的 Settings 内所做的选择。</p></li><li><p><strong>Settings 中的 VPN：</strong>现在，<strong>Settings &gt; More &gt; VPN</strong> 中会显示 VPN 应用。此外，现在，关于 VPN 使用情况的通知取决于该 VPN 的配置方式。对于配置文件所有者，通知取决于该 VPN 是针对托管配置文件、个人配置文件还是同时针对这两者进行配置。对于设备所有者，通知取决于 VPN 是否针对整个设备进行配置。</p></li><li><strong>工作状态通知：</strong>现在，每当来自托管配置文件的应用具有前台 Activity 时，状态栏就会出现一个公文包图标。此外，如果设备直接解锁到托管配置文件中某个应用的 Activity，则会显示一个 Toast，通知用户他们位于托管配置文件内。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android 6.0 (M) 为用户和应用开发者提供了新功能。本文旨在介绍其中最值得关注的 API。&lt;/p&gt;
&lt;h2 id=&quot;着手开发&quot;&gt;&lt;a href=&quot;#着手开发&quot; class=&quot;headerlink&quot; title=&quot;着手开发&quot;&gt;&lt;/a&gt;着手开发&lt;/h2&gt;&lt;p&gt;要着手
      
    
    </summary>
    
    
      <category term="Anroid" scheme="http://yoursite.com/tags/Anroid/"/>
    
      <category term="Marshmallow" scheme="http://yoursite.com/tags/Marshmallow/"/>
    
      <category term="Anroid6.0" scheme="http://yoursite.com/tags/Anroid6-0/"/>
    
      <category term="Android Developers" scheme="http://yoursite.com/tags/Android-Developers/"/>
    
  </entry>
  
</feed>
